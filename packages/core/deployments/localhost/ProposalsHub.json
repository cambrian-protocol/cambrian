{
  "address": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_ctfAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "CreateProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "DefundProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "ExecuteProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "from",
          "type": "address"
        }
      ],
      "name": "FundProposal",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "conditionalTokens",
      "outputs": [
        {
          "internalType": "contract IConditionalTokens",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "baseId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "collateralToken",
          "type": "address"
        },
        {
          "internalType": "contract IIPFSSolutionsHub",
          "name": "ipfsSolutionsHub",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "fundingGoal",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "contract Solver",
              "name": "implementation",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "keeper",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "arbitrator",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "timelockSeconds",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "executions",
                  "type": "uint256"
                },
                {
                  "internalType": "enum SolverLib.IngestType",
                  "name": "ingestType",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "slot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "solverIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                }
              ],
              "internalType": "struct SolverLib.Ingest[]",
              "name": "ingests",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "contract IERC20",
                  "name": "collateralToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "outcomeSlots",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "parentCollectionIndexSet",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "amountSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256[]",
                  "name": "partition",
                  "type": "uint256[]"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "recipientAddressSlot",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "bytes32[]",
                      "name": "recipientAmountSlots",
                      "type": "bytes32[]"
                    }
                  ],
                  "internalType": "struct SolverLib.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "digest",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint8",
                      "name": "hashFunction",
                      "type": "uint8"
                    },
                    {
                      "internalType": "uint8",
                      "name": "size",
                      "type": "uint8"
                    }
                  ],
                  "internalType": "struct SolverLib.Multihash[]",
                  "name": "outcomeURIs",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct SolverLib.ConditionBase",
              "name": "conditionBase",
              "type": "tuple"
            }
          ],
          "internalType": "struct SolverLib.Config[]",
          "name": "solverConfigs",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "digest",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "hashFunction",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "size",
              "type": "uint8"
            }
          ],
          "internalType": "struct SolverLib.Multihash",
          "name": "solverConfigsCID",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "digest",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "hashFunction",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "size",
              "type": "uint8"
            }
          ],
          "internalType": "struct SolverLib.Multihash",
          "name": "metadataCID",
          "type": "tuple"
        }
      ],
      "name": "createIPFSSolutionAndProposal",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "solutionId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "collateralToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "solutionsHub",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "fundingGoal",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "baseId",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "digest",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "hashFunction",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "size",
              "type": "uint8"
            }
          ],
          "internalType": "struct SolverLib.Multihash",
          "name": "metadataCID",
          "type": "tuple"
        }
      ],
      "name": "createProposal",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "solutionId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "defundProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "contract Solver",
              "name": "implementation",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "keeper",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "arbitrator",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "timelockSeconds",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "executions",
                  "type": "uint256"
                },
                {
                  "internalType": "enum SolverLib.IngestType",
                  "name": "ingestType",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "slot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "solverIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                }
              ],
              "internalType": "struct SolverLib.Ingest[]",
              "name": "ingests",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "contract IERC20",
                  "name": "collateralToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "outcomeSlots",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "parentCollectionIndexSet",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "amountSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256[]",
                  "name": "partition",
                  "type": "uint256[]"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "recipientAddressSlot",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "bytes32[]",
                      "name": "recipientAmountSlots",
                      "type": "bytes32[]"
                    }
                  ],
                  "internalType": "struct SolverLib.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "digest",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint8",
                      "name": "hashFunction",
                      "type": "uint8"
                    },
                    {
                      "internalType": "uint8",
                      "name": "size",
                      "type": "uint8"
                    }
                  ],
                  "internalType": "struct SolverLib.Multihash[]",
                  "name": "outcomeURIs",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct SolverLib.ConditionBase",
              "name": "conditionBase",
              "type": "tuple"
            }
          ],
          "internalType": "struct SolverLib.Config[]",
          "name": "solverConfigs",
          "type": "tuple[]"
        }
      ],
      "name": "executeIPFSProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "fundProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "funderAmountMap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "getMetadataCID",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "digest",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "hashFunction",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "size",
              "type": "uint8"
            }
          ],
          "internalType": "struct SolverLib.Multihash",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "getProposal",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isExecuted",
              "type": "bool"
            },
            {
              "internalType": "contract IERC20",
              "name": "collateralToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "proposer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "solutionsHub",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "solutionId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "funding",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fundingGoal",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "bytes32",
                  "name": "digest",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint8",
                  "name": "hashFunction",
                  "type": "uint8"
                },
                {
                  "internalType": "uint8",
                  "name": "size",
                  "type": "uint8"
                }
              ],
              "internalType": "struct SolverLib.Multihash",
              "name": "metadataCID",
              "type": "tuple"
            }
          ],
          "internalType": "struct ProposalsHub.Proposal",
          "name": "proposal",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "isProposal",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onERC1155BatchReceived",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "proposals",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isExecuted",
          "type": "bool"
        },
        {
          "internalType": "contract IERC20",
          "name": "collateralToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "solutionsHub",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "solutionId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "funding",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fundingGoal",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "digest",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "hashFunction",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "size",
              "type": "uint8"
            }
          ],
          "internalType": "struct SolverLib.Multihash",
          "name": "metadataCID",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "reclaimTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "reclaimableTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "reclaimedTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "solver",
          "type": "address"
        }
      ],
      "name": "transferERC20",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xbbf73f6265b8634ae7a01efe91b0735bc36bc71315a012858d8147890ffb507d",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    "transactionIndex": 0,
    "gasUsed": "2179541",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc9f7480e59f9d5e547057a1dfdf03eb6ce9831b5c44834ad2f3a1fa46a8bef2b",
    "transactionHash": "0xbbf73f6265b8634ae7a01efe91b0735bc36bc71315a012858d8147890ffb507d",
    "logs": [],
    "blockNumber": 3,
    "cumulativeGasUsed": "2179541",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5FbDB2315678afecb367f032d93F642f64180aa3"
  ],
  "solcInputHash": "8f94e83f8717c76ee706b6f7449e8204",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ctfAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"CreateProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"DefundProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ExecuteProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"FundProposal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"conditionalTokens\",\"outputs\":[{\"internalType\":\"contract IConditionalTokens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"baseId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"contract IIPFSSolutionsHub\",\"name\":\"ipfsSolutionsHub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingGoal\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract Solver\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelockSeconds\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"executions\",\"type\":\"uint256\"},{\"internalType\":\"enum SolverLib.IngestType\",\"name\":\"ingestType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"solverIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SolverLib.Ingest[]\",\"name\":\"ingests\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outcomeSlots\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parentCollectionIndexSet\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"amountSlot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"partition\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recipientAddressSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"recipientAmountSlots\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SolverLib.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashFunction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverLib.Multihash[]\",\"name\":\"outcomeURIs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SolverLib.ConditionBase\",\"name\":\"conditionBase\",\"type\":\"tuple\"}],\"internalType\":\"struct SolverLib.Config[]\",\"name\":\"solverConfigs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashFunction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverLib.Multihash\",\"name\":\"solverConfigsCID\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashFunction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverLib.Multihash\",\"name\":\"metadataCID\",\"type\":\"tuple\"}],\"name\":\"createIPFSSolutionAndProposal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"solutionId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solutionsHub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingGoal\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"baseId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashFunction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverLib.Multihash\",\"name\":\"metadataCID\",\"type\":\"tuple\"}],\"name\":\"createProposal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"solutionId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"defundProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"contract Solver\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelockSeconds\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"executions\",\"type\":\"uint256\"},{\"internalType\":\"enum SolverLib.IngestType\",\"name\":\"ingestType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"solverIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SolverLib.Ingest[]\",\"name\":\"ingests\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outcomeSlots\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parentCollectionIndexSet\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"amountSlot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"partition\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recipientAddressSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"recipientAmountSlots\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SolverLib.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashFunction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverLib.Multihash[]\",\"name\":\"outcomeURIs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SolverLib.ConditionBase\",\"name\":\"conditionBase\",\"type\":\"tuple\"}],\"internalType\":\"struct SolverLib.Config[]\",\"name\":\"solverConfigs\",\"type\":\"tuple[]\"}],\"name\":\"executeIPFSProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fundProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"funderAmountMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getMetadataCID\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashFunction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverLib.Multihash\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solutionsHub\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"solutionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"funding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingGoal\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashFunction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverLib.Multihash\",\"name\":\"metadataCID\",\"type\":\"tuple\"}],\"internalType\":\"struct ProposalsHub.Proposal\",\"name\":\"proposal\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"isProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solutionsHub\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"solutionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"funding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingGoal\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashFunction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverLib.Multihash\",\"name\":\"metadataCID\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"reclaimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reclaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reclaimedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createProposal(address,address,uint256,bytes32,(bytes32,uint8,uint8))\":{\"details\":\"Creates a Proposal from an existing Solution.Base\",\"params\":{\"baseId\":\"ID of the Solution.Base for which a new instance and proposal is created\",\"collateralToken\":\"ERC20 token being used as collateral for conditional tokens\",\"fundingGoal\":\"Amount of ERC20 collateral requested for the Proposal\",\"solutionsHub\":\"Address of the SolutionsHub contract managing the Solution\"}},\"defundProposal(bytes32,address,uint256)\":{\"details\":\"Called by user to remove their funding from a Proposal\",\"params\":{\"amount\":\"Amount to be defunded\",\"proposalId\":\"ID of Proposal being defunded\",\"token\":\"ERC20 token to be defunded\"}},\"executeIPFSProposal(bytes32,(address,address,address,uint256,bytes,(uint256,uint8,bytes32,uint256,bytes)[],(address,uint256,uint256,bytes32,uint256[],(bytes32,bytes32[])[],(bytes32,uint8,uint8)[]))[])\":{\"details\":\"Executes a proposal for Solutions where on the *hash* of solver configs is stored on-chain\",\"params\":{\"proposalId\":\"ID of proposal\",\"solverConfigs\":\"Configurations of Solvers to be run for the proposed solution\"}},\"fundProposal(bytes32,address,uint256)\":{\"details\":\"Called by user to add funding to a Proposal\",\"params\":{\"amount\":\"Amount to be funded\",\"proposalId\":\"ID of Proposal being funded\",\"token\":\"ERC20 token to be funded with\"}},\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\":{\"details\":\"Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` (i.e. 0xbc197c81, or its own function selector).\",\"params\":{\"data\":\"Additional data with no specified format\",\"from\":\"The address which previously owned the token\",\"ids\":\"An array containing ids of each token being transferred (order and length must match values array)\",\"operator\":\"The address which initiated the batch transfer (i.e. msg.sender)\",\"values\":\"An array containing amounts of each token being transferred (order and length must match ids array)\"},\"returns\":{\"_0\":\"`bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\"}},\"reclaimTokens(bytes32,uint256)\":{\"details\":\"Transfers reclaimable CTs to a claimer and lowers their reclaimable balance for that token\",\"params\":{\"proposalId\":\"ID of proposal being reclaimed from\",\"tokenId\":\"ERC1155 token being reclaimed\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"transferERC20(bytes32,address)\":{\"details\":\"Called by SolutionsHub after deploying Solvers\",\"params\":{\"proposalId\":\"Proposal that collateral is being transferred from\",\"solver\":\"Solver receiving collateral\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"onERC1155Received(address,address,uint256,uint256,bytes)\":{\"notice\":\"IMPORTANT! Any CTs sent to this contract are reclaimable by the funders in proportion to their funding. If a user reclaims CTs and sends them back again to this contract, they will only be able to  regain from them a fraction of their original funding.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ProposalsHub.sol\":\"ProposalsHub\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7454006cccb737612b00104d2f606d728e2818b778e7e55542f063c614ce46ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][account] = accountBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\",\"keccak256\":\"0xbda715785876dbfc675396b89ac45bb9f4cceb968133a8258924d163a700f0e4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xfce1eb6398eae0e2b50251140866a70a3106193f101972c878bba1dbf44929ec\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7de6e64d4a8075e803a972cc77c4c91463e0c3777e4110eacfb5d4a71759b2fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x6ba0564f6970414d1166ee83127b834bbe7dbf699241a3005eb7ae64a2211975\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0x8c578d9e30c8f2bb7ac01d108766df87d42b73d4d3638f01d494a894fe7c1f4b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3336baae5cf23e94274d75336e2d412193be508504aee185e61dc7d58cd05c8a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x5718c5df9bd67ac68a796961df938821bb5dc0cd4c6118d77e9145afb187409b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa28007762d9da9db878dd421960c8cb9a10471f47ab5c1b3309bfe48e9e79ff4\",\"license\":\"MIT\"},\"contracts/CTHelpers.sol\":{\"content\":\"/** \\r\\n    SPDX-License-Identifier: LGPL-3.0\\r\\n    Copied from Gnosis\\r\\n    Updated for Solidity 0.8.0\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nlibrary CTHelpers {\\r\\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function getConditionId(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) internal pure returns (bytes32) {\\r\\n        return\\r\\n            keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\\r\\n    }\\r\\n\\r\\n    uint256 constant P =\\r\\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\\r\\n    uint256 constant B = 3;\\r\\n\\r\\n    function sqrt(uint256 x) private pure returns (uint256 y) {\\r\\n        uint256 p = P;\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly {\\r\\n            // add chain generated via https://crypto.stackexchange.com/q/27179/71252\\r\\n            // and transformed to the following program:\\r\\n\\r\\n            // x=1; y=x+x; z=y+y; z=z+z; y=y+z; x=x+y; y=y+x; z=y+y; t=z+z; t=z+t; t=t+t;\\r\\n            // t=t+t; z=z+t; x=x+z; z=x+x; z=z+z; y=y+z; z=y+y; z=z+z; z=z+z; z=y+z; x=x+z;\\r\\n            // z=x+x; z=z+z; z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; z=y+y; t=z+z;\\r\\n            // t=t+t; t=t+t; z=z+t; x=x+z; y=y+x; z=y+y; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\\r\\n            // z=x+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; t=z+z; t=t+t; t=z+t; t=y+t; t=t+t;\\r\\n            // t=t+t; t=t+t; t=t+t; z=z+t; x=x+z; z=x+x; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z;\\r\\n            // t=z+z; t=z+t; w=t+t; w=w+w; w=w+w; w=w+w; w=w+w; t=t+w; z=z+t; x=x+z; y=y+x;\\r\\n            // z=y+y; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; z=z+z; y=y+z; z=y+y;\\r\\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; x=x+z; y=y+x; x=x+y; y=y+x; z=y+y; z=z+z;\\r\\n            // z=y+z; x=x+z; z=x+x; z=x+z; y=y+z; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; z=y+z;\\r\\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x; t=z+z; t=t+t; t=z+t;\\r\\n            // t=x+t; t=t+t; t=t+t; t=t+t; t=t+t; z=z+t; y=y+z; x=x+y; y=y+x; x=x+y; z=x+x;\\r\\n            // z=x+z; z=z+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x;\\r\\n            // z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; x=x+y; z=x+x; y=y+z; x=x+y; y=y+x;\\r\\n            // z=y+y; z=y+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\\r\\n            // z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; t=x+z; t=t+t; t=t+t; z=z+t; y=y+z; z=y+y;\\r\\n            // x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; t=y+z; z=y+t; z=z+z; z=z+z;\\r\\n            // z=t+z; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; y=y+z; x=x+y; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; res=y+x\\r\\n            // res == (P + 1) // 4\\r\\n\\r\\n            y := mulmod(x, x, p)\\r\\n            {\\r\\n                let z := mulmod(y, y, p)\\r\\n                z := mulmod(z, z, p)\\r\\n                y := mulmod(y, z, p)\\r\\n                x := mulmod(x, y, p)\\r\\n                y := mulmod(y, x, p)\\r\\n                z := mulmod(y, y, p)\\r\\n                {\\r\\n                    let t := mulmod(z, z, p)\\r\\n                    t := mulmod(z, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    t := mulmod(z, z, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    t := mulmod(z, z, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(z, t, p)\\r\\n                    t := mulmod(y, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    t := mulmod(z, z, p)\\r\\n                    t := mulmod(z, t, p)\\r\\n                    {\\r\\n                        let w := mulmod(t, t, p)\\r\\n                        w := mulmod(w, w, p)\\r\\n                        w := mulmod(w, w, p)\\r\\n                        w := mulmod(w, w, p)\\r\\n                        w := mulmod(w, w, p)\\r\\n                        t := mulmod(t, w, p)\\r\\n                    }\\r\\n                    z := mulmod(z, t, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    t := mulmod(z, z, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(z, t, p)\\r\\n                    t := mulmod(x, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    t := mulmod(x, z, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    t := mulmod(y, z, p)\\r\\n                    z := mulmod(y, t, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(t, z, p)\\r\\n                }\\r\\n                x := mulmod(x, z, p)\\r\\n                y := mulmod(y, x, p)\\r\\n                x := mulmod(x, y, p)\\r\\n                y := mulmod(y, x, p)\\r\\n                x := mulmod(x, y, p)\\r\\n                z := mulmod(x, x, p)\\r\\n                z := mulmod(x, z, p)\\r\\n                y := mulmod(y, z, p)\\r\\n            }\\r\\n            x := mulmod(x, y, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            y := mulmod(y, x, p)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\\r\\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\\r\\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\\r\\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\\r\\n    function getCollectionId(\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256 indexSet\\r\\n    ) internal view returns (bytes32) {\\r\\n        uint256 x1 = uint256(\\r\\n            keccak256(abi.encodePacked(conditionId, indexSet))\\r\\n        );\\r\\n        bool odd = x1 >> 255 != 0;\\r\\n        uint256 y1;\\r\\n        uint256 yy;\\r\\n        do {\\r\\n            x1 = addmod(x1, 1, P);\\r\\n            yy = addmod(mulmod(x1, mulmod(x1, x1, P), P), B, P);\\r\\n            y1 = sqrt(yy);\\r\\n        } while (mulmod(y1, y1, P) != yy);\\r\\n        if ((odd && y1 % 2 == 0) || (!odd && y1 % 2 == 1)) y1 = P - y1;\\r\\n\\r\\n        uint256 x2 = uint256(parentCollectionId);\\r\\n        if (x2 != 0) {\\r\\n            odd = x2 >> 254 != 0;\\r\\n            x2 = (x2 << 2) >> 2;\\r\\n            yy = addmod(mulmod(x2, mulmod(x2, x2, P), P), B, P);\\r\\n            uint256 y2 = sqrt(yy);\\r\\n            if ((odd && y2 % 2 == 0) || (!odd && y2 % 2 == 1)) y2 = P - y2;\\r\\n            require(mulmod(y2, y2, P) == yy, \\\"invalid parentID\\\");\\r\\n\\r\\n            (bool success, bytes memory ret) = address(6).staticcall(\\r\\n                abi.encode(x1, y1, x2, y2)\\r\\n            );\\r\\n            require(success, \\\"ecadd failed\\\");\\r\\n            (x1, y1) = abi.decode(ret, (uint256, uint256));\\r\\n        }\\r\\n\\r\\n        if (y1 % 2 == 1) x1 ^= 1 << 254;\\r\\n\\r\\n        return bytes32(x1);\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\\r\\n    /// @param collateralToken Collateral token which backs the position.\\r\\n    /// @param collectionId ID of the outcome collection associated with this position.\\r\\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(keccak256(abi.encodePacked(collateralToken, collectionId)));\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xe1f65df52607601f45e8a4954ea747c8322d9951ccd8a5d6b292d8f82fd859d4\",\"license\":\"LGPL-3.0\"},\"contracts/ConditionalTokens.sol\":{\"content\":\"/** \\r\\n    SPDX-License-Identifier: LGPL-3.0\\r\\n    Copied from Gnosis\\r\\n    Updated for Solidity 0.8.0\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport {ERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\r\\n\\r\\nimport {CTHelpers} from \\\"./CTHelpers.sol\\\";\\r\\n\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\n\\r\\n// Mainnet (ID: 1) canonical address: 0xC59b0e4De5F1248C1140964E0fF287B192407E0C\\r\\n// Rinkeby (ID: 4) canonical address: 0x36bede640D19981A82090519bC1626249984c908\\r\\n\\r\\ncontract ConditionalTokens is ERC1155 {\\r\\n    /// @dev Emitted upon the successful preparation of a condition.\\r\\n    /// @param conditionId The condition's ID. This ID may be derived from the other three parameters via ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    event ConditionPreparation(\\r\\n        bytes32 indexed conditionId,\\r\\n        address indexed oracle,\\r\\n        bytes32 indexed questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    );\\r\\n\\r\\n    event ConditionResolution(\\r\\n        bytes32 indexed conditionId,\\r\\n        address indexed oracle,\\r\\n        bytes32 indexed questionId,\\r\\n        uint256 outcomeSlotCount,\\r\\n        uint256[] payoutNumerators\\r\\n    );\\r\\n\\r\\n    /// @dev Emitted when a position is successfully split.\\r\\n    event PositionSplit(\\r\\n        address indexed stakeholder,\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 indexed parentCollectionId,\\r\\n        bytes32 indexed conditionId,\\r\\n        uint256[] partition,\\r\\n        uint256 amount\\r\\n    );\\r\\n    /// @dev Emitted when positions are successfully merged.\\r\\n    event PositionsMerge(\\r\\n        address indexed stakeholder,\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 indexed parentCollectionId,\\r\\n        bytes32 indexed conditionId,\\r\\n        uint256[] partition,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event PayoutRedemption(\\r\\n        address indexed redeemer,\\r\\n        IERC20 indexed collateralToken,\\r\\n        bytes32 indexed parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] indexSets,\\r\\n        uint256 payout\\r\\n    );\\r\\n\\r\\n    /// Mapping key is an condition ID. Value represents numerators of the payout vector associated with the condition. This array is initialized with a length equal to the outcome slot count. E.g. Condition with 3 outcomes [A, B, C] and two of those correct [0.5, 0.5, 0]. In Ethereum there are no decimal values, so here, 0.5 is represented by fractions like 1/2 == 0.5. That's why we need numerator and denominator values. Payout numerators are also used as a check of initialization. If the numerators array is empty (has length zero), the condition was not created/prepared. See getOutcomeSlotCount.\\r\\n    mapping(bytes32 => uint256[]) public payoutNumerators;\\r\\n    /// Denominator is also used for checking if the condition has been resolved. If the denominator is non-zero, then the condition has been resolved.\\r\\n    mapping(bytes32 => uint256) public payoutDenominator;\\r\\n\\r\\n    constructor() ERC1155(\\\"\\\") {}\\r\\n\\r\\n    /// @dev This function prepares a condition by initializing a payout vector associated with the condition.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function prepareCondition(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) external {\\r\\n        // Limit of 256 because we use a partition array that is a number of 256 bits.\\r\\n        require(outcomeSlotCount <= 256, \\\"too many outcome slots\\\");\\r\\n        require(\\r\\n            outcomeSlotCount > 1,\\r\\n            \\\"there should be more than one outcome slot\\\"\\r\\n        );\\r\\n        bytes32 conditionId = CTHelpers.getConditionId(\\r\\n            oracle,\\r\\n            questionId,\\r\\n            outcomeSlotCount\\r\\n        );\\r\\n        require(\\r\\n            payoutNumerators[conditionId].length == 0,\\r\\n            \\\"condition already prepared\\\"\\r\\n        );\\r\\n        payoutNumerators[conditionId] = new uint256[](outcomeSlotCount);\\r\\n        emit ConditionPreparation(\\r\\n            conditionId,\\r\\n            oracle,\\r\\n            questionId,\\r\\n            outcomeSlotCount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``, where oracle is the message sender, questionId is one of the parameters of this function, and outcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.\\r\\n    /// @param questionId The question ID the oracle is answering for\\r\\n    /// @param payouts The oracle's answer\\r\\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts)\\r\\n        external\\r\\n    {\\r\\n        uint256 outcomeSlotCount = payouts.length;\\r\\n        require(\\r\\n            outcomeSlotCount > 1,\\r\\n            \\\"there should be more than one outcome slot\\\"\\r\\n        );\\r\\n        // IMPORTANT, the oracle is enforced to be the sender because it's part of the hash.\\r\\n        bytes32 conditionId = CTHelpers.getConditionId(\\r\\n            msg.sender,\\r\\n            questionId,\\r\\n            outcomeSlotCount\\r\\n        );\\r\\n        require(\\r\\n            payoutNumerators[conditionId].length == outcomeSlotCount,\\r\\n            \\\"condition not prepared or found\\\"\\r\\n        );\\r\\n        require(\\r\\n            payoutDenominator[conditionId] == 0,\\r\\n            \\\"payout denominator already set\\\"\\r\\n        );\\r\\n\\r\\n        uint256 den = 0;\\r\\n        for (uint256 i = 0; i < outcomeSlotCount; i++) {\\r\\n            uint256 num = payouts[i];\\r\\n            den = den + num;\\r\\n\\r\\n            require(\\r\\n                payoutNumerators[conditionId][i] == 0,\\r\\n                \\\"payout numerator already set\\\"\\r\\n            );\\r\\n            payoutNumerators[conditionId][i] = num;\\r\\n        }\\r\\n        require(den > 0, \\\"payout is all zeroes\\\");\\r\\n        payoutDenominator[conditionId] = den;\\r\\n        emit ConditionResolution(\\r\\n            conditionId,\\r\\n            msg.sender,\\r\\n            questionId,\\r\\n            outcomeSlotCount,\\r\\n            payoutNumerators[conditionId]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev This function splits a position. If splitting from the collateral, this contract will attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this contract will burn `amount` stake held by the message sender in the position being split worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the split target positions. If any of the transfers, mints, or burns fail, the transaction will revert. The transaction will also revert if the given partition is trivial, invalid, or refers to more slots than the condition is prepared with.\\r\\n    /// @param collateralToken The address of the positions' backing collateral token.\\r\\n    /// @param parentCollectionId The ID of the outcome collections common to the position being split and the split target positions. May be null, in which only the collateral is shared.\\r\\n    /// @param conditionId The ID of the condition to split on.\\r\\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint). Each element's a number which, together with the condition, represents the outcome collection. E.g. 0b110 is A|B, 0b010 is B, etc.\\r\\n    /// @param amount The amount of collateral or stake to split.\\r\\n    function splitPosition(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata partition,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(partition.length > 1, \\\"got empty or singleton partition\\\");\\r\\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\\r\\n        require(outcomeSlotCount > 0, \\\"condition not prepared yet\\\");\\r\\n\\r\\n        // For a condition with 4 outcomes fullIndexSet's 0b1111; for 5 it's 0b11111...\\r\\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\\r\\n        // freeIndexSet starts as the full collection\\r\\n        uint256 freeIndexSet = fullIndexSet;\\r\\n        // This loop checks that all condition sets are disjoint (the same outcome is not part of more than 1 set)\\r\\n        uint256[] memory positionIds = new uint256[](partition.length);\\r\\n        uint256[] memory amounts = new uint256[](partition.length);\\r\\n        for (uint256 i = 0; i < partition.length; i++) {\\r\\n            uint256 indexSet = partition[i];\\r\\n            require(\\r\\n                indexSet > 0 && indexSet < fullIndexSet,\\r\\n                \\\"got invalid index set\\\"\\r\\n            );\\r\\n            require(\\r\\n                (indexSet & freeIndexSet) == indexSet,\\r\\n                \\\"partition not disjoint\\\"\\r\\n            );\\r\\n            freeIndexSet ^= indexSet;\\r\\n            positionIds[i] = CTHelpers.getPositionId(\\r\\n                collateralToken,\\r\\n                CTHelpers.getCollectionId(\\r\\n                    parentCollectionId,\\r\\n                    conditionId,\\r\\n                    indexSet\\r\\n                )\\r\\n            );\\r\\n            amounts[i] = amount;\\r\\n        }\\r\\n\\r\\n        if (freeIndexSet == 0) {\\r\\n            // Partitioning the full set of outcomes for the condition in this branch\\r\\n            if (parentCollectionId == bytes32(0)) {\\r\\n                require(\\r\\n                    collateralToken.transferFrom(\\r\\n                        msg.sender,\\r\\n                        address(this),\\r\\n                        amount\\r\\n                    ),\\r\\n                    \\\"could not receive collateral tokens\\\"\\r\\n                );\\r\\n            } else {\\r\\n                _burn(\\r\\n                    msg.sender,\\r\\n                    CTHelpers.getPositionId(\\r\\n                        collateralToken,\\r\\n                        parentCollectionId\\r\\n                    ),\\r\\n                    amount\\r\\n                );\\r\\n            }\\r\\n        } else {\\r\\n            // Partitioning a subset of outcomes for the condition in this branch.\\r\\n            // For example, for a condition with three outcomes A, B, and C, this branch\\r\\n            // allows the splitting of a position $:(A|C) to positions $:(A) and $:(C).\\r\\n            _burn(\\r\\n                msg.sender,\\r\\n                CTHelpers.getPositionId(\\r\\n                    collateralToken,\\r\\n                    CTHelpers.getCollectionId(\\r\\n                        parentCollectionId,\\r\\n                        conditionId,\\r\\n                        fullIndexSet ^ freeIndexSet\\r\\n                    )\\r\\n                ),\\r\\n                amount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        _mintBatch(\\r\\n            msg.sender,\\r\\n            // position ID is the ERC 1155 token ID\\r\\n            positionIds,\\r\\n            amounts,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n        emit PositionSplit(\\r\\n            msg.sender,\\r\\n            collateralToken,\\r\\n            parentCollectionId,\\r\\n            conditionId,\\r\\n            partition,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function mergePositions(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata partition,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(partition.length > 1, \\\"got empty or singleton partition\\\");\\r\\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\\r\\n        require(outcomeSlotCount > 0, \\\"condition not prepared yet\\\");\\r\\n\\r\\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\\r\\n        uint256 freeIndexSet = fullIndexSet;\\r\\n        uint256[] memory positionIds = new uint256[](partition.length);\\r\\n        uint256[] memory amounts = new uint256[](partition.length);\\r\\n        for (uint256 i = 0; i < partition.length; i++) {\\r\\n            uint256 indexSet = partition[i];\\r\\n            require(\\r\\n                indexSet > 0 && indexSet < fullIndexSet,\\r\\n                \\\"got invalid index set\\\"\\r\\n            );\\r\\n            require(\\r\\n                (indexSet & freeIndexSet) == indexSet,\\r\\n                \\\"partition not disjoint\\\"\\r\\n            );\\r\\n            freeIndexSet ^= indexSet;\\r\\n            positionIds[i] = CTHelpers.getPositionId(\\r\\n                collateralToken,\\r\\n                CTHelpers.getCollectionId(\\r\\n                    parentCollectionId,\\r\\n                    conditionId,\\r\\n                    indexSet\\r\\n                )\\r\\n            );\\r\\n            amounts[i] = amount;\\r\\n        }\\r\\n        _burnBatch(msg.sender, positionIds, amounts);\\r\\n\\r\\n        if (freeIndexSet == 0) {\\r\\n            if (parentCollectionId == bytes32(0)) {\\r\\n                require(\\r\\n                    collateralToken.transfer(msg.sender, amount),\\r\\n                    \\\"could not send collateral tokens\\\"\\r\\n                );\\r\\n            } else {\\r\\n                _mint(\\r\\n                    msg.sender,\\r\\n                    CTHelpers.getPositionId(\\r\\n                        collateralToken,\\r\\n                        parentCollectionId\\r\\n                    ),\\r\\n                    amount,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n            }\\r\\n        } else {\\r\\n            _mint(\\r\\n                msg.sender,\\r\\n                CTHelpers.getPositionId(\\r\\n                    collateralToken,\\r\\n                    CTHelpers.getCollectionId(\\r\\n                        parentCollectionId,\\r\\n                        conditionId,\\r\\n                        fullIndexSet ^ freeIndexSet\\r\\n                    )\\r\\n                ),\\r\\n                amount,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit PositionsMerge(\\r\\n            msg.sender,\\r\\n            collateralToken,\\r\\n            parentCollectionId,\\r\\n            conditionId,\\r\\n            partition,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function redeemPositions(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata indexSets\\r\\n    ) external {\\r\\n        uint256 den = payoutDenominator[conditionId];\\r\\n        require(den > 0, \\\"result for condition not received yet\\\");\\r\\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\\r\\n        require(outcomeSlotCount > 0, \\\"condition not prepared yet\\\");\\r\\n\\r\\n        uint256 totalPayout = 0;\\r\\n\\r\\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\\r\\n        for (uint256 i = 0; i < indexSets.length; i++) {\\r\\n            uint256 indexSet = indexSets[i];\\r\\n            require(\\r\\n                indexSet > 0 && indexSet < fullIndexSet,\\r\\n                \\\"got invalid index set\\\"\\r\\n            );\\r\\n            uint256 positionId = CTHelpers.getPositionId(\\r\\n                collateralToken,\\r\\n                CTHelpers.getCollectionId(\\r\\n                    parentCollectionId,\\r\\n                    conditionId,\\r\\n                    indexSet\\r\\n                )\\r\\n            );\\r\\n\\r\\n            uint256 payoutNumerator = 0;\\r\\n            for (uint256 j = 0; j < outcomeSlotCount; j++) {\\r\\n                if (indexSet & (1 << j) != 0) {\\r\\n                    payoutNumerator =\\r\\n                        payoutNumerator +\\r\\n                        payoutNumerators[conditionId][j];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            uint256 payoutStake = balanceOf(msg.sender, positionId);\\r\\n            // console.log(\\\"redeeming msg.sender: \\\", msg.sender);\\r\\n            // console.log(\\\"positionId: \\\", positionId);\\r\\n            // console.log(\\\"payoutStake: \\\", payoutStake);\\r\\n\\r\\n            if (payoutStake > 0) {\\r\\n                totalPayout =\\r\\n                    totalPayout +\\r\\n                    ((payoutStake * payoutNumerator) / den);\\r\\n                _burn(msg.sender, positionId, payoutStake);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (totalPayout > 0) {\\r\\n            if (parentCollectionId == bytes32(0)) {\\r\\n                require(\\r\\n                    collateralToken.transfer(msg.sender, totalPayout),\\r\\n                    \\\"could not transfer payout to message sender\\\"\\r\\n                );\\r\\n            } else {\\r\\n                _mint(\\r\\n                    msg.sender,\\r\\n                    CTHelpers.getPositionId(\\r\\n                        collateralToken,\\r\\n                        parentCollectionId\\r\\n                    ),\\r\\n                    totalPayout,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        emit PayoutRedemption(\\r\\n            msg.sender,\\r\\n            collateralToken,\\r\\n            parentCollectionId,\\r\\n            conditionId,\\r\\n            indexSets,\\r\\n            totalPayout\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Gets the outcome slot count of a condition.\\r\\n    /// @param conditionId ID of the condition.\\r\\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not been prepared yet.\\r\\n    function getOutcomeSlotCount(bytes32 conditionId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return payoutNumerators[conditionId].length;\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function getConditionId(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) external pure returns (bytes32) {\\r\\n        return CTHelpers.getConditionId(oracle, questionId, outcomeSlotCount);\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\\r\\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\\r\\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\\r\\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\\r\\n    function getCollectionId(\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256 indexSet\\r\\n    ) external view returns (bytes32) {\\r\\n        return\\r\\n            CTHelpers.getCollectionId(\\r\\n                parentCollectionId,\\r\\n                conditionId,\\r\\n                indexSet\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\\r\\n    /// @param collateralToken Collateral token which backs the position.\\r\\n    /// @param collectionId ID of the outcome collection associated with this position.\\r\\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\\r\\n        external\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return CTHelpers.getPositionId(collateralToken, collectionId);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x08e10869c064e2e794c06ebb1c34deb6abe9adfbf85ed39cf3e0bbcadf6f3901\",\"license\":\"LGPL-3.0\"},\"contracts/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/// @title Contains 512-bit math functions\\r\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\r\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\r\\nlibrary FullMath {\\r\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n    function mulDiv(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        // 512-bit multiply [prod1 prod0] = a * b\\r\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n        // then use the Chinese Remainder Theorem to reconstruct\\r\\n        // the 512 bit result. The result is stored in two 256\\r\\n        // variables such that product = prod1 * 2**256 + prod0\\r\\n        uint256 prod0; // Least significant 256 bits of the product\\r\\n        uint256 prod1; // Most significant 256 bits of the product\\r\\n        assembly {\\r\\n            let mm := mulmod(a, b, not(0))\\r\\n            prod0 := mul(a, b)\\r\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n        }\\r\\n\\r\\n        // Handle non-overflow cases, 256 by 256 division\\r\\n        if (prod1 == 0) {\\r\\n            require(denominator > 0);\\r\\n            assembly {\\r\\n                result := div(prod0, denominator)\\r\\n            }\\r\\n            return result;\\r\\n        }\\r\\n\\r\\n        // Make sure the result is less than 2**256.\\r\\n        // Also prevents denominator == 0\\r\\n        require(denominator > prod1);\\r\\n\\r\\n        ///////////////////////////////////////////////\\r\\n        // 512 by 256 division.\\r\\n        ///////////////////////////////////////////////\\r\\n\\r\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n        // Compute remainder using mulmod\\r\\n        uint256 remainder;\\r\\n        assembly {\\r\\n            remainder := mulmod(a, b, denominator)\\r\\n        }\\r\\n        // Subtract 256 bit number from 512 bit number\\r\\n        assembly {\\r\\n            prod1 := sub(prod1, gt(remainder, prod0))\\r\\n            prod0 := sub(prod0, remainder)\\r\\n        }\\r\\n\\r\\n        // Factor powers of two out of denominator\\r\\n        // Compute largest power of two divisor of denominator.\\r\\n        // Always >= 1.\\r\\n        uint256 twos = denominator & (~denominator + 1);\\r\\n        // Divide denominator by power of two\\r\\n        assembly {\\r\\n            denominator := div(denominator, twos)\\r\\n        }\\r\\n\\r\\n        // Divide [prod1 prod0] by the factors of two\\r\\n        assembly {\\r\\n            prod0 := div(prod0, twos)\\r\\n        }\\r\\n        // Shift in bits from prod1 into prod0. For this we need\\r\\n        // to flip `twos` such that it is 2**256 / twos.\\r\\n        // If twos is zero, then it becomes one\\r\\n        assembly {\\r\\n            twos := add(div(sub(0, twos), twos), 1)\\r\\n        }\\r\\n        prod0 |= prod1 * twos;\\r\\n\\r\\n        // Invert denominator mod 2**256\\r\\n        // Now that denominator is an odd number, it has an inverse\\r\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n        // Compute the inverse by starting with a seed that is correct\\r\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n        uint256 inv = (3 * denominator) ^ 2;\\r\\n        // Now use Newton-Raphson iteration to improve the precision.\\r\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\r\\n        // arithmetic, doubling the correct bits in each step.\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\r\\n\\r\\n        // Because the division is now exact we can divide by multiplying\\r\\n        // with the modular inverse of denominator. This will give us the\\r\\n        // correct result modulo 2**256. Since the precoditions guarantee\\r\\n        // that the outcome is less than 2**256, this is the final result.\\r\\n        // We don't need to compute the high bits of the result and prod1\\r\\n        // is no longer required.\\r\\n        result = prod0 * inv;\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    function mulDivRoundingUp(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        result = mulDiv(a, b, denominator);\\r\\n        if (mulmod(a, b, denominator) > 0) {\\r\\n            require(result < type(uint256).max);\\r\\n            result++;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xb5fba761aa46ae47434135e71bfc29ad52a1d332d1325abbd6d527f97b863282\",\"license\":\"MIT\"},\"contracts/IPFSSolutionsHub.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./interfaces/ISolverFactory.sol\\\";\\r\\nimport \\\"./Solver.sol\\\";\\r\\nimport \\\"./SolverLib.sol\\\";\\r\\nimport \\\"./interfaces/IProposalsHub.sol\\\";\\r\\n\\r\\ncontract IPFSSolutionsHub {\\r\\n    ISolverFactory immutable solverFactory;\\r\\n    IProposalsHub immutable proposalsHub;\\r\\n\\r\\n    struct Base {\\r\\n        IERC20 collateralToken;\\r\\n        bytes32 id;\\r\\n        bytes32 solverConfigsHash;\\r\\n        SolverLib.Multihash solverConfigsCID;\\r\\n    }\\r\\n\\r\\n    struct Instance {\\r\\n        bool executed;\\r\\n        bytes32 id;\\r\\n        bytes32 baseId;\\r\\n        address[] solverAddresses;\\r\\n    }\\r\\n\\r\\n    struct Solution {\\r\\n        bool executed;\\r\\n        IERC20 collateralToken;\\r\\n        address proposalsHub;\\r\\n        bytes32 proposalId;\\r\\n        bytes32 id;\\r\\n        bytes32 solverConfigsHash;\\r\\n        SolverLib.Multihash solverConfigsCID;\\r\\n        address[] solverAddresses;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32 => Base) public bases;\\r\\n    mapping(bytes32 => Instance) public instances;\\r\\n\\r\\n    mapping(bytes32 => bytes32) instanceId_to_ProposalId;\\r\\n\\r\\n    event CreateBase(bytes32 id);\\r\\n    event CreateSolution(bytes32 id);\\r\\n    event ExecuteSolution(bytes32 id);\\r\\n\\r\\n    constructor(\\r\\n        ISolverFactory factoryAddress,\\r\\n        IProposalsHub proposalsHubAddress\\r\\n    ) {\\r\\n        solverFactory = factoryAddress;\\r\\n        proposalsHub = proposalsHubAddress;\\r\\n    }\\r\\n\\r\\n    function linkToProposal(\\r\\n        bytes32 proposalId,\\r\\n        bytes32 solutionId,\\r\\n        IERC20 collateralToken\\r\\n    ) external {\\r\\n        require(\\r\\n            proposalsHub.isProposal(proposalId),\\r\\n            \\\"Proposal is not valid at proposalsHub\\\"\\r\\n        );\\r\\n        require(\\r\\n            bases[instances[solutionId].baseId].collateralToken ==\\r\\n                collateralToken,\\r\\n            \\\"Wrong collateral token\\\"\\r\\n        );\\r\\n\\r\\n        instanceId_to_ProposalId[solutionId] = proposalId;\\r\\n    }\\r\\n\\r\\n    function deploySolverChain(\\r\\n        bytes32 _solutionId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) private {\\r\\n        address _solverAddress;\\r\\n\\r\\n        for (uint256 i; i < solverConfigs.length; i++) {\\r\\n            if (i == 0) {\\r\\n                _solverAddress = solverFactory.createSolver(\\r\\n                    address(0),\\r\\n                    i,\\r\\n                    solverConfigs[i]\\r\\n                );\\r\\n\\r\\n                require(\\r\\n                    _solverAddress != address(0),\\r\\n                    \\\"Invalid address for Solver\\\"\\r\\n                );\\r\\n            } else {\\r\\n                _solverAddress = Solver(_solverAddress).deployChild(\\r\\n                    solverConfigs[i]\\r\\n                );\\r\\n            }\\r\\n            instances[_solutionId].solverAddresses.push(_solverAddress);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function createBase(\\r\\n        bytes32 baseId,\\r\\n        IERC20 collateralToken,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        SolverLib.Multihash calldata solverConfigsCID\\r\\n    ) public {\\r\\n        require(bases[baseId].id != baseId, \\\"Base ID already exists\\\");\\r\\n        Base storage base = bases[baseId];\\r\\n        base.id = baseId;\\r\\n        base.collateralToken = collateralToken;\\r\\n        base.solverConfigsHash = keccak256(abi.encode(solverConfigs));\\r\\n        base.solverConfigsCID = solverConfigsCID;\\r\\n        emit CreateBase(baseId);\\r\\n    }\\r\\n\\r\\n    function createInstance(bytes32 baseId, bytes32 instanceId)\\r\\n        public\\r\\n        returns (bytes32 solutionId)\\r\\n    {\\r\\n        require(\\r\\n            instances[instanceId].id != instanceId,\\r\\n            \\\"Instance ID already exists\\\"\\r\\n        );\\r\\n        require(bases[baseId].id != bytes32(\\\"\\\"), \\\"Base not found\\\");\\r\\n\\r\\n        Instance storage instance = instances[instanceId];\\r\\n        instance.id = instanceId;\\r\\n        instance.baseId = baseId;\\r\\n\\r\\n        emit CreateSolution(instanceId);\\r\\n        return instanceId;\\r\\n    }\\r\\n\\r\\n    function createSolution(\\r\\n        bytes32 instanceId,\\r\\n        IERC20 collateralToken,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        SolverLib.Multihash calldata solverConfigsCID\\r\\n    ) public returns (bytes32 baseId, bytes32 solutionId) {\\r\\n        require(\\r\\n            instances[instanceId].id != instanceId,\\r\\n            \\\"SolutionsHub::Instance ID already exists\\\"\\r\\n        );\\r\\n        baseId = keccak256(abi.encodePacked(instanceId, instanceId));\\r\\n        createBase(baseId, collateralToken, solverConfigs, solverConfigsCID);\\r\\n        createInstance(baseId, instanceId);\\r\\n\\r\\n        emit CreateSolution(instanceId);\\r\\n        return (baseId, instanceId);\\r\\n    }\\r\\n\\r\\n    function executeSolution(\\r\\n        bytes32 proposalId,\\r\\n        bytes32 solutionId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) external {\\r\\n        require(\\r\\n            verifyHash(solutionId, solverConfigs),\\r\\n            \\\"Incorrect SolverConfig content\\\"\\r\\n        );\\r\\n        require(\\r\\n            msg.sender == address(proposalsHub),\\r\\n            \\\"Not correct proposalsHub\\\"\\r\\n        );\\r\\n        require(\\r\\n            instanceId_to_ProposalId[solutionId] == proposalId,\\r\\n            \\\"Wrong proposalId\\\"\\r\\n        );\\r\\n        require(\\r\\n            instances[solutionId].executed == false,\\r\\n            \\\"Solution already executed\\\"\\r\\n        );\\r\\n\\r\\n        instances[solutionId].executed = true;\\r\\n\\r\\n        deploySolverChain(solutionId, solverConfigs);\\r\\n\\r\\n        IProposalsHub(msg.sender).transferERC20(\\r\\n            proposalId,\\r\\n            instances[solutionId].solverAddresses[0]\\r\\n        );\\r\\n\\r\\n        for (uint256 i; i < instances[solutionId].solverAddresses.length; i++) {\\r\\n            ISolver _solver = ISolver(instances[solutionId].solverAddresses[i]);\\r\\n            _solver.setTrackingId(instanceId_to_ProposalId[solutionId]);\\r\\n        }\\r\\n        // Prepare first Solver\\r\\n        ISolver(instances[solutionId].solverAddresses[0]).prepareSolve(0);\\r\\n\\r\\n        emit ExecuteSolution(solutionId);\\r\\n    }\\r\\n\\r\\n    function verifyHash(\\r\\n        bytes32 solutionId,\\r\\n        SolverLib.Config[] memory solverConfigs\\r\\n    ) public view returns (bool) {\\r\\n        return\\r\\n            bases[instances[solutionId].baseId].solverConfigsHash ==\\r\\n            keccak256(abi.encode(solverConfigs));\\r\\n    }\\r\\n\\r\\n    function solverFromIndex(bytes32 solutionId, uint256 index)\\r\\n        public\\r\\n        view\\r\\n        returns (address solverAddress)\\r\\n    {\\r\\n        if (instances[solutionId].solverAddresses.length > 0) {\\r\\n            return instances[solutionId].solverAddresses[index];\\r\\n        } else {\\r\\n            return address(0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getSolvers(bytes32 solutionId)\\r\\n        public\\r\\n        view\\r\\n        returns (address[] memory solvers)\\r\\n    {\\r\\n        solvers = instances[solutionId].solverAddresses;\\r\\n    }\\r\\n\\r\\n    function getSolution(bytes32 instanceId)\\r\\n        public\\r\\n        view\\r\\n        returns (Solution memory solution)\\r\\n    {\\r\\n        Instance memory instance = instances[instanceId];\\r\\n        Base memory base = bases[instance.baseId];\\r\\n\\r\\n        solution.id = instance.id;\\r\\n        solution.executed = instance.executed;\\r\\n        solution.collateralToken = base.collateralToken;\\r\\n        solution.proposalId = instanceId_to_ProposalId[instanceId];\\r\\n        solution.solverConfigsHash = base.solverConfigsHash;\\r\\n        solution.solverConfigsCID = base.solverConfigsCID;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xcd988e54548d29d4dc20d339acad50024271ccfa1b87cd8a60454d99f58c5197\",\"license\":\"GPL-3.0\"},\"contracts/ProposalsHub.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IIPFSSolutionsHub.sol\\\";\\r\\nimport \\\"./interfaces/IConditionalTokens.sol\\\";\\r\\n\\r\\nimport \\\"./SolverLib.sol\\\";\\r\\n\\r\\n// 0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9 DEV_ADDRESS\\r\\ncontract ProposalsHub is ERC1155Receiver {\\r\\n    // Used to allow funders to reclaim conditional tokens sent to this address\\r\\n    IConditionalTokens public immutable conditionalTokens;\\r\\n\\r\\n    // Increment for unique proposal IDs\\r\\n    uint256 nonce;\\r\\n\\r\\n    struct Proposal {\\r\\n        bool isExecuted;\\r\\n        IERC20 collateralToken;\\r\\n        address proposer;\\r\\n        address solutionsHub;\\r\\n        bytes32 id;\\r\\n        bytes32 solutionId;\\r\\n        uint256 funding;\\r\\n        uint256 fundingGoal;\\r\\n        SolverLib.Multihash metadataCID;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32 => Proposal) public proposals;\\r\\n    mapping(bytes32 => mapping(address => uint256)) public funderAmountMap;\\r\\n\\r\\n    // Used to allow funders to reclaim conditional tokens sent to this address\\r\\n    mapping(bytes32 => mapping(uint256 => uint256)) public reclaimableTokens;\\r\\n    mapping(uint256 => mapping(address => uint256)) public reclaimedTokens;\\r\\n\\r\\n    event CreateProposal(bytes32 indexed id);\\r\\n    event ExecuteProposal(bytes32 indexed id);\\r\\n    event FundProposal(bytes32 indexed id, uint256 amount, address from);\\r\\n    event DefundProposal(bytes32 indexed id, uint256 amount, address to);\\r\\n\\r\\n    constructor(address _ctfAddress) {\\r\\n        conditionalTokens = IConditionalTokens(_ctfAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Executes a proposal for Solutions where on the *hash* of solver configs is stored on-chain\\r\\n        @param proposalId ID of proposal\\r\\n        @param solverConfigs Configurations of Solvers to be run for the proposed solution\\r\\n     */\\r\\n    function executeIPFSProposal(\\r\\n        bytes32 proposalId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) external {\\r\\n        require(\\r\\n            proposals[proposalId].funding >= proposals[proposalId].fundingGoal,\\r\\n            \\\"Proposal not fully funded\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[proposalId].isExecuted == false,\\r\\n            \\\"ProposalsHub::Proposal already executed\\\"\\r\\n        );\\r\\n\\r\\n        IIPFSSolutionsHub(proposals[proposalId].solutionsHub).executeSolution(\\r\\n            proposalId,\\r\\n            proposals[proposalId].solutionId,\\r\\n            solverConfigs\\r\\n        );\\r\\n\\r\\n        proposals[proposalId].isExecuted = true;\\r\\n\\r\\n        emit ExecuteProposal(proposalId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called by SolutionsHub after deploying Solvers\\r\\n        @param proposalId Proposal that collateral is being transferred from\\r\\n        @param solver Solver receiving collateral\\r\\n     */\\r\\n    function transferERC20(bytes32 proposalId, address solver) external {\\r\\n        require(\\r\\n            msg.sender == proposals[proposalId].solutionsHub,\\r\\n            \\\"msg.sender not solutionsHub\\\"\\r\\n        );\\r\\n        require(solver != address(0), \\\"Invalid address\\\");\\r\\n        require(\\r\\n            IIPFSSolutionsHub(proposals[proposalId].solutionsHub)\\r\\n                .solverFromIndex(proposals[proposalId].solutionId, 0) == solver,\\r\\n            \\\"Incorrect solver address\\\"\\r\\n        );\\r\\n\\r\\n        IERC20 _token = IERC20(proposals[proposalId].collateralToken);\\r\\n        uint256 beforeBalance = _token.balanceOf(address(this));\\r\\n        require(\\r\\n            _token.transfer(solver, proposals[proposalId].funding),\\r\\n            \\\"Transfer failed\\\"\\r\\n        );\\r\\n        require(\\r\\n            beforeBalance - _token.balanceOf(address(this)) ==\\r\\n                proposals[proposalId].fundingGoal,\\r\\n            \\\"Incorrect balance after transfer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Creates a Proposal from an existing Solution.Base\\r\\n        @param collateralToken ERC20 token being used as collateral for conditional tokens\\r\\n        @param solutionsHub Address of the SolutionsHub contract managing the Solution\\r\\n        @param fundingGoal Amount of ERC20 collateral requested for the Proposal\\r\\n        @param baseId ID of the Solution.Base for which a new instance and proposal is created\\r\\n    */\\r\\n    function createProposal(\\r\\n        IERC20 collateralToken,\\r\\n        address solutionsHub,\\r\\n        uint256 fundingGoal,\\r\\n        bytes32 baseId,\\r\\n        SolverLib.Multihash calldata metadataCID\\r\\n    ) public returns (bytes32 solutionId, bytes32 proposalId) {\\r\\n        nonce++;\\r\\n\\r\\n        solutionId = IIPFSSolutionsHub(solutionsHub).createInstance(\\r\\n            baseId,\\r\\n            keccak256(\\r\\n                abi.encodePacked(baseId, blockhash(block.number - 1), nonce)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        proposalId = keccak256(abi.encodePacked(solutionId, nonce));\\r\\n\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        proposal.id = proposalId;\\r\\n\\r\\n        IIPFSSolutionsHub(solutionsHub).linkToProposal(\\r\\n            proposalId,\\r\\n            solutionId,\\r\\n            collateralToken\\r\\n        );\\r\\n\\r\\n        proposal.collateralToken = collateralToken;\\r\\n        proposal.proposer = msg.sender;\\r\\n        proposal.solutionsHub = solutionsHub;\\r\\n        proposal.solutionId = solutionId;\\r\\n        proposal.fundingGoal = fundingGoal;\\r\\n        proposal.metadataCID = metadataCID;\\r\\n\\r\\n        emit CreateProposal(proposalId);\\r\\n\\r\\n        return (solutionId, proposalId);\\r\\n    }\\r\\n\\r\\n    function createIPFSSolutionAndProposal(\\r\\n        bytes32 baseId,\\r\\n        IERC20 collateralToken,\\r\\n        IIPFSSolutionsHub ipfsSolutionsHub,\\r\\n        uint256 fundingGoal,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        SolverLib.Multihash calldata solverConfigsCID,\\r\\n        SolverLib.Multihash calldata metadataCID\\r\\n    ) external returns (bytes32 solutionId, bytes32 proposalId) {\\r\\n        ipfsSolutionsHub.createBase(\\r\\n            baseId,\\r\\n            collateralToken,\\r\\n            solverConfigs,\\r\\n            solverConfigsCID\\r\\n        );\\r\\n\\r\\n        (solutionId, proposalId) = createProposal(\\r\\n            collateralToken,\\r\\n            address(ipfsSolutionsHub),\\r\\n            fundingGoal,\\r\\n            baseId,\\r\\n            metadataCID\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called by user to add funding to a Proposal\\r\\n        @param proposalId ID of Proposal being funded\\r\\n        @param token ERC20 token to be funded with\\r\\n        @param amount Amount to be funded\\r\\n    */\\r\\n    function fundProposal(\\r\\n        bytes32 proposalId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(proposals[proposalId].id != 0, \\\"Proposal does not exist\\\");\\r\\n        require(\\r\\n            proposals[proposalId].isExecuted == false,\\r\\n            \\\"ProposalsHub::Proposal already executed\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[proposalId].collateralToken == token,\\r\\n            \\\"Proposal does not include this token to be funded\\\"\\r\\n        );\\r\\n        require(amount > 0, \\\"Amount cannot be zero\\\");\\r\\n        require(\\r\\n            amount + proposals[proposalId].funding <=\\r\\n                proposals[proposalId].fundingGoal,\\r\\n            \\\"Can't fund more than goal\\\"\\r\\n        );\\r\\n\\r\\n        uint256 beforeBalance = token.balanceOf(address(this));\\r\\n        require(\\r\\n            token.transferFrom(msg.sender, address(this), amount),\\r\\n            \\\"Could not transfer from msg.sender\\\"\\r\\n        );\\r\\n        require(\\r\\n            token.balanceOf(address(this)) - beforeBalance == amount,\\r\\n            \\\"Incorrect balance after transfer\\\"\\r\\n        );\\r\\n\\r\\n        proposals[proposalId].funding += amount;\\r\\n        funderAmountMap[proposalId][msg.sender] += amount;\\r\\n\\r\\n        emit FundProposal(proposalId, amount, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called by user to remove their funding from a Proposal\\r\\n        @param proposalId ID of Proposal being defunded\\r\\n        @param token ERC20 token to be defunded\\r\\n        @param amount Amount to be defunded\\r\\n    */\\r\\n    function defundProposal(\\r\\n        bytes32 proposalId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(proposals[proposalId].id != 0, \\\"Proposal does not exist\\\");\\r\\n        require(\\r\\n            proposals[proposalId].isExecuted == false,\\r\\n            \\\"ProposalsHub::Proposal already executed\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[proposalId].collateralToken == token,\\r\\n            \\\"Proposal does not include this token to be funded\\\"\\r\\n        );\\r\\n        require(amount > 0, \\\"Amount cannot be zero\\\");\\r\\n        require(\\r\\n            amount <= funderAmountMap[proposalId][msg.sender],\\r\\n            \\\"Committed funds is lower than amount.\\\"\\r\\n        );\\r\\n        uint256 beforeBalance = token.balanceOf(address(this));\\r\\n\\r\\n        proposals[proposalId].funding -= amount;\\r\\n        funderAmountMap[proposalId][msg.sender] -= amount;\\r\\n\\r\\n        require(token.transfer(msg.sender, amount), \\\"Transfer failed\\\");\\r\\n\\r\\n        require(\\r\\n            beforeBalance - token.balanceOf(address(this)) == amount,\\r\\n            \\\"Before and after balance wrong\\\"\\r\\n        );\\r\\n\\r\\n        emit DefundProposal(proposalId, amount, msg.sender);\\r\\n    }\\r\\n\\r\\n    function getProposal(bytes32 id)\\r\\n        external\\r\\n        view\\r\\n        returns (Proposal memory proposal)\\r\\n    {\\r\\n        return proposals[id];\\r\\n    }\\r\\n\\r\\n    function getMetadataCID(bytes32 id)\\r\\n        external\\r\\n        view\\r\\n        returns (SolverLib.Multihash memory)\\r\\n    {\\r\\n        return proposals[id].metadataCID;\\r\\n    }\\r\\n\\r\\n    function isProposal(bytes32 id) external view returns (bool) {\\r\\n        return proposals[id].id != bytes32(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called when contract receives ERC1155 with data referring to a proposalId\\r\\n        @param proposalId ID of proposal being referred to by tx\\r\\n        @param tokenId ID of ERC1155 token that was received\\r\\n        @param amount Amount of token received\\r\\n     */\\r\\n    function postReclaimableTokens(\\r\\n        bytes32 proposalId,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        reclaimableTokens[proposalId][tokenId] += amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Transfers reclaimable CTs to a claimer and lowers their reclaimable balance for that token\\r\\n        @param proposalId ID of proposal being reclaimed from\\r\\n        @param tokenId ERC1155 token being reclaimed\\r\\n     */\\r\\n    function reclaimTokens(bytes32 proposalId, uint256 tokenId) external {\\r\\n        require(\\r\\n            funderAmountMap[proposalId][msg.sender] > 0,\\r\\n            \\\"ProposalsHub::msg.sender has no claim\\\"\\r\\n        );\\r\\n        uint256 _claimDenominator = proposals[proposalId].funding /\\r\\n            funderAmountMap[proposalId][msg.sender];\\r\\n\\r\\n        uint256 _claimAmount = (reclaimableTokens[proposalId][tokenId] /\\r\\n            _claimDenominator) - reclaimedTokens[tokenId][msg.sender];\\r\\n        require(_claimAmount > 0, \\\"ProposalsHub::Claim is 0\\\");\\r\\n        require(\\r\\n            _claimAmount <= reclaimableTokens[proposalId][tokenId],\\r\\n            \\\"ProposalsHub::Claim is too large\\\"\\r\\n        );\\r\\n        reclaimedTokens[tokenId][msg.sender] += _claimAmount;\\r\\n\\r\\n        conditionalTokens.safeTransferFrom(\\r\\n            address(this),\\r\\n            msg.sender,\\r\\n            tokenId,\\r\\n            _claimAmount,\\r\\n            abi.encode(proposalId)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        IMPORTANT!\\r\\n        Any CTs sent to this contract are reclaimable by the funders in proportion to their funding.\\r\\n        If a user reclaims CTs and sends them back again to this contract, they will only be able to \\r\\n        regain from them a fraction of their original funding.\\r\\n    */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external virtual override returns (bytes4) {\\r\\n        bytes32 _proposalId = abi.decode(data, (bytes32));\\r\\n        require(\\r\\n            proposals[_proposalId].id == _proposalId,\\r\\n            \\\"ProposalsHub::Data is not valid proposalId\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[_proposalId].isExecuted,\\r\\n            \\\"ProposalsHub::Proposal has not been executed\\\"\\r\\n        );\\r\\n        postReclaimableTokens(_proposalId, id, value);\\r\\n\\r\\n        return this.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external virtual override returns (bytes4) {\\r\\n        bytes32 _proposalId = abi.decode(data, (bytes32));\\r\\n        require(\\r\\n            proposals[_proposalId].id == _proposalId,\\r\\n            \\\"ProposalsHub::Data is not valid proposalId\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[_proposalId].isExecuted,\\r\\n            \\\"ProposalsHub::Proposal has not been executed\\\"\\r\\n        );\\r\\n        for (uint256 i; i < ids.length; i++) {\\r\\n            postReclaimableTokens(_proposalId, ids[i], values[i]);\\r\\n        }\\r\\n        return this.onERC1155BatchReceived.selector;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xb9517a98bd1a582e4aeb576b77d1847b7b6a56701a096f2c6659d4bacf7c3826\",\"license\":\"GPL-3.0\"},\"contracts/Solver.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IConditionalTokens.sol\\\";\\r\\nimport \\\"./interfaces/ISolver.sol\\\";\\r\\n\\r\\nimport \\\"./Solver.sol\\\";\\r\\nimport \\\"./SolverLib.sol\\\";\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\n\\r\\nabstract contract Solver is Initializable, ERC1155Receiver {\\r\\n    address factoryAddress; // Factory which creates Solver proxies\\r\\n    address ctfAddress; // Conditional token framework\\r\\n    address deployerAddress; // Address which called SolverFactory to deploy this Solver\\r\\n\\r\\n    SolverLib.Config public config; // Primary config of the Solver\\r\\n    SolverLib.Condition[] public conditions; // Array of conditions\\r\\n\\r\\n    address public chainParent; // Parent solver\\r\\n    address public chainChild; // Child solver\\r\\n    uint256 public chainIndex; // This Solver's index in chain\\r\\n\\r\\n    uint256[] public timelocks; // Current timelock, indexed by condition\\r\\n    bytes32 public trackingId; // Settable for adding some higher-level trackingId (eg. id of a proposal this solver belongs to)\\r\\n\\r\\n    SolverLib.Callbacks callbacks;\\r\\n    SolverLib.Datas datas;\\r\\n\\r\\n    event ChangedStatus(bytes32 conditionId);\\r\\n\\r\\n    event DeployedChild(address child);\\r\\n\\r\\n    event DeliveredNullArbitration(bytes32 conditionId);\\r\\n\\r\\n    event IngestedData(); // Emited on executeIngests(), handleCallback(), addData()\\r\\n\\r\\n    event PreparedSolve(address solver, uint256 solveIndex);\\r\\n\\r\\n    // Recommended disabling of initializer for the implementation. Not called by clones\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called by SolverFactory when contract is created. Nothing else should ever need to call this\\r\\n        @param _chainParent The address of the Solver above this one in the chain. address(0) if this Solver is first.\\r\\n        @param _chainIndex The index of this Solver in the chain\\r\\n        @param _solverConfig The configuration of this Solver\\r\\n    */\\r\\n    function init(\\r\\n        address _deployer,\\r\\n        address _ctfAddress,\\r\\n        address _chainParent,\\r\\n        uint256 _chainIndex,\\r\\n        SolverLib.Config calldata _solverConfig\\r\\n    ) external initializer {\\r\\n        require(_solverConfig.keeper != address(0), \\\"Keeper invalid\\\");\\r\\n        deployerAddress = _deployer;\\r\\n        factoryAddress = msg.sender;\\r\\n        ctfAddress = _ctfAddress;\\r\\n        chainParent = _chainParent;\\r\\n        chainIndex = _chainIndex;\\r\\n        config = _solverConfig;\\r\\n\\r\\n        for (uint256 i = 0; i < _solverConfig.ingests.length; i++) {\\r\\n            datas.slotIngestIdx[_solverConfig.ingests[i].slot] = i;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ********************************** SETUP ***************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Creates a new condition, associated timelock, and executes ingests for this Solver and any child Solvers\\r\\n        @param _index Index of the new condition to be created.\\r\\n    */\\r\\n    function prepareSolve(uint256 _index) external {\\r\\n        if (conditions.length > 0) {\\r\\n            require(\\r\\n                msg.sender == config.keeper || msg.sender == chainParent,\\r\\n                \\\"Only keeper/parent\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        require(_index == conditions.length, \\\"Invalid index to prepare\\\");\\r\\n        require(callbacks.numOutgoing == 0, \\\"Fulfill outgoing callbacks first\\\");\\r\\n        require(callbacks.numIncoming == 0, \\\"Fulfill incoming callbacks first\\\");\\r\\n\\r\\n        conditions.push(\\r\\n            SolverLib.createCondition(\\r\\n                ctfAddress,\\r\\n                config.conditionBase,\\r\\n                chainParent,\\r\\n                conditions.length\\r\\n            )\\r\\n        );\\r\\n        timelocks.push(0);\\r\\n\\r\\n        executeIngests();\\r\\n\\r\\n        emit PreparedSolve(address(this), _index);\\r\\n\\r\\n        if (chainChild != address(0)) {\\r\\n            ISolver(chainChild).prepareSolve(_index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Deploys a new Solver as a child\\r\\n        @param _config Configuration of the child Solver\\r\\n    */\\r\\n    function deployChild(SolverLib.Config calldata _config)\\r\\n        public\\r\\n        returns (address)\\r\\n    {\\r\\n        require(msg.sender == config.keeper, \\\"Only keeper\\\");\\r\\n        require(chainChild == address(0), \\\"Solver has child\\\");\\r\\n\\r\\n        chainChild = SolverLib.deployChild(\\r\\n            factoryAddress,\\r\\n            _config,\\r\\n            chainIndex,\\r\\n            trackingId\\r\\n        );\\r\\n\\r\\n        return chainChild;\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ****************************** EXECUTION ***************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Mints conditional tokens, allocates them to recipients specified by ingested data, runs arbitrary `postroll()` function and tries to do the same for child Solver\\r\\n        @param _index Index of condition to execute on\\r\\n     */\\r\\n    function executeSolve(uint256 _index) public {\\r\\n        require(ingestsValid() == true, \\\"ingests invalid\\\");\\r\\n\\r\\n        SolverLib.executeSolve(\\r\\n            _index,\\r\\n            ctfAddress,\\r\\n            conditions[_index],\\r\\n            config.conditionBase,\\r\\n            datas,\\r\\n            trackingId,\\r\\n            chainParent,\\r\\n            abi.decode(\\r\\n                datas.slots[config.conditionBase.amountSlot][_index],\\r\\n                (uint256)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        postroll(_index);\\r\\n        cascade(_index);\\r\\n    }\\r\\n\\r\\n    function postroll(uint256 _index) internal virtual;\\r\\n\\r\\n    function cascade(uint256 _index) internal {\\r\\n        if (\\r\\n            chainChild != address(0) &&\\r\\n            ISolver(chainChild).ingestsValid() &&\\r\\n            ISolver(chainChild).allocationsValid(_index)\\r\\n        ) {\\r\\n            ISolver(chainChild).executeSolve(_index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ********************************** DATA ****************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Adds data to slot (if valid ver.) and executes any callbacks for this slot\\r\\n        @param _slot Destination slot\\r\\n        @param _data Data added to slot\\r\\n     */\\r\\n    function router(bytes32 _slot, bytes memory _data) private {\\r\\n        require(\\r\\n            datas.slots[_slot].length == (conditions.length - 1),\\r\\n            \\\"Slot version invalid\\\"\\r\\n        );\\r\\n        datas.slots[_slot].push(_data);\\r\\n\\r\\n        callback(_slot);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Executes ingests from config. Registers callbacks for ingests which wait for upstream solver data\\r\\n     */\\r\\n    function executeIngests() private {\\r\\n        for (uint256 i; i < config.ingests.length; i++) {\\r\\n            if (config.ingests[i].ingestType != SolverLib.IngestType.Callback) {\\r\\n                ingest(config.ingests[i]);\\r\\n            } else {\\r\\n                address _cbSolver = ISolver(address(this))\\r\\n                    .addressFromChainIndex(config.ingests[i].solverIndex);\\r\\n                registerIncomingCallback(_cbSolver, i);\\r\\n                ISolver(_cbSolver).registerOutgoingCallback(\\r\\n                    abi.decode(config.ingests[i].data, (bytes32)),\\r\\n                    chainIndex\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        emit IngestedData();\\r\\n    }\\r\\n\\r\\n    function ingest(SolverLib.Ingest storage _ingest) private {\\r\\n        require(uint256(_ingest.ingestType) <= 3, \\\"Invalid ingestType\\\");\\r\\n        _ingest.executions++;\\r\\n\\r\\n        if (_ingest.ingestType != SolverLib.IngestType.Manual) {\\r\\n            router(_ingest.slot, SolverLib.ingest(_ingest));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Verifies that all ingests have been performed for a condition\\r\\n     */\\r\\n    function ingestsValid() public view returns (bool) {\\r\\n        return SolverLib.ingestsValid(config.ingests, conditions.length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Verifies that all slots corresponding to recipients have been filled before CT allocation\\r\\n     */\\r\\n    function allocationsValid(uint256 _index) public view returns (bool) {\\r\\n        return SolverLib.allocationsValid(_index, datas, config.conditionBase);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Allows keeper to manually add data to IngestType.Manual slots after executeIngests\\r\\n        @param _slot Destination slot\\r\\n        @param _data Data to be added\\r\\n     */\\r\\n    function addData(bytes32 _slot, bytes memory _data) external {\\r\\n        require(msg.sender == config.keeper, \\\"OnlyKeeper\\\");\\r\\n        require(\\r\\n            config.ingests[datas.slotIngestIdx[_slot]].ingestType ==\\r\\n                SolverLib.IngestType.Manual,\\r\\n            \\\"only IngestType.Manual\\\"\\r\\n        );\\r\\n\\r\\n        router(_slot, _data);\\r\\n        emit IngestedData();\\r\\n    }\\r\\n\\r\\n    function getData(bytes32 _slot) public view returns (bytes memory data) {\\r\\n        data = datas.slots[_slot][datas.slots[_slot].length - 1];\\r\\n    }\\r\\n\\r\\n    function getAllData(bytes32 _slot)\\r\\n        public\\r\\n        view\\r\\n        returns (bytes[] memory data)\\r\\n    {\\r\\n        data = datas.slots[_slot];\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ****************************** CALLBACKS ***************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Register callback that an upstream Solver will call when some data is added\\r\\n        @param _cbSolver Address of the Solver making the callback\\r\\n        @param _ingestIndex Index of the ingest registering this callback\\r\\n     */\\r\\n    function registerIncomingCallback(address _cbSolver, uint256 _ingestIndex)\\r\\n        private\\r\\n    {\\r\\n        callbacks.incoming[\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    _cbSolver,\\r\\n                    abi.decode(config.ingests[_ingestIndex].data, (bytes32))\\r\\n                )\\r\\n            )\\r\\n        ] = _ingestIndex;\\r\\n        callbacks.numIncoming++;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Register callback expected by a downstream Solver for some data\\r\\n        @param _slot Slot being waited on by downstream Solver\\r\\n        @param _chainIndex Index of the Solver requesting this callback\\r\\n     */\\r\\n    function registerOutgoingCallback(bytes32 _slot, uint256 _chainIndex)\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            msg.sender == addressFromChainIndex(_chainIndex),\\r\\n            \\\"msg.sender not solver\\\"\\r\\n        );\\r\\n\\r\\n        if (\\r\\n            datas.slots[_slot].length > 0 &&\\r\\n            datas.slots[_slot].length == conditions.length\\r\\n        ) {\\r\\n            // Downchain Solver is preparing a new condition before us and is happy with the existing data\\r\\n            ISolver(msg.sender).handleCallback(_slot);\\r\\n        } else {\\r\\n            callbacks.outgoing[_slot].push(msg.sender);\\r\\n            callbacks.numOutgoing++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Handle upstream Solver making callback and ingest the data\\r\\n        @param _slot Destination slot for the data being sent\\r\\n     */\\r\\n    function handleCallback(bytes32 _slot) external {\\r\\n        bytes32 _cb = keccak256(abi.encodePacked(msg.sender, _slot));\\r\\n        require(\\r\\n            msg.sender ==\\r\\n                addressFromChainIndex(\\r\\n                    config.ingests[callbacks.incoming[_cb]].solverIndex\\r\\n                ),\\r\\n            \\\"msg.sender not solver\\\"\\r\\n        );\\r\\n        require(\\r\\n            config.ingests[callbacks.incoming[_cb]].ingestType ==\\r\\n                SolverLib.IngestType.Callback,\\r\\n            \\\"Ingest not Callback\\\"\\r\\n        );\\r\\n\\r\\n        config.ingests[callbacks.incoming[_cb]].executions++;\\r\\n\\r\\n        router(\\r\\n            config.ingests[callbacks.incoming[_cb]].slot,\\r\\n            ISolver(msg.sender).getCallbackOutput(\\r\\n                abi.decode(\\r\\n                    config.ingests[callbacks.incoming[_cb]].data,\\r\\n                    (bytes32)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        delete callbacks.incoming[_cb];\\r\\n        callbacks.numIncoming--;\\r\\n\\r\\n        emit IngestedData();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Make any callbacks that were waiting on _slot\\r\\n        @param _slot Slot being waited on by downstream Solvers\\r\\n     */\\r\\n    function callback(bytes32 _slot) private {\\r\\n        for (uint256 i; i < callbacks.outgoing[_slot].length; i++) {\\r\\n            if (address(callbacks.outgoing[_slot][i]) != address(0)) {\\r\\n                ISolver(address(callbacks.outgoing[_slot][i])).handleCallback(\\r\\n                    _slot\\r\\n                );\\r\\n                delete callbacks.outgoing[_slot][i];\\r\\n                callbacks.numOutgoing--;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev A simple getter that requires upstream slot ver. == our condition ver.\\r\\n        @param _slot Slot containing data\\r\\n     */\\r\\n    function getCallbackOutput(bytes32 _slot)\\r\\n        public\\r\\n        view\\r\\n        returns (bytes memory data)\\r\\n    {\\r\\n        require(\\r\\n            datas.slots[_slot].length == conditions.length,\\r\\n            \\\"Slot invalid ver.\\\"\\r\\n        );\\r\\n\\r\\n        data = datas.slots[_slot][datas.slots[_slot].length - 1];\\r\\n    }\\r\\n\\r\\n    function getOutgoingCallbacks(bytes32 slot)\\r\\n        public\\r\\n        view\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        return callbacks.outgoing[slot];\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ****************************** REPORTING ***************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Propose payouts (AKA outcomes) for a condition\\r\\n        @param _index Index of condition\\r\\n        @param _payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\\r\\n     */\\r\\n    function proposePayouts(uint256 _index, uint256[] calldata _payouts)\\r\\n        external\\r\\n    {\\r\\n        require(msg.sender == config.keeper, \\\"Only Keeper\\\");\\r\\n        require(\\r\\n            _payouts.length == config.conditionBase.outcomeSlots,\\r\\n            \\\"payouts.length must match outcomeSlots\\\"\\r\\n        );\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.Executed,\\r\\n            \\\"Condition not Executed\\\"\\r\\n        );\\r\\n\\r\\n        SolverLib.proposePayouts(conditions[_index], _payouts);\\r\\n        updateTimelock(_index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Confirm payouts for condition (reportPayouts to ConditionalTokens contract)\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function confirmPayouts(uint256 _index) external {\\r\\n        require(block.timestamp > timelocks[_index], \\\"Timelock still locked\\\");\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.OutcomeProposed,\\r\\n            \\\"Outcome not proposed\\\"\\r\\n        );\\r\\n        SolverLib.confirmPayouts(ctfAddress, conditions[_index]);\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ***************************** ARBITRATION **************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Sets condition.status to ArbitrationRequested.\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function arbitrationRequested(uint256 _index) external {\\r\\n        require(msg.sender == config.arbitrator, \\\"Only arbitrator\\\");\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.OutcomeProposed ||\\r\\n                conditions[_index].status ==\\r\\n                SolverLib.Status.ArbitrationRequested,\\r\\n            \\\"Cannot request\\\"\\r\\n        );\\r\\n\\r\\n        SolverLib.arbitrationRequested(conditions[_index]);\\r\\n        updateTimelock(_index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Allows arbitrator to unilaterally make a payout report.\\r\\n        @param _index Index of condition\\r\\n        @param payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\\r\\n     */\\r\\n    function arbitrate(uint256 _index, uint256[] memory payouts) external {\\r\\n        require(msg.sender == config.arbitrator, \\\"Only arbitrator\\\");\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.ArbitrationRequested,\\r\\n            \\\"Not ArbitrationRequested\\\"\\r\\n        );\\r\\n        require(block.timestamp > timelocks[_index], \\\"Timelock still locked\\\");\\r\\n        require(\\r\\n            payouts.length == config.conditionBase.outcomeSlots,\\r\\n            \\\"payouts.length must match outcomeSlots\\\"\\r\\n        );\\r\\n        SolverLib.arbitrate(ctfAddress, conditions[_index], payouts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Returns condition.status to OutcomeProposed without a ruling.\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function arbitrateNull(uint256 _index) external {\\r\\n        require(msg.sender == config.arbitrator, \\\"Only arbitrator\\\");\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.ArbitrationRequested,\\r\\n            \\\"Not ArbitrationRequested\\\"\\r\\n        );\\r\\n        SolverLib.arbitrateNull(conditions[_index]);\\r\\n        updateTimelock(_index);\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ******************************** UTILIY ****************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Get address for a Solver by its index in the chain\\r\\n        @param _index Index of Solver\\r\\n     */\\r\\n    function addressFromChainIndex(uint256 _index)\\r\\n        public\\r\\n        view\\r\\n        returns (address _address)\\r\\n    {\\r\\n        if (_index == chainIndex) {\\r\\n            _address = address(this);\\r\\n        } else if (_index < chainIndex) {\\r\\n            _address = ISolver(chainParent).addressFromChainIndex(_index);\\r\\n        } else if (_index > chainIndex) {\\r\\n            _address = ISolver(chainChild).addressFromChainIndex(_index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function condition(uint256 index)\\r\\n        public\\r\\n        view\\r\\n        returns (SolverLib.Condition memory)\\r\\n    {\\r\\n        return conditions[index];\\r\\n    }\\r\\n\\r\\n    function getConditions()\\r\\n        public\\r\\n        view\\r\\n        returns (SolverLib.Condition[] memory)\\r\\n    {\\r\\n        return conditions;\\r\\n    }\\r\\n\\r\\n    function getConfig() public view returns (SolverLib.Config memory) {\\r\\n        return config;\\r\\n    }\\r\\n\\r\\n    function keeper() public view returns (address) {\\r\\n        return config.keeper;\\r\\n    }\\r\\n\\r\\n    function arbitrator() public view returns (address) {\\r\\n        return config.arbitrator;\\r\\n    }\\r\\n\\r\\n    function setTrackingId(bytes32 _trackingId) public {\\r\\n        require(trackingId == bytes32(0), \\\"TrackingId set\\\");\\r\\n        require(msg.sender == deployerAddress);\\r\\n        trackingId = _trackingId;\\r\\n    }\\r\\n\\r\\n    function updateTimelock(uint256 _index) internal {\\r\\n        timelocks[_index] =\\r\\n            block.timestamp +\\r\\n            (config.timelockSeconds * 1 seconds);\\r\\n    }\\r\\n\\r\\n    function collateralBalance() public view returns (uint256 balance) {\\r\\n        balance = IERC20(config.conditionBase.collateralToken).balanceOf(\\r\\n            address(this)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns recipient addresses for a condition\\r\\n     */\\r\\n    function isRecipient(address account, uint256 conditionIndex)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        for (uint256 i; i < config.conditionBase.allocations.length; i++) {\\r\\n            address recipient = abi.decode(\\r\\n                datas.slots[\\r\\n                    config.conditionBase.allocations[i].recipientAddressSlot\\r\\n                ][conditionIndex],\\r\\n                (address)\\r\\n            );\\r\\n\\r\\n            if (account == recipient) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function getStatus(uint256 conditionIndex)\\r\\n        public\\r\\n        view\\r\\n        returns (SolverLib.Status status)\\r\\n    {\\r\\n        status = conditions[conditionIndex].status;\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ******************************** TOKENS ****************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Redeems CTs held by this Solver. See ConditionalTokens contract for more info.\\r\\n     */\\r\\n    function redeemPosition(\\r\\n        IERC20 _collateralToken,\\r\\n        bytes32 _parentCollectionId,\\r\\n        bytes32 _conditionId,\\r\\n        uint256[] calldata _indexSets\\r\\n    ) external {\\r\\n        require(msg.sender == config.keeper, \\\"Only Keeper\\\");\\r\\n        IConditionalTokens(ctfAddress).redeemPositions(\\r\\n            _collateralToken,\\r\\n            _parentCollectionId,\\r\\n            _conditionId,\\r\\n            _indexSets\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external virtual override returns (bytes4) {\\r\\n        return this.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external virtual override returns (bytes4) {\\r\\n        return this.onERC1155BatchReceived.selector;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x9597c48ce4329f88c705b4fe809247fda6d6713bbc16e5b229b83b5a8b5aa384\",\"license\":\"GPL-3.0\"},\"contracts/SolverLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./Solver.sol\\\";\\r\\nimport \\\"./interfaces/ISolver.sol\\\";\\r\\nimport \\\"./interfaces/IConditionalTokens.sol\\\";\\r\\nimport \\\"./interfaces/ISolverFactory.sol\\\";\\r\\nimport \\\"./FullMath.sol\\\";\\r\\n\\r\\nlibrary SolverLib {\\r\\n    // Ingest Types\\r\\n    enum IngestType {\\r\\n        Callback,\\r\\n        Constant,\\r\\n        Function,\\r\\n        Manual\\r\\n    }\\r\\n\\r\\n    // Status state for Conditions\\r\\n    enum Status {\\r\\n        Initiated, // Default state\\r\\n        Executed, // Solver has executed according to configuration\\r\\n        OutcomeProposed, // Outcome has been proposed for reporting\\r\\n        ArbitrationRequested, // Arbitration has been requested for this condition\\r\\n        ArbitrationDelivered, // Arbitration (except 'null' arbitration) has been delivered for this condition\\r\\n        OutcomeReported // Outcome has been reported to the CTF via reportPayouts()\\r\\n    }\\r\\n\\r\\n    struct Multihash {\\r\\n        bytes32 digest;\\r\\n        uint8 hashFunction;\\r\\n        uint8 size;\\r\\n    }\\r\\n\\r\\n    // Expected sources of data being ingested into the Solver\\r\\n    struct Ingest {\\r\\n        uint256 executions; // Number of times this Ingest has been executed\\r\\n        IngestType ingestType;\\r\\n        bytes32 slot; // Destination slot for data\\r\\n        uint256 solverIndex; // Index of the Solver in the chain to make function call to or register callback\\r\\n        bytes data; // Raw when isConstant=true, slot index of upstream solver data when callback, else an encoded function call\\r\\n    }\\r\\n\\r\\n    // Condition object created by addCondition() from ConditionBase\\r\\n    struct Condition {\\r\\n        IERC20 collateralToken;\\r\\n        bytes32 questionId; // // keccak256(abi.encodePacked(config.conditionBase.metadata, address(this), conditions.length))\\r\\n        bytes32 parentCollectionId; // ID of the parent collection above this Solver in the CTF\\r\\n        bytes32 conditionId; // ID of this condition in the CTF\\r\\n        uint256[] payouts; // Currently proposed payouts. Final if reported == true\\r\\n        Status status; // Status of this condition\\r\\n    }\\r\\n\\r\\n    // Configuration of this Solver\\r\\n    struct Config {\\r\\n        Solver implementation; // The implementation address for this Solver\\r\\n        address keeper; // Keeper address\\r\\n        address arbitrator; // Arbitrator address\\r\\n        uint256 timelockSeconds; // Number of seconds to increment timelock for during critical activities\\r\\n        bytes data; // Arbitrary data\\r\\n        Ingest[] ingests; // Data ingests to be performed to bring data in from other Solver\\r\\n        ConditionBase conditionBase; // Base to create conditions from\\r\\n    }\\r\\n\\r\\n    struct Datas {\\r\\n        mapping(bytes32 => bytes[]) slots;\\r\\n        mapping(bytes32 => uint256) slotIngestIdx;\\r\\n    }\\r\\n\\r\\n    struct Callbacks {\\r\\n        uint256 numIncoming;\\r\\n        uint256 numOutgoing;\\r\\n        mapping(bytes32 => address[]) outgoing; // This Slot => Solver expecting callback\\r\\n        mapping(bytes32 => uint256) incoming; // keccack256(Address, CallerSlot) => Receiving Ingest\\r\\n    }\\r\\n\\r\\n    // Immutable data regarding conditions which may be created\\r\\n    struct ConditionBase {\\r\\n        IERC20 collateralToken;\\r\\n        uint256 outcomeSlots; // Num outcome slots\\r\\n        uint256 parentCollectionIndexSet; // IndexSet to get parentCollectionId from parent Solver\\r\\n        bytes32 amountSlot; // Slot for amount of collateral being used        // TODO maybe make this dynamic also\\r\\n        uint256[] partition; // Partition of positions for payouts\\r\\n        Allocation[] allocations; // Allocations for each partition\\r\\n        Multihash[] outcomeURIs; // Resource containing human-friendly descriptions of the conditions for this Solver\\r\\n    }\\r\\n\\r\\n    struct Allocation {\\r\\n        bytes32 recipientAddressSlot; // Slot containing address of recipient\\r\\n        bytes32[] recipientAmountSlots; // recipientAmountSlots[i] => amount for partition[i]\\r\\n    }\\r\\n\\r\\n    event DeployedChild(address child);\\r\\n    event ChangedStatus(bytes32 conditionId);\\r\\n    event DeliveredNullArbitration(bytes32 conditionId);\\r\\n\\r\\n    function executeSolve(\\r\\n        uint256 index,\\r\\n        address ctfAddress,\\r\\n        Condition storage condition,\\r\\n        ConditionBase storage base,\\r\\n        Datas storage datas,\\r\\n        bytes32 trackingId,\\r\\n        address chainParent,\\r\\n        uint256 amount\\r\\n    ) public {\\r\\n        require(\\r\\n            condition.status == SolverLib.Status.Initiated,\\r\\n            \\\"not Initiated\\\"\\r\\n        );\\r\\n        require(\\r\\n            allocationsValid(index, datas, base),\\r\\n            \\\"Recipient slot requires updating\\\"\\r\\n        );\\r\\n\\r\\n        condition.status = SolverLib.Status.Executed;\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n\\r\\n        splitPosition(ctfAddress, chainParent, base, condition, amount);\\r\\n        allocatePartition(\\r\\n            index,\\r\\n            ctfAddress,\\r\\n            condition,\\r\\n            base,\\r\\n            datas,\\r\\n            trackingId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function createCondition(\\r\\n        address ctfAddress,\\r\\n        ConditionBase calldata base,\\r\\n        address chainParent,\\r\\n        uint256 conditionIdx\\r\\n    ) public returns (Condition memory condition) {\\r\\n        condition.questionId = keccak256(\\r\\n            abi.encode(base.outcomeURIs, address(this), conditionIdx)\\r\\n        );\\r\\n\\r\\n        if (chainParent == address(0)) {\\r\\n            condition.parentCollectionId = bytes32(\\\"\\\"); // top level collection\\r\\n        } else {\\r\\n            Condition[] memory _chainParentConditions = ISolver(chainParent)\\r\\n                .getConditions();\\r\\n\\r\\n            require(\\r\\n                _chainParentConditions.length > 0,\\r\\n                \\\"Parent has no conditions\\\"\\r\\n            );\\r\\n\\r\\n            condition.parentCollectionId = getCollectionId(\\r\\n                ctfAddress,\\r\\n                _chainParentConditions[_chainParentConditions.length - 1],\\r\\n                base.parentCollectionIndexSet\\r\\n            );\\r\\n        }\\r\\n\\r\\n        condition.conditionId = IConditionalTokens(ctfAddress).getConditionId(\\r\\n            address(this), // Solver is Oracle\\r\\n            condition.questionId,\\r\\n            base.outcomeSlots\\r\\n        );\\r\\n\\r\\n        condition.collateralToken = base.collateralToken;\\r\\n\\r\\n        IConditionalTokens(ctfAddress).prepareCondition(\\r\\n            address(this),\\r\\n            condition.questionId,\\r\\n            base.outcomeSlots\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployChild(\\r\\n        address factoryAddress,\\r\\n        Config calldata config,\\r\\n        uint256 solverIndex,\\r\\n        bytes32 trackingId\\r\\n    ) public returns (address child) {\\r\\n        child = ISolverFactory(factoryAddress).createSolver(\\r\\n            address(this),\\r\\n            solverIndex + 1,\\r\\n            config\\r\\n        );\\r\\n\\r\\n        if (trackingId != bytes32(\\\"\\\")) {\\r\\n            ISolver(child).setTrackingId(trackingId);\\r\\n        }\\r\\n\\r\\n        emit DeployedChild(child);\\r\\n\\r\\n        return child;\\r\\n    }\\r\\n\\r\\n    function getPositionId(\\r\\n        address ctfAddress,\\r\\n        Condition memory condition,\\r\\n        IERC20 collateralToken,\\r\\n        uint256 partition\\r\\n    ) public view returns (uint256 positionId) {\\r\\n        IConditionalTokens ct = IConditionalTokens(ctfAddress);\\r\\n        positionId = ct.getPositionId(\\r\\n            collateralToken,\\r\\n            ct.getCollectionId(\\r\\n                condition.parentCollectionId,\\r\\n                condition.conditionId,\\r\\n                partition\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function splitPosition(\\r\\n        address ctfAddress,\\r\\n        address chainParent,\\r\\n        ConditionBase storage base,\\r\\n        Condition storage condition,\\r\\n        uint256 amount\\r\\n    ) public {\\r\\n        uint256 _balance;\\r\\n\\r\\n        IConditionalTokens ICT = IConditionalTokens(ctfAddress);\\r\\n\\r\\n        if (chainParent == address(0)) {\\r\\n            _balance = IERC20(base.collateralToken).balanceOf(address(this));\\r\\n            base.collateralToken.approve(ctfAddress, bpToNum(amount, _balance));\\r\\n        } else {\\r\\n            _balance = ICT.balanceOf(\\r\\n                address(this),\\r\\n                ICT.getPositionId(\\r\\n                    base.collateralToken,\\r\\n                    condition.parentCollectionId\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n\\r\\n        ICT.splitPosition(\\r\\n            base.collateralToken,\\r\\n            condition.parentCollectionId,\\r\\n            condition.conditionId,\\r\\n            base.partition,\\r\\n            bpToNum(amount, _balance)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function reportPayouts(address ctfAddress, Condition storage condition)\\r\\n        public\\r\\n    {\\r\\n        IConditionalTokens(ctfAddress).reportPayouts(\\r\\n            condition.questionId,\\r\\n            condition.payouts\\r\\n        );\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function reportPayouts(\\r\\n        address ctfAddress,\\r\\n        Condition storage condition,\\r\\n        uint256[] memory payouts\\r\\n    ) public {\\r\\n        IConditionalTokens(ctfAddress).reportPayouts(\\r\\n            condition.questionId,\\r\\n            payouts\\r\\n        );\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function proposePayouts(\\r\\n        Condition storage condition,\\r\\n        uint256[] calldata _payouts\\r\\n    ) public {\\r\\n        condition.status = Status.OutcomeProposed;\\r\\n        condition.payouts = _payouts;\\r\\n\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function confirmPayouts(address ctfAddress, Condition storage condition)\\r\\n        public\\r\\n    {\\r\\n        condition.status = Status.OutcomeReported;\\r\\n        reportPayouts(ctfAddress, condition);\\r\\n    }\\r\\n\\r\\n    function arbitrationRequested(Condition storage condition) public {\\r\\n        condition.status = Status.ArbitrationRequested;\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function arbitrateNull(Condition storage condition) public {\\r\\n        condition.status = Status.OutcomeProposed;\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n        emit DeliveredNullArbitration(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function arbitrate(\\r\\n        address ctfAddress,\\r\\n        Condition storage condition,\\r\\n        uint256[] memory payouts\\r\\n    ) public {\\r\\n        condition.status = Status.ArbitrationDelivered;\\r\\n        reportPayouts(ctfAddress, condition, payouts);\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function allocationsValid(\\r\\n        uint256 conditionVer,\\r\\n        Datas storage datas,\\r\\n        ConditionBase storage conditionBase\\r\\n    ) public view returns (bool valid) {\\r\\n        valid = true;\\r\\n\\r\\n        for (uint256 i = 0; i < conditionBase.allocations.length; i++) {\\r\\n            if (\\r\\n                datas\\r\\n                    .slots[conditionBase.allocations[i].recipientAddressSlot]\\r\\n                    .length != (conditionVer + 1)\\r\\n            ) {\\r\\n                valid = false;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function allocatePartition(\\r\\n        uint256 conditionVer,\\r\\n        address ctfAddress,\\r\\n        Condition storage condition,\\r\\n        ConditionBase storage base,\\r\\n        Datas storage data,\\r\\n        bytes32 trackingId\\r\\n    ) public {\\r\\n        uint256[] memory _tokens = new uint256[](base.partition.length);\\r\\n        uint256[] memory _balances = new uint256[](base.partition.length);\\r\\n        address[] memory _addressThis = new address[](base.partition.length);\\r\\n\\r\\n        for (uint256 i; i < base.partition.length; i++) {\\r\\n            _tokens[i] = getPositionId(\\r\\n                ctfAddress,\\r\\n                condition,\\r\\n                base.collateralToken,\\r\\n                base.partition[i]\\r\\n            );\\r\\n            _addressThis[i] = address(this); // For more efficient balanceOfBatch call\\r\\n        }\\r\\n\\r\\n        _balances = IConditionalTokens(ctfAddress).balanceOfBatch(\\r\\n            _addressThis,\\r\\n            _tokens\\r\\n        );\\r\\n\\r\\n        for (uint256 i; i < base.allocations.length; i++) {\\r\\n            uint256[] memory _amounts = new uint256[](base.partition.length);\\r\\n\\r\\n            for (\\r\\n                uint256 j;\\r\\n                j < base.allocations[i].recipientAmountSlots.length;\\r\\n                j++\\r\\n            ) {\\r\\n                uint256 _pctValue = abi.decode(\\r\\n                    data.slots[base.allocations[i].recipientAmountSlots[j]][\\r\\n                        conditionVer\\r\\n                    ],\\r\\n                    (uint256)\\r\\n                );\\r\\n                if (_pctValue == 0) {\\r\\n                    _amounts[j] = 0;\\r\\n                } else {\\r\\n                    _amounts[j] = bpToNum(_pctValue, _balances[j]);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            IConditionalTokens(ctfAddress).safeBatchTransferFrom(\\r\\n                address(this),\\r\\n                abi.decode(\\r\\n                    data.slots[base.allocations[i].recipientAddressSlot][\\r\\n                        conditionVer\\r\\n                    ],\\r\\n                    (address)\\r\\n                ),\\r\\n                _tokens,\\r\\n                _amounts,\\r\\n                abi.encode(trackingId)\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function bpToNum(uint256 bp, uint256 num) public pure returns (uint256) {\\r\\n        return FullMath.mulDiv(bp, num, 10000);\\r\\n    }\\r\\n\\r\\n    function ingest(Ingest storage _ingest)\\r\\n        public\\r\\n        view\\r\\n        returns (bytes memory data)\\r\\n    {\\r\\n        require(\\r\\n            _ingest.ingestType != IngestType.Manual,\\r\\n            \\\"Manual ingests should not get here\\\"\\r\\n        );\\r\\n\\r\\n        if (_ingest.ingestType == IngestType.Constant) {\\r\\n            data = _ingest.data;\\r\\n        } else {\\r\\n            address _solver = ISolver(address(this)).addressFromChainIndex(\\r\\n                _ingest.solverIndex\\r\\n            );\\r\\n            (bool success, bytes memory retData) = _solver.staticcall(\\r\\n                _ingest.data\\r\\n            );\\r\\n            require(success, \\\"Ingest staticcall failed\\\");\\r\\n            data = retData;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function ingestsValid(Ingest[] calldata ingests, uint256 conditionVer)\\r\\n        public\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        for (uint256 i; i < ingests.length; i++) {\\r\\n            if (ingests[i].executions != conditionVer) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getCollectionId(\\r\\n        address ctfAddress,\\r\\n        Condition memory condition,\\r\\n        uint256 partition\\r\\n    ) public view returns (bytes32 collectionId) {\\r\\n        collectionId = IConditionalTokens(ctfAddress).getCollectionId(\\r\\n            condition.parentCollectionId,\\r\\n            condition.conditionId,\\r\\n            partition\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xc43d4334b8ccf3d96b06c223f10ab3a49815654a348f01868fbfc7c9a90ad70e\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IConditionalTokens.sol\":{\"content\":\"/** \\r\\n    SPDX-License-Identifier: LGPL-3.0\\r\\n*/\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\n\\r\\n// Mainnet (ID: 1) canonical address: 0xC59b0e4De5F1248C1140964E0fF287B192407E0C\\r\\n// Rinkeby (ID: 4) canonical address: 0x36bede640D19981A82090519bC1626249984c908\\r\\n\\r\\ninterface IConditionalTokens is IERC1155 {\\r\\n    /// @dev This function prepares a condition by initializing a payout vector associated with the condition.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function prepareCondition(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) external;\\r\\n\\r\\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``, where oracle is the message sender, questionId is one of the parameters of this function, and outcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.\\r\\n    /// @param questionId The question ID the oracle is answering for\\r\\n    /// @param payouts The oracle's answer\\r\\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts)\\r\\n        external;\\r\\n\\r\\n    /// @dev This function splits a position. If splitting from the collateral, this contract will attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this contract will burn `amount` stake held by the message sender in the position being split worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the split target positions. If any of the transfers, mints, or burns fail, the transaction will revert. The transaction will also revert if the given partition is trivial, invalid, or refers to more slots than the condition is prepared with.\\r\\n    /// @param collateralToken The address of the positions' backing collateral token.\\r\\n    /// @param parentCollectionId The ID of the outcome collections common to the position being split and the split target positions. May be null, in which only the collateral is shared.\\r\\n    /// @param conditionId The ID of the condition to split on.\\r\\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint). Each element's a number which, together with the condition, represents the outcome collection. E.g. 0b110 is A|B, 0b010 is B, etc.\\r\\n    /// @param amount The amount of collateral or stake to split.\\r\\n    function splitPosition(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata partition,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function mergePositions(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata partition,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function redeemPositions(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata indexSets\\r\\n    ) external;\\r\\n\\r\\n    /// @dev Gets the outcome slot count of a condition.\\r\\n    /// @param conditionId ID of the condition.\\r\\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not been prepared yet.\\r\\n    function getOutcomeSlotCount(bytes32 conditionId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function getConditionId(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) external pure returns (bytes32);\\r\\n\\r\\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\\r\\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\\r\\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\\r\\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\\r\\n    function getCollectionId(\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256 indexSet\\r\\n    ) external view returns (bytes32);\\r\\n\\r\\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\\r\\n    /// @param collateralToken Collateral token which backs the position.\\r\\n    /// @param collectionId ID of the outcome collection associated with this position.\\r\\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\\r\\n        external\\r\\n        pure\\r\\n        returns (uint256);\\r\\n}\\r\\n\",\"keccak256\":\"0x72f8f9f2bd693fc5e2086cf13c3bfcf581142f82cf91bb1638fd3c90d17bd8dc\",\"license\":\"LGPL-3.0\"},\"contracts/interfaces/IIPFSSolutionsHub.sol\":{\"content\":\"pragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../IPFSSolutionsHub.sol\\\";\\r\\nimport \\\"../SolverLib.sol\\\";\\r\\n\\r\\ninterface IIPFSSolutionsHub {\\r\\n    struct Solution {\\r\\n        bool executed;\\r\\n        IERC20 collateralToken;\\r\\n        address proposalHub;\\r\\n        bytes32 proposalId;\\r\\n        bytes32 id;\\r\\n        bytes32 solverConfigsHash;\\r\\n        SolverLib.Multihash solverConfigsCID;\\r\\n        address[] solverAddresses;\\r\\n    }\\r\\n\\r\\n    function createBase(\\r\\n        bytes32 baseId,\\r\\n        IERC20 collateralToken,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        SolverLib.Multihash calldata solverConfigsCID\\r\\n    ) external;\\r\\n\\r\\n    function createInstance(bytes32 baseId, bytes32 instanceId)\\r\\n        external\\r\\n        returns (bytes32 solutionId);\\r\\n\\r\\n    function createSolution(\\r\\n        bytes32 _id,\\r\\n        IERC20 _collateralToken,\\r\\n        SolverLib.Config[] calldata _solverConfigs,\\r\\n        SolverLib.Multihash calldata _solverConfigsCID\\r\\n    ) external returns (bytes32 _solutionId);\\r\\n\\r\\n    function linkToProposal(\\r\\n        bytes32 proposalId,\\r\\n        bytes32 solutionId,\\r\\n        IERC20 collateralToken\\r\\n    ) external;\\r\\n\\r\\n    function executeSolution(\\r\\n        bytes32 _proposalId,\\r\\n        bytes32 _solutionId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) external;\\r\\n\\r\\n    function solverFromIndex(bytes32 _solutionId, uint256 _solverIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (address solver);\\r\\n\\r\\n    function getSolvers(bytes32 _solutionId)\\r\\n        external\\r\\n        view\\r\\n        returns (address[] memory solvers);\\r\\n\\r\\n    function verifyHash(\\r\\n        bytes32 solutionId,\\r\\n        SolverLib.Config[] memory solverConfigs\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function getSolution(bytes32 id)\\r\\n        external\\r\\n        view\\r\\n        returns (IPFSSolutionsHub.Solution memory);\\r\\n}\\r\\n\",\"keccak256\":\"0x3782f01378df1ccd1f0b93c33a4cf3c0f9fa16b7e40a47d5bf98f3f42ad65237\"},\"contracts/interfaces/IProposalsHub.sol\":{\"content\":\"pragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../SolverLib.sol\\\";\\r\\nimport \\\"../ProposalsHub.sol\\\";\\r\\nimport \\\"./IIPFSSolutionsHub.sol\\\";\\r\\n\\r\\ninterface IProposalsHub {\\r\\n    function executeProposal(bytes32 proposalId) external;\\r\\n\\r\\n    function executeIPFSProposal(\\r\\n        bytes32 proposalId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) external;\\r\\n\\r\\n    function approveERC20Transfer(bytes32 proposalId, address solver) external;\\r\\n\\r\\n    function createProposal(\\r\\n        IERC20 collateralToken,\\r\\n        address solutionsHub,\\r\\n        uint256 fundingGoal,\\r\\n        bytes32 solutionId\\r\\n    ) external;\\r\\n\\r\\n    function createIPFSSolutionAndProposal(\\r\\n        bytes32 solutionId,\\r\\n        IERC20 collateralToken,\\r\\n        IIPFSSolutionsHub ipfsSolutionsHub,\\r\\n        uint256 fundingGoal,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        SolverLib.Multihash calldata solverConfigsCID,\\r\\n        SolverLib.Multihash calldata metadataCID\\r\\n    ) external returns (bytes32 solutionID, bytes32 proposalID);\\r\\n\\r\\n    function fundProposal(\\r\\n        bytes32 proposalId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function defundProposal(\\r\\n        bytes32 proposalId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function getMetadataCID(bytes32 id)\\r\\n        external\\r\\n        view\\r\\n        returns (SolverLib.Multihash memory);\\r\\n\\r\\n    function isProposal(bytes32 id) external view returns (bool);\\r\\n\\r\\n    function getProposal(bytes32 id)\\r\\n        external\\r\\n        view\\r\\n        returns (ProposalsHub.Proposal memory proposal);\\r\\n\\r\\n    function transferERC20(bytes32 proposalId, address solver) external;\\r\\n\\r\\n    function reclaimTokens(bytes32 proposalId, uint256 tokenId) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xc8956649a0f9d5f76b9d16849a3c9ac3d17e984212af33369d2c831cce54f1ab\"},\"contracts/interfaces/ISolver.sol\":{\"content\":\"pragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"../ConditionalTokens.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../Solver.sol\\\";\\r\\nimport \\\"../SolverLib.sol\\\";\\r\\n\\r\\ninterface ISolver {\\r\\n    // INITIALIZATION - Only called by SolverFactory\\r\\n    function init(\\r\\n        address _chainParent,\\r\\n        uint256 _chainIndex,\\r\\n        SolverLib.Config calldata _solverConfig\\r\\n    ) external;\\r\\n\\r\\n    // PREP AND EXECUTE\\r\\n\\r\\n    function prepareSolve(uint256 _index) external;\\r\\n\\r\\n    function deployChild(SolverLib.Config calldata _config)\\r\\n        external\\r\\n        returns (Solver _solver);\\r\\n\\r\\n    function executeSolve(uint256 _index) external;\\r\\n\\r\\n    // DATA\\r\\n\\r\\n    function addData(bytes32 _slot, bytes memory _data) external;\\r\\n\\r\\n    function getData(bytes32 _slot) external view returns (bytes memory data);\\r\\n\\r\\n    // CALLBACKS\\r\\n\\r\\n    function registerOutgoingCallback(bytes32 _slot, uint256 _chainIndex)\\r\\n        external;\\r\\n\\r\\n    function handleCallback(bytes32 _slot) external;\\r\\n\\r\\n    function getCallbackOutput(bytes32 _slot)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes memory data);\\r\\n\\r\\n    function getOutgoingCallbacks(uint256 slot)\\r\\n        external\\r\\n        view\\r\\n        returns (address[] memory);\\r\\n\\r\\n    // REPORTING\\r\\n\\r\\n    function proposePayouts(uint256 _index, uint256[] calldata _payouts)\\r\\n        external;\\r\\n\\r\\n    function confirmPayouts(uint256 _index) external;\\r\\n\\r\\n    // ARBITRATION\\r\\n\\r\\n    function arbitrate(uint256 _index, uint256[] calldata _payouts) external;\\r\\n\\r\\n    function arbitrateNull(uint256 _index) external;\\r\\n\\r\\n    function arbitrationRequested(uint256 _index) external;\\r\\n\\r\\n    function arbitrationPending(uint256 _index) external;\\r\\n\\r\\n    // UTILITY\\r\\n\\r\\n    function ingestsValid() external view returns (bool);\\r\\n\\r\\n    function allocationsValid(uint256 _index) external view returns (bool);\\r\\n\\r\\n    function addressFromChainIndex(uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (address _address);\\r\\n\\r\\n    function setTrackingId(bytes32 _trackingId) external;\\r\\n\\r\\n    function getConditions()\\r\\n        external\\r\\n        view\\r\\n        returns (SolverLib.Condition[] memory);\\r\\n\\r\\n    function condition(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (SolverLib.Condition memory);\\r\\n\\r\\n    function keeper() external view returns (address);\\r\\n\\r\\n    function arbitrator() external view returns (address);\\r\\n\\r\\n    function collateralBalance() external view returns (uint256 balance);\\r\\n\\r\\n    function timelocks(uint256 conditionIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 timelock);\\r\\n\\r\\n    function isRecipient(address account, uint256 conditionIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function getStatus(uint256 conditionIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (SolverLib.Status status);\\r\\n\\r\\n    function redeemPosition(\\r\\n        IERC20 _collateralToken,\\r\\n        bytes32 _parentCollectionId,\\r\\n        bytes32 _conditionId,\\r\\n        uint256[] calldata _indexSets\\r\\n    ) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x11761a8d686fcfefeeee7390085227a65503500a1dcf1a56f26956c743a445aa\"},\"contracts/interfaces/ISolverFactory.sol\":{\"content\":\"pragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"../SolverLib.sol\\\";\\r\\n\\r\\ninterface ISolverFactory {\\r\\n    function createSolver(\\r\\n        address chainParent,\\r\\n        uint256 chainIndex,\\r\\n        SolverLib.Config calldata solverConfig\\r\\n    ) external returns (address);\\r\\n}\\r\\n\",\"keccak256\":\"0xa314c68d8de81eccedd1c296ade494d275cf13634c37da2bb15667df8fdeb09e\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b506040516200270a3803806200270a833981016040819052620000349162000046565b6001600160a01b031660805262000078565b6000602082840312156200005957600080fd5b81516001600160a01b03811681146200007157600080fd5b9392505050565b60805161266f6200009b6000396000818161027f01526111d7015261266f6000f3fe608060405234801561001057600080fd5b50600436106100e65760003560e01c806301ffc9a7146100eb5780631918063f1461011357806332c8506e1461012857806332ed5b121461013b57806333c15c34146101e3578063430694cf1461021c57806353ba3f571461023c57806354dd9927146102675780635bd9e2991461027a5780635d7dec6f146102ae57806383460ba8146102d6578063aaa4f33214610301578063aaf7a21414610321578063b70c764c14610334578063bc197c8114610347578063c12639f714610373578063d3f79a0514610386578063f23a6e61146103ab575b600080fd5b6100fe6100f9366004611821565b6103be565b60405190151581526020015b60405180910390f35b61012661012136600461187a565b6103f5565b005b6101266101363660046118f5565b61075d565b6101ce610149366004611940565b600160208181526000928352604092839020805492810154600282015460038301546004840154600585015460068601548951606081018b526007880154815260089097015460ff818116998901999099526101009081900489169a88019a909a52968816986001600160a01b03980488169794851696939094169491939092909189565b60405161010a99989796959493929190611988565b61020e6101f136600461187a565b600460209081526000928352604080842090915290825290205481565b60405190815260200161010a565b61022f61022a366004611940565b6108b4565b60405161010a91906119e9565b61020e61024a366004611a71565b600360209081526000928352604080842090915290825290205481565b610126610275366004611a93565b610970565b6102a17f000000000000000000000000000000000000000000000000000000000000000081565b60405161010a9190611acb565b6102c16102bc366004611af7565b610d02565b6040805192835260208301919091520161010a565b61020e6102e436600461187a565b600260209081526000928352604080842090915290825290205481565b61031461030f366004611940565b610f2d565b60405161010a9190611b53565b6102c161032f366004611b61565b610f7b565b610126610342366004611a71565b611002565b61035a610355366004611c42565b611282565b6040516001600160e01b0319909116815260200161010a565b610126610381366004611a93565b611361565b6100fe610394366004611940565b600090815260016020526040902060030154151590565b61035a6103b9366004611d00565b6116ea565b60006001600160e01b03198216630271189760e51b14806103ef57506301ffc9a760e01b6001600160e01b03198316145b92915050565b6000828152600160205260409020600201546001600160a01b031633146104615760405162461bcd60e51b815260206004820152601b60248201527a36b9b39739b2b73232b9103737ba1039b7b63aba34b7b739a43ab160291b60448201526064015b60405180910390fd5b6001600160a01b0381166104a95760405162461bcd60e51b815260206004820152600f60248201526e496e76616c6964206164647265737360881b6044820152606401610458565b6000828152600160205260408082206002810154600491820154925162c8a40d60e51b81526001600160a01b038087169592169363191481a0936104f893919201918252602082015260400190565b602060405180830381865afa158015610515573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105399190611d7b565b6001600160a01b03161461058a5760405162461bcd60e51b8152602060048201526018602482015277496e636f727265637420736f6c766572206164647265737360401b6044820152606401610458565b6000828152600160205260408082205490516370a0823160e01b81526101009091046001600160a01b0316919082906370a08231906105cd903090600401611acb565b602060405180830381865afa1580156105ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060e9190611d98565b6000858152600160205260409081902060050154905163a9059cbb60e01b81529192506001600160a01b0384169163a9059cbb9161065191879190600401611db1565b6020604051808303816000875af1158015610670573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106949190611dca565b6106b05760405162461bcd60e51b815260040161045890611dec565b600084815260016020526040908190206006015490516370a0823160e01b81526001600160a01b038416906370a08231906106ef903090600401611acb565b602060405180830381865afa15801561070c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107309190611d98565b61073a9083611e2b565b146107575760405162461bcd60e51b815260040161045890611e42565b50505050565b6000838152600160205260409020600681015460059091015410156107c05760405162461bcd60e51b8152602060048201526019602482015278141c9bdc1bdcd85b081b9bdd08199d5b1b1e48199d5b991959603a1b6044820152606401610458565b60008381526001602052604090205460ff16156107ef5760405162461bcd60e51b815260040161045890611e77565b6000838152600160205260409081902060028101546004918201549251632034967b60e21b81526001600160a01b03909116926380d259ec92610839928892918891889101612355565b600060405180830381600087803b15801561085357600080fd5b505af1158015610867573d6000803e3d6000fd5b5050506000848152600160208190526040808320805460ff1916909217909155518592507f3a5a0357f01e19a1531e65bfe13d63c64c9ae8f03d8c26ae74b1e2929a4f39669190a2505050565b6108bc6117ae565b50600090815260016020818152604092839020835161012081018552815460ff808216151583526001600160a01b036101009283900481168487015295840154861683880152600284015490951660608084019190915260038401546080840152600484015460a0840152600584015460c0840152600684015460e0840152865190810187526007840154815260089093015480861694840194909452928390049093169381019390935281019190915290565b60008381526001602052604081206003015490036109a05760405162461bcd60e51b815260040161045890612375565b60008381526001602052604090205460ff16156109cf5760405162461bcd60e51b815260040161045890611e77565b6000838152600160205260409020546001600160a01b038381166101009092041614610a0d5760405162461bcd60e51b8152600401610458906123a6565b60008111610a2d5760405162461bcd60e51b8152600401610458906123f7565b6000838152600260209081526040808320338452909152902054811115610aa45760405162461bcd60e51b815260206004820152602560248201527f436f6d6d69747465642066756e6473206973206c6f776572207468616e20616d60448201526437bab73a1760d91b6064820152608401610458565b6040516370a0823160e01b81526000906001600160a01b038416906370a0823190610ad3903090600401611acb565b602060405180830381865afa158015610af0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b149190611d98565b905081600160008681526020019081526020016000206005016000828254610b3c9190611e2b565b9091555050600084815260026020908152604080832033845290915281208054849290610b6a908490611e2b565b909155505060405163a9059cbb60e01b81526001600160a01b0384169063a9059cbb90610b9d9033908690600401611db1565b6020604051808303816000875af1158015610bbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610be09190611dca565b610bfc5760405162461bcd60e51b815260040161045890611dec565b6040516370a0823160e01b815282906001600160a01b038516906370a0823190610c2a903090600401611acb565b602060405180830381865afa158015610c47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c6b9190611d98565b610c759083611e2b565b14610cc25760405162461bcd60e51b815260206004820152601e60248201527f4265666f726520616e642061667465722062616c616e63652077726f6e6700006044820152606401610458565b837fe2ab43d60bbb163b7fad7413086cd6c1ee0e0a59a9625e4945a10f1b6a167ff98333604051610cf4929190612426565b60405180910390a250505050565b6000805481908180610d138361243d565b90915550506001600160a01b03861663c4e3983f8580610d34600143611e2b565b6000546040805160208101949094529140918301919091526060820152608001604051602081830303815290604052805190602001206040518363ffffffff1660e01b8152600401610d90929190918252602082015260400190565b6020604051808303816000875af1158015610daf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dd39190611d98565b915081600054604051602001610df3929190918252602082015260400190565b60408051808303601f190181528282528051602091820120600081815260019092529190206003810182905563a2440b9d60e01b835260048301829052602483018590526001600160a01b038a81166044850152919350919088169063a2440b9d90606401600060405180830381600087803b158015610e7257600080fd5b505af1158015610e86573d6000803e3d6000fd5b505082546001600160a01b03808c1661010002610100600160a81b03199092169190911784556001840180546001600160a01b03199081163317909155600285018054928c1692909116919091179055505060048101839055600681018690558360078201610ef58282612456565b505060405182907f2d231481d8c1af3958a30a257e93e0df6b089bc07ebedc0a86e7355d1aaf133890600090a2509550959350505050565b610f35611801565b5060009081526001602090815260409182902082516060810184526007820154815260089091015460ff8082169383019390935261010090049091169181019190915290565b600080876001600160a01b031663fa1a84c78b8b8989896040518663ffffffff1660e01b8152600401610fb295949392919061249a565b600060405180830381600087803b158015610fcc57600080fd5b505af1158015610fe0573d6000803e3d6000fd5b50505050610ff18989898d87610d02565b909b909a5098505050505050505050565b60008281526002602090815260408083203384529091529020546110765760405162461bcd60e51b815260206004820152602560248201527f50726f706f73616c734875623a3a6d73672e73656e64657220686173206e6f20604482015264636c61696d60d81b6064820152608401610458565b600082815260026020908152604080832033845282528083205485845260019092528220600501546110a891906124d4565b60008381526004602090815260408083203384528252808320548784526003835281842087855290925282205492935090916110e59084906124d4565b6110ef9190611e2b565b90506000811161113c5760405162461bcd60e51b8152602060048201526018602482015277050726f706f73616c734875623a3a436c61696d20697320360441b6044820152606401610458565b60008481526003602090815260408083208684529091529020548111156111a55760405162461bcd60e51b815260206004820181905260248201527f50726f706f73616c734875623a3a436c61696d20697320746f6f206c617267656044820152606401610458565b6000838152600460209081526040808320338452909152812080548392906111ce9084906124f6565b925050819055507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f242432a303386858960405160200161121b91815260200190565b6040516020818303038152906040526040518663ffffffff1660e01b815260040161124a95949392919061250e565b600060405180830381600087803b15801561126457600080fd5b505af1158015611278573d6000803e3d6000fd5b5050505050505050565b60008061129183850185611940565b60008181526001602052604090206003015490915081146112c45760405162461bcd60e51b81526004016104589061258d565b60008181526001602052604090205460ff166112f25760405162461bcd60e51b8152600401610458906125d7565b60005b8781101561134a57611338828a8a8481811061131357611313612623565b9050602002013589898581811061132c5761132c612623565b9050602002013561177b565b806113428161243d565b9150506112f5565b5063bc197c8160e01b9a9950505050505050505050565b60008381526001602052604081206003015490036113915760405162461bcd60e51b815260040161045890612375565b60008381526001602052604090205460ff16156113c05760405162461bcd60e51b815260040161045890611e77565b6000838152600160205260409020546001600160a01b0383811661010090920416146113fe5760405162461bcd60e51b8152600401610458906123a6565b6000811161141e5760405162461bcd60e51b8152600401610458906123f7565b6000838152600160205260409020600681015460059091015461144190836124f6565b111561148b5760405162461bcd60e51b815260206004820152601960248201527810d85b89dd08199d5b99081b5bdc99481d1a185b8819dbd85b603a1b6044820152606401610458565b6040516370a0823160e01b81526000906001600160a01b038416906370a08231906114ba903090600401611acb565b602060405180830381865afa1580156114d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114fb9190611d98565b6040516323b872dd60e01b8152336004820152306024820152604481018490529091506001600160a01b038416906323b872dd906064016020604051808303816000875af1158015611551573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115759190611dca565b6115cc5760405162461bcd60e51b815260206004820152602260248201527f436f756c64206e6f74207472616e736665722066726f6d206d73672e73656e6460448201526132b960f11b6064820152608401610458565b8181846001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016115fa9190611acb565b602060405180830381865afa158015611617573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061163b9190611d98565b6116459190611e2b565b146116625760405162461bcd60e51b815260040161045890611e42565b600084815260016020526040812060050180548492906116839084906124f6565b90915550506000848152600260209081526040808320338452909152812080548492906116b19084906124f6565b92505081905550837f82999597cf961179ae8200cb30fa0dcf5559a734cfd867ccd187c5dd6946c4138333604051610cf4929190612426565b6000806116f983850185611940565b600081815260016020526040902060030154909150811461172c5760405162461bcd60e51b81526004016104589061258d565b60008181526001602052604090205460ff1661175a5760405162461bcd60e51b8152600401610458906125d7565b61176581878761177b565b5063f23a6e6160e01b90505b9695505050505050565b6000838152600360209081526040808320858452909152812080548392906117a49084906124f6565b9091555050505050565b6040805161012081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081019190915261010081016117fc611801565b905290565b604080516060810182526000808252602082018190529181019190915290565b60006020828403121561183357600080fd5b81356001600160e01b03198116811461184b57600080fd5b9392505050565b6001600160a01b038116811461186757600080fd5b50565b803561187581611852565b919050565b6000806040838503121561188d57600080fd5b82359150602083013561189f81611852565b809150509250929050565b60008083601f8401126118bc57600080fd5b5081356001600160401b038111156118d357600080fd5b6020830191508360208260051b85010111156118ee57600080fd5b9250929050565b60008060006040848603121561190a57600080fd5b8335925060208401356001600160401b0381111561192757600080fd5b611933868287016118aa565b9497909650939450505050565b60006020828403121561195257600080fd5b5035919050565b6001600160a01b03169052565b8051825260ff602082015116602083015260ff60408201511660408301525050565b89151581526001600160a01b0389811660208301528881166040830152871660608201526080810186905260a0810185905260c0810184905260e0810183905261016081016119db610100830184611966565b9a9950505050505050505050565b8151151581526020808301516001600160a01b031690820152604080830151610160830191611a1a90840182611959565b506060830151611a2d6060840182611959565b506080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151611a6982850182611966565b505092915050565b60008060408385031215611a8457600080fd5b50508035926020909101359150565b600080600060608486031215611aa857600080fd5b833592506020840135611aba81611852565b929592945050506040919091013590565b6001600160a01b0391909116815260200190565b600060608284031215611af157600080fd5b50919050565b600080600080600060e08688031215611b0f57600080fd5b8535611b1a81611852565b94506020860135611b2a81611852565b93506040860135925060608601359150611b478760808801611adf565b90509295509295909350565b606081016103ef8284611966565b600080600080600080600080610160898b031215611b7e57600080fd5b883597506020890135611b9081611852565b96506040890135611ba081611852565b95506060890135945060808901356001600160401b03811115611bc257600080fd5b611bce8b828c016118aa565b9095509350611be290508a60a08b01611adf565b9150611bf28a6101008b01611adf565b90509295985092959890939650565b60008083601f840112611c1357600080fd5b5081356001600160401b03811115611c2a57600080fd5b6020830191508360208285010111156118ee57600080fd5b60008060008060008060008060a0898b031215611c5e57600080fd5b8835611c6981611852565b97506020890135611c7981611852565b965060408901356001600160401b0380821115611c9557600080fd5b611ca18c838d016118aa565b909850965060608b0135915080821115611cba57600080fd5b611cc68c838d016118aa565b909650945060808b0135915080821115611cdf57600080fd5b50611cec8b828c01611c01565b999c989b5096995094979396929594505050565b60008060008060008060a08789031215611d1957600080fd5b8635611d2481611852565b95506020870135611d3481611852565b9450604087013593506060870135925060808701356001600160401b03811115611d5d57600080fd5b611d6989828a01611c01565b979a9699509497509295939492505050565b600060208284031215611d8d57600080fd5b815161184b81611852565b600060208284031215611daa57600080fd5b5051919050565b6001600160a01b03929092168252602082015260400190565b600060208284031215611ddc57600080fd5b8151801515811461184b57600080fd5b6020808252600f908201526e151c985b9cd9995c8819985a5b1959608a1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b600082821015611e3d57611e3d611e15565b500390565b6020808252818101527f496e636f72726563742062616c616e6365206166746572207472616e73666572604082015260600190565b60208082526027908201527f50726f706f73616c734875623a3a50726f706f73616c20616c726561647920656040820152661e1958dd5d195960ca1b606082015260800190565b6000808335601e19843603018112611ed557600080fd5b83016020810192503590506001600160401b03811115611ef457600080fd5b8036038313156118ee57600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000808335601e19843603018112611f4357600080fd5b83016020810192503590506001600160401b03811115611f6257600080fd5b8060051b36038313156118ee57600080fd5b81835260006020808501808196508560051b810191508460005b878110156120185782840389528135609e19883603018112611faf57600080fd5b87018035855260a08682013560048110611fc857600080fd5b8688015260408281013590870152606080830135908701526080611fee81840184611ebe565b935082828901526120028389018583611f03565b9c89019c97505050928601925050600101611f8e565b5091979650505050505050565b6000823560de1983360301811261203b57600080fd5b90910192915050565b81835260006001600160fb1b0383111561205d57600080fd5b8260051b8083602087013760009401602001938452509192915050565b6000808335601e1984360301811261209157600080fd5b83016020810192503590506001600160401b038111156120b057600080fd5b6060810236038313156118ee57600080fd5b60ff8116811461186757600080fd5b8035825260208101356120e3816120c2565b60ff16602083015260408101356120f9816120c2565b60ff81166040840152505050565b81835260208301925060008160005b8481101561213b5761212886836120d1565b6060958601959190910190600101612116565b5093949350505050565b6000813561215281611852565b6001600160a01b031683526020828101358185015260408084013581860152606080850135908601526121886080850185611f2c565b60e0608088015261219d60e088018284612044565b9150506121ad60a0860186611f2c565b87830360a0890152808352848301600582901b84018601836000805b8581101561222857878403601f19018552823536889003603e190181126121ee578283fd5b8701803585526122008b820182611f2c565b91508a8c8701526122148b87018383612044565b968c019695505050918901916001016121c9565b50505061223860c08a018a61207a565b9750955089810360c08b01526119db818888612107565b81835260006020808501808196508560051b810191508460005b878110156120185782840389526122808288612025565b60e0813561228d81611852565b6001600160a01b031686526122a382880161186a565b6122af88880182611959565b5060406122bd81840161186a565b6122c982890182611959565b50506060828101359087015260806122e381840184611ebe565b83838a01526122f5848a018284611f03565b935050505060a061230881840184611f2c565b888403838a015261231a848284611f74565b935050505060c061232d81840184612025565b925086820381880152506123418183612145565b9a87019a9550505090840190600101612269565b84815283602082015260606040820152600061177160608301848661224f565b602080825260179082015276141c9bdc1bdcd85b08191bd95cc81b9bdd08195e1a5cdd604a1b604082015260600190565b60208082526031908201527f50726f706f73616c20646f6573206e6f7420696e636c756465207468697320746040820152701bdad95b881d1bc8189948199d5b991959607a1b606082015260800190565b602080825260159082015274416d6f756e742063616e6e6f74206265207a65726f60581b604082015260600190565b9182526001600160a01b0316602082015260400190565b60006001820161244f5761244f611e15565b5060010190565b8135815560018101602083013561246c816120c2565b8154604085013561247c816120c2565b61ff008160081b1660ff841661ffff19841617178455505050505050565b8581526001600160a01b038516602082015260c0604082018190526000906124c5908301858761224f565b905061177160608301846120d1565b6000826124f157634e487b7160e01b600052601260045260246000fd5b500490565b6000821982111561250957612509611e15565b500190565b600060018060a01b03808816835260208188168185015286604085015285606085015260a06080850152845191508160a085015260005b828110156125615785810182015185820160c001528101612545565b8281111561257357600060c084870101525b5050601f01601f19169190910160c0019695505050505050565b6020808252602a908201527f50726f706f73616c734875623a3a44617461206973206e6f742076616c6964206040820152691c1c9bdc1bdcd85b125960b21b606082015260800190565b6020808252602c908201527f50726f706f73616c734875623a3a50726f706f73616c20686173206e6f74206260408201526b19595b88195e1958dd5d195960a21b606082015260800190565b634e487b7160e01b600052603260045260246000fdfea264697066735822122011f4669f2fd82b339c2b3f19acb6cd81e7232847590806e29bf348180aec2b1464736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100e65760003560e01c806301ffc9a7146100eb5780631918063f1461011357806332c8506e1461012857806332ed5b121461013b57806333c15c34146101e3578063430694cf1461021c57806353ba3f571461023c57806354dd9927146102675780635bd9e2991461027a5780635d7dec6f146102ae57806383460ba8146102d6578063aaa4f33214610301578063aaf7a21414610321578063b70c764c14610334578063bc197c8114610347578063c12639f714610373578063d3f79a0514610386578063f23a6e61146103ab575b600080fd5b6100fe6100f9366004611821565b6103be565b60405190151581526020015b60405180910390f35b61012661012136600461187a565b6103f5565b005b6101266101363660046118f5565b61075d565b6101ce610149366004611940565b600160208181526000928352604092839020805492810154600282015460038301546004840154600585015460068601548951606081018b526007880154815260089097015460ff818116998901999099526101009081900489169a88019a909a52968816986001600160a01b03980488169794851696939094169491939092909189565b60405161010a99989796959493929190611988565b61020e6101f136600461187a565b600460209081526000928352604080842090915290825290205481565b60405190815260200161010a565b61022f61022a366004611940565b6108b4565b60405161010a91906119e9565b61020e61024a366004611a71565b600360209081526000928352604080842090915290825290205481565b610126610275366004611a93565b610970565b6102a17f000000000000000000000000000000000000000000000000000000000000000081565b60405161010a9190611acb565b6102c16102bc366004611af7565b610d02565b6040805192835260208301919091520161010a565b61020e6102e436600461187a565b600260209081526000928352604080842090915290825290205481565b61031461030f366004611940565b610f2d565b60405161010a9190611b53565b6102c161032f366004611b61565b610f7b565b610126610342366004611a71565b611002565b61035a610355366004611c42565b611282565b6040516001600160e01b0319909116815260200161010a565b610126610381366004611a93565b611361565b6100fe610394366004611940565b600090815260016020526040902060030154151590565b61035a6103b9366004611d00565b6116ea565b60006001600160e01b03198216630271189760e51b14806103ef57506301ffc9a760e01b6001600160e01b03198316145b92915050565b6000828152600160205260409020600201546001600160a01b031633146104615760405162461bcd60e51b815260206004820152601b60248201527a36b9b39739b2b73232b9103737ba1039b7b63aba34b7b739a43ab160291b60448201526064015b60405180910390fd5b6001600160a01b0381166104a95760405162461bcd60e51b815260206004820152600f60248201526e496e76616c6964206164647265737360881b6044820152606401610458565b6000828152600160205260408082206002810154600491820154925162c8a40d60e51b81526001600160a01b038087169592169363191481a0936104f893919201918252602082015260400190565b602060405180830381865afa158015610515573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105399190611d7b565b6001600160a01b03161461058a5760405162461bcd60e51b8152602060048201526018602482015277496e636f727265637420736f6c766572206164647265737360401b6044820152606401610458565b6000828152600160205260408082205490516370a0823160e01b81526101009091046001600160a01b0316919082906370a08231906105cd903090600401611acb565b602060405180830381865afa1580156105ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060e9190611d98565b6000858152600160205260409081902060050154905163a9059cbb60e01b81529192506001600160a01b0384169163a9059cbb9161065191879190600401611db1565b6020604051808303816000875af1158015610670573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106949190611dca565b6106b05760405162461bcd60e51b815260040161045890611dec565b600084815260016020526040908190206006015490516370a0823160e01b81526001600160a01b038416906370a08231906106ef903090600401611acb565b602060405180830381865afa15801561070c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107309190611d98565b61073a9083611e2b565b146107575760405162461bcd60e51b815260040161045890611e42565b50505050565b6000838152600160205260409020600681015460059091015410156107c05760405162461bcd60e51b8152602060048201526019602482015278141c9bdc1bdcd85b081b9bdd08199d5b1b1e48199d5b991959603a1b6044820152606401610458565b60008381526001602052604090205460ff16156107ef5760405162461bcd60e51b815260040161045890611e77565b6000838152600160205260409081902060028101546004918201549251632034967b60e21b81526001600160a01b03909116926380d259ec92610839928892918891889101612355565b600060405180830381600087803b15801561085357600080fd5b505af1158015610867573d6000803e3d6000fd5b5050506000848152600160208190526040808320805460ff1916909217909155518592507f3a5a0357f01e19a1531e65bfe13d63c64c9ae8f03d8c26ae74b1e2929a4f39669190a2505050565b6108bc6117ae565b50600090815260016020818152604092839020835161012081018552815460ff808216151583526001600160a01b036101009283900481168487015295840154861683880152600284015490951660608084019190915260038401546080840152600484015460a0840152600584015460c0840152600684015460e0840152865190810187526007840154815260089093015480861694840194909452928390049093169381019390935281019190915290565b60008381526001602052604081206003015490036109a05760405162461bcd60e51b815260040161045890612375565b60008381526001602052604090205460ff16156109cf5760405162461bcd60e51b815260040161045890611e77565b6000838152600160205260409020546001600160a01b038381166101009092041614610a0d5760405162461bcd60e51b8152600401610458906123a6565b60008111610a2d5760405162461bcd60e51b8152600401610458906123f7565b6000838152600260209081526040808320338452909152902054811115610aa45760405162461bcd60e51b815260206004820152602560248201527f436f6d6d69747465642066756e6473206973206c6f776572207468616e20616d60448201526437bab73a1760d91b6064820152608401610458565b6040516370a0823160e01b81526000906001600160a01b038416906370a0823190610ad3903090600401611acb565b602060405180830381865afa158015610af0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b149190611d98565b905081600160008681526020019081526020016000206005016000828254610b3c9190611e2b565b9091555050600084815260026020908152604080832033845290915281208054849290610b6a908490611e2b565b909155505060405163a9059cbb60e01b81526001600160a01b0384169063a9059cbb90610b9d9033908690600401611db1565b6020604051808303816000875af1158015610bbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610be09190611dca565b610bfc5760405162461bcd60e51b815260040161045890611dec565b6040516370a0823160e01b815282906001600160a01b038516906370a0823190610c2a903090600401611acb565b602060405180830381865afa158015610c47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c6b9190611d98565b610c759083611e2b565b14610cc25760405162461bcd60e51b815260206004820152601e60248201527f4265666f726520616e642061667465722062616c616e63652077726f6e6700006044820152606401610458565b837fe2ab43d60bbb163b7fad7413086cd6c1ee0e0a59a9625e4945a10f1b6a167ff98333604051610cf4929190612426565b60405180910390a250505050565b6000805481908180610d138361243d565b90915550506001600160a01b03861663c4e3983f8580610d34600143611e2b565b6000546040805160208101949094529140918301919091526060820152608001604051602081830303815290604052805190602001206040518363ffffffff1660e01b8152600401610d90929190918252602082015260400190565b6020604051808303816000875af1158015610daf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dd39190611d98565b915081600054604051602001610df3929190918252602082015260400190565b60408051808303601f190181528282528051602091820120600081815260019092529190206003810182905563a2440b9d60e01b835260048301829052602483018590526001600160a01b038a81166044850152919350919088169063a2440b9d90606401600060405180830381600087803b158015610e7257600080fd5b505af1158015610e86573d6000803e3d6000fd5b505082546001600160a01b03808c1661010002610100600160a81b03199092169190911784556001840180546001600160a01b03199081163317909155600285018054928c1692909116919091179055505060048101839055600681018690558360078201610ef58282612456565b505060405182907f2d231481d8c1af3958a30a257e93e0df6b089bc07ebedc0a86e7355d1aaf133890600090a2509550959350505050565b610f35611801565b5060009081526001602090815260409182902082516060810184526007820154815260089091015460ff8082169383019390935261010090049091169181019190915290565b600080876001600160a01b031663fa1a84c78b8b8989896040518663ffffffff1660e01b8152600401610fb295949392919061249a565b600060405180830381600087803b158015610fcc57600080fd5b505af1158015610fe0573d6000803e3d6000fd5b50505050610ff18989898d87610d02565b909b909a5098505050505050505050565b60008281526002602090815260408083203384529091529020546110765760405162461bcd60e51b815260206004820152602560248201527f50726f706f73616c734875623a3a6d73672e73656e64657220686173206e6f20604482015264636c61696d60d81b6064820152608401610458565b600082815260026020908152604080832033845282528083205485845260019092528220600501546110a891906124d4565b60008381526004602090815260408083203384528252808320548784526003835281842087855290925282205492935090916110e59084906124d4565b6110ef9190611e2b565b90506000811161113c5760405162461bcd60e51b8152602060048201526018602482015277050726f706f73616c734875623a3a436c61696d20697320360441b6044820152606401610458565b60008481526003602090815260408083208684529091529020548111156111a55760405162461bcd60e51b815260206004820181905260248201527f50726f706f73616c734875623a3a436c61696d20697320746f6f206c617267656044820152606401610458565b6000838152600460209081526040808320338452909152812080548392906111ce9084906124f6565b925050819055507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f242432a303386858960405160200161121b91815260200190565b6040516020818303038152906040526040518663ffffffff1660e01b815260040161124a95949392919061250e565b600060405180830381600087803b15801561126457600080fd5b505af1158015611278573d6000803e3d6000fd5b5050505050505050565b60008061129183850185611940565b60008181526001602052604090206003015490915081146112c45760405162461bcd60e51b81526004016104589061258d565b60008181526001602052604090205460ff166112f25760405162461bcd60e51b8152600401610458906125d7565b60005b8781101561134a57611338828a8a8481811061131357611313612623565b9050602002013589898581811061132c5761132c612623565b9050602002013561177b565b806113428161243d565b9150506112f5565b5063bc197c8160e01b9a9950505050505050505050565b60008381526001602052604081206003015490036113915760405162461bcd60e51b815260040161045890612375565b60008381526001602052604090205460ff16156113c05760405162461bcd60e51b815260040161045890611e77565b6000838152600160205260409020546001600160a01b0383811661010090920416146113fe5760405162461bcd60e51b8152600401610458906123a6565b6000811161141e5760405162461bcd60e51b8152600401610458906123f7565b6000838152600160205260409020600681015460059091015461144190836124f6565b111561148b5760405162461bcd60e51b815260206004820152601960248201527810d85b89dd08199d5b99081b5bdc99481d1a185b8819dbd85b603a1b6044820152606401610458565b6040516370a0823160e01b81526000906001600160a01b038416906370a08231906114ba903090600401611acb565b602060405180830381865afa1580156114d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114fb9190611d98565b6040516323b872dd60e01b8152336004820152306024820152604481018490529091506001600160a01b038416906323b872dd906064016020604051808303816000875af1158015611551573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115759190611dca565b6115cc5760405162461bcd60e51b815260206004820152602260248201527f436f756c64206e6f74207472616e736665722066726f6d206d73672e73656e6460448201526132b960f11b6064820152608401610458565b8181846001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016115fa9190611acb565b602060405180830381865afa158015611617573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061163b9190611d98565b6116459190611e2b565b146116625760405162461bcd60e51b815260040161045890611e42565b600084815260016020526040812060050180548492906116839084906124f6565b90915550506000848152600260209081526040808320338452909152812080548492906116b19084906124f6565b92505081905550837f82999597cf961179ae8200cb30fa0dcf5559a734cfd867ccd187c5dd6946c4138333604051610cf4929190612426565b6000806116f983850185611940565b600081815260016020526040902060030154909150811461172c5760405162461bcd60e51b81526004016104589061258d565b60008181526001602052604090205460ff1661175a5760405162461bcd60e51b8152600401610458906125d7565b61176581878761177b565b5063f23a6e6160e01b90505b9695505050505050565b6000838152600360209081526040808320858452909152812080548392906117a49084906124f6565b9091555050505050565b6040805161012081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081019190915261010081016117fc611801565b905290565b604080516060810182526000808252602082018190529181019190915290565b60006020828403121561183357600080fd5b81356001600160e01b03198116811461184b57600080fd5b9392505050565b6001600160a01b038116811461186757600080fd5b50565b803561187581611852565b919050565b6000806040838503121561188d57600080fd5b82359150602083013561189f81611852565b809150509250929050565b60008083601f8401126118bc57600080fd5b5081356001600160401b038111156118d357600080fd5b6020830191508360208260051b85010111156118ee57600080fd5b9250929050565b60008060006040848603121561190a57600080fd5b8335925060208401356001600160401b0381111561192757600080fd5b611933868287016118aa565b9497909650939450505050565b60006020828403121561195257600080fd5b5035919050565b6001600160a01b03169052565b8051825260ff602082015116602083015260ff60408201511660408301525050565b89151581526001600160a01b0389811660208301528881166040830152871660608201526080810186905260a0810185905260c0810184905260e0810183905261016081016119db610100830184611966565b9a9950505050505050505050565b8151151581526020808301516001600160a01b031690820152604080830151610160830191611a1a90840182611959565b506060830151611a2d6060840182611959565b506080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151611a6982850182611966565b505092915050565b60008060408385031215611a8457600080fd5b50508035926020909101359150565b600080600060608486031215611aa857600080fd5b833592506020840135611aba81611852565b929592945050506040919091013590565b6001600160a01b0391909116815260200190565b600060608284031215611af157600080fd5b50919050565b600080600080600060e08688031215611b0f57600080fd5b8535611b1a81611852565b94506020860135611b2a81611852565b93506040860135925060608601359150611b478760808801611adf565b90509295509295909350565b606081016103ef8284611966565b600080600080600080600080610160898b031215611b7e57600080fd5b883597506020890135611b9081611852565b96506040890135611ba081611852565b95506060890135945060808901356001600160401b03811115611bc257600080fd5b611bce8b828c016118aa565b9095509350611be290508a60a08b01611adf565b9150611bf28a6101008b01611adf565b90509295985092959890939650565b60008083601f840112611c1357600080fd5b5081356001600160401b03811115611c2a57600080fd5b6020830191508360208285010111156118ee57600080fd5b60008060008060008060008060a0898b031215611c5e57600080fd5b8835611c6981611852565b97506020890135611c7981611852565b965060408901356001600160401b0380821115611c9557600080fd5b611ca18c838d016118aa565b909850965060608b0135915080821115611cba57600080fd5b611cc68c838d016118aa565b909650945060808b0135915080821115611cdf57600080fd5b50611cec8b828c01611c01565b999c989b5096995094979396929594505050565b60008060008060008060a08789031215611d1957600080fd5b8635611d2481611852565b95506020870135611d3481611852565b9450604087013593506060870135925060808701356001600160401b03811115611d5d57600080fd5b611d6989828a01611c01565b979a9699509497509295939492505050565b600060208284031215611d8d57600080fd5b815161184b81611852565b600060208284031215611daa57600080fd5b5051919050565b6001600160a01b03929092168252602082015260400190565b600060208284031215611ddc57600080fd5b8151801515811461184b57600080fd5b6020808252600f908201526e151c985b9cd9995c8819985a5b1959608a1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b600082821015611e3d57611e3d611e15565b500390565b6020808252818101527f496e636f72726563742062616c616e6365206166746572207472616e73666572604082015260600190565b60208082526027908201527f50726f706f73616c734875623a3a50726f706f73616c20616c726561647920656040820152661e1958dd5d195960ca1b606082015260800190565b6000808335601e19843603018112611ed557600080fd5b83016020810192503590506001600160401b03811115611ef457600080fd5b8036038313156118ee57600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000808335601e19843603018112611f4357600080fd5b83016020810192503590506001600160401b03811115611f6257600080fd5b8060051b36038313156118ee57600080fd5b81835260006020808501808196508560051b810191508460005b878110156120185782840389528135609e19883603018112611faf57600080fd5b87018035855260a08682013560048110611fc857600080fd5b8688015260408281013590870152606080830135908701526080611fee81840184611ebe565b935082828901526120028389018583611f03565b9c89019c97505050928601925050600101611f8e565b5091979650505050505050565b6000823560de1983360301811261203b57600080fd5b90910192915050565b81835260006001600160fb1b0383111561205d57600080fd5b8260051b8083602087013760009401602001938452509192915050565b6000808335601e1984360301811261209157600080fd5b83016020810192503590506001600160401b038111156120b057600080fd5b6060810236038313156118ee57600080fd5b60ff8116811461186757600080fd5b8035825260208101356120e3816120c2565b60ff16602083015260408101356120f9816120c2565b60ff81166040840152505050565b81835260208301925060008160005b8481101561213b5761212886836120d1565b6060958601959190910190600101612116565b5093949350505050565b6000813561215281611852565b6001600160a01b031683526020828101358185015260408084013581860152606080850135908601526121886080850185611f2c565b60e0608088015261219d60e088018284612044565b9150506121ad60a0860186611f2c565b87830360a0890152808352848301600582901b84018601836000805b8581101561222857878403601f19018552823536889003603e190181126121ee578283fd5b8701803585526122008b820182611f2c565b91508a8c8701526122148b87018383612044565b968c019695505050918901916001016121c9565b50505061223860c08a018a61207a565b9750955089810360c08b01526119db818888612107565b81835260006020808501808196508560051b810191508460005b878110156120185782840389526122808288612025565b60e0813561228d81611852565b6001600160a01b031686526122a382880161186a565b6122af88880182611959565b5060406122bd81840161186a565b6122c982890182611959565b50506060828101359087015260806122e381840184611ebe565b83838a01526122f5848a018284611f03565b935050505060a061230881840184611f2c565b888403838a015261231a848284611f74565b935050505060c061232d81840184612025565b925086820381880152506123418183612145565b9a87019a9550505090840190600101612269565b84815283602082015260606040820152600061177160608301848661224f565b602080825260179082015276141c9bdc1bdcd85b08191bd95cc81b9bdd08195e1a5cdd604a1b604082015260600190565b60208082526031908201527f50726f706f73616c20646f6573206e6f7420696e636c756465207468697320746040820152701bdad95b881d1bc8189948199d5b991959607a1b606082015260800190565b602080825260159082015274416d6f756e742063616e6e6f74206265207a65726f60581b604082015260600190565b9182526001600160a01b0316602082015260400190565b60006001820161244f5761244f611e15565b5060010190565b8135815560018101602083013561246c816120c2565b8154604085013561247c816120c2565b61ff008160081b1660ff841661ffff19841617178455505050505050565b8581526001600160a01b038516602082015260c0604082018190526000906124c5908301858761224f565b905061177160608301846120d1565b6000826124f157634e487b7160e01b600052601260045260246000fd5b500490565b6000821982111561250957612509611e15565b500190565b600060018060a01b03808816835260208188168185015286604085015285606085015260a06080850152845191508160a085015260005b828110156125615785810182015185820160c001528101612545565b8281111561257357600060c084870101525b5050601f01601f19169190910160c0019695505050505050565b6020808252602a908201527f50726f706f73616c734875623a3a44617461206973206e6f742076616c6964206040820152691c1c9bdc1bdcd85b125960b21b606082015260800190565b6020808252602c908201527f50726f706f73616c734875623a3a50726f706f73616c20686173206e6f74206260408201526b19595b88195e1958dd5d195960a21b606082015260800190565b634e487b7160e01b600052603260045260246000fdfea264697066735822122011f4669f2fd82b339c2b3f19acb6cd81e7232847590806e29bf348180aec2b1464736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createProposal(address,address,uint256,bytes32,(bytes32,uint8,uint8))": {
        "details": "Creates a Proposal from an existing Solution.Base",
        "params": {
          "baseId": "ID of the Solution.Base for which a new instance and proposal is created",
          "collateralToken": "ERC20 token being used as collateral for conditional tokens",
          "fundingGoal": "Amount of ERC20 collateral requested for the Proposal",
          "solutionsHub": "Address of the SolutionsHub contract managing the Solution"
        }
      },
      "defundProposal(bytes32,address,uint256)": {
        "details": "Called by user to remove their funding from a Proposal",
        "params": {
          "amount": "Amount to be defunded",
          "proposalId": "ID of Proposal being defunded",
          "token": "ERC20 token to be defunded"
        }
      },
      "executeIPFSProposal(bytes32,(address,address,address,uint256,bytes,(uint256,uint8,bytes32,uint256,bytes)[],(address,uint256,uint256,bytes32,uint256[],(bytes32,bytes32[])[],(bytes32,uint8,uint8)[]))[])": {
        "details": "Executes a proposal for Solutions where on the *hash* of solver configs is stored on-chain",
        "params": {
          "proposalId": "ID of proposal",
          "solverConfigs": "Configurations of Solvers to be run for the proposed solution"
        }
      },
      "fundProposal(bytes32,address,uint256)": {
        "details": "Called by user to add funding to a Proposal",
        "params": {
          "amount": "Amount to be funded",
          "proposalId": "ID of Proposal being funded",
          "token": "ERC20 token to be funded with"
        }
      },
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
        "details": "Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81, or its own function selector).",
        "params": {
          "data": "Additional data with no specified format",
          "from": "The address which previously owned the token",
          "ids": "An array containing ids of each token being transferred (order and length must match values array)",
          "operator": "The address which initiated the batch transfer (i.e. msg.sender)",
          "values": "An array containing amounts of each token being transferred (order and length must match ids array)"
        },
        "returns": {
          "_0": "`bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed"
        }
      },
      "reclaimTokens(bytes32,uint256)": {
        "details": "Transfers reclaimable CTs to a claimer and lowers their reclaimable balance for that token",
        "params": {
          "proposalId": "ID of proposal being reclaimed from",
          "tokenId": "ERC1155 token being reclaimed"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "transferERC20(bytes32,address)": {
        "details": "Called by SolutionsHub after deploying Solvers",
        "params": {
          "proposalId": "Proposal that collateral is being transferred from",
          "solver": "Solver receiving collateral"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "onERC1155Received(address,address,uint256,uint256,bytes)": {
        "notice": "IMPORTANT! Any CTs sent to this contract are reclaimable by the funders in proportion to their funding. If a user reclaims CTs and sends them back again to this contract, they will only be able to  regain from them a fraction of their original funding."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7573,
        "contract": "contracts/ProposalsHub.sol:ProposalsHub",
        "label": "nonce",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 7599,
        "contract": "contracts/ProposalsHub.sol:ProposalsHub",
        "label": "proposals",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_struct(Proposal)7594_storage)"
      },
      {
        "astId": 7605,
        "contract": "contracts/ProposalsHub.sol:ProposalsHub",
        "label": "funderAmountMap",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 7611,
        "contract": "contracts/ProposalsHub.sol:ProposalsHub",
        "label": "reclaimableTokens",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_bytes32,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 7617,
        "contract": "contracts/ProposalsHub.sol:ProposalsHub",
        "label": "reclaimedTokens",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_uint256))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IERC20)2691": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_bytes32,t_struct(Proposal)7594_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct ProposalsHub.Proposal)",
        "numberOfBytes": "32",
        "value": "t_struct(Proposal)7594_storage"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Multihash)10193_storage": {
        "encoding": "inplace",
        "label": "struct SolverLib.Multihash",
        "members": [
          {
            "astId": 10188,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "digest",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 10190,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "hashFunction",
            "offset": 0,
            "slot": "1",
            "type": "t_uint8"
          },
          {
            "astId": 10192,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "size",
            "offset": 1,
            "slot": "1",
            "type": "t_uint8"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Proposal)7594_storage": {
        "encoding": "inplace",
        "label": "struct ProposalsHub.Proposal",
        "members": [
          {
            "astId": 7575,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "isExecuted",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 7578,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "collateralToken",
            "offset": 1,
            "slot": "0",
            "type": "t_contract(IERC20)2691"
          },
          {
            "astId": 7580,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "proposer",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 7582,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "solutionsHub",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 7584,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "id",
            "offset": 0,
            "slot": "3",
            "type": "t_bytes32"
          },
          {
            "astId": 7586,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "solutionId",
            "offset": 0,
            "slot": "4",
            "type": "t_bytes32"
          },
          {
            "astId": 7588,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "funding",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 7590,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "fundingGoal",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 7593,
            "contract": "contracts/ProposalsHub.sol:ProposalsHub",
            "label": "metadataCID",
            "offset": 0,
            "slot": "7",
            "type": "t_struct(Multihash)10193_storage"
          }
        ],
        "numberOfBytes": "288"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}