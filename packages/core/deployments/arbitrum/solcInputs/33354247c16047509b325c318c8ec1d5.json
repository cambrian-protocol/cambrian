{
  "language": "Solidity",
  "sources": {
    "contracts/arbitration/ArbitrationDispatch.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.14;\r\n\r\nimport \"../interfaces/ISolver.sol\";\r\n\r\ncontract ArbitrationDispatch {\r\n    bool internal locked;\r\n    modifier reentrancyGuard() {\r\n        require(!locked, \"reentrancyGuard\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    event RequestedArbitration(\r\n        address indexed solver,\r\n        address indexed arbitrator,\r\n        address requester,\r\n        uint256 conditionIndex,\r\n        uint256 value,\r\n        bytes retData\r\n    );\r\n\r\n    /**\r\n     * @notice Atomically forwards ETH (may be zero) to arbitrator address.\r\n     * @dev Untrusted\r\n     * @param solver Address of solver\r\n     * @param conditionIndex Index of condition for which arbitration is being requested\r\n     */\r\n    function requestArbitration(ISolver solver, uint256 conditionIndex)\r\n        external\r\n        payable\r\n        reentrancyGuard\r\n    {\r\n        address _arbitrator = solver.arbitrator();\r\n        require(_arbitrator != address(0), \"Arbitrator can't be zero address\");\r\n\r\n        SolverLib.Condition memory condition = solver.condition(conditionIndex);\r\n\r\n        require(\r\n            condition.status == SolverLib.Status.OutcomeProposed ||\r\n                condition.status == SolverLib.Status.ArbitrationRequested,\r\n            \"Condition status invalid for arbitration\"\r\n        );\r\n\r\n        (bool success, bytes memory retData) = _arbitrator.call{\r\n            value: msg.value\r\n        }(abi.encode(address(solver), conditionIndex, msg.sender));\r\n\r\n        require(success, \"Arbitrator reverted\");\r\n\r\n        emit RequestedArbitration(\r\n            address(solver),\r\n            _arbitrator,\r\n            msg.sender,\r\n            conditionIndex,\r\n            msg.value,\r\n            retData\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ISolver.sol": {
      "content": "pragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../conditionalTokens/ConditionalTokens.sol\";\r\nimport \"../solvers/Solver.sol\";\r\nimport \"../solvers/SolverLib.sol\";\r\n\r\ninterface ISolver {\r\n    /**\r\n        @notice Called by SolverFactory when contract is created. Nothing else should ever need to call this\r\n        @dev initializer\r\n        @param _chainParent The address of the Solver above this one in the chain. address(0) if this Solver is first.\r\n        @param _chainIndex The index of this Solver in the chain\r\n        @param _solverConfig The configuration of this Solver\r\n    */\r\n    function init(\r\n        address _deployer,\r\n        address _ctfAddress,\r\n        address _chainParent,\r\n        uint256 _chainIndex,\r\n        SolverLib.Config calldata _solverConfig\r\n    ) external;\r\n\r\n    /**\r\n        @notice Creates a new condition, associated timelock, and executes ingests for this Solver and any child Solvers\r\n        @param _index Index of the new condition to be created.\r\n    */\r\n    function prepareSolve(uint256 _index) external;\r\n\r\n    /**\r\n        @notice Deploys a new Solver as a child\r\n        @param _config Configuration of the child Solver\r\n        @return address\r\n    */\r\n    function deployChild(SolverLib.Config calldata _config)\r\n        external\r\n        returns (address);\r\n\r\n    /**\r\n        @notice Mints conditional tokens, allocates them to recipients specified by ingested data, runs arbitrary `postroll()` function and tries to do the same for child Solver\r\n        @dev require(ingestsValid())\r\n        @param _index Index of condition to execute on\r\n     */\r\n    function executeSolve(uint256 _index) external;\r\n\r\n    /**\r\n        @notice Verifies that all ingests have been performed for a condition\r\n        @return bool\r\n     */\r\n    function ingestsValid() external view returns (bool);\r\n\r\n    /**\r\n        @notice Verifies that all slots corresponding to recipients have been filled before CT allocation\r\n        @param _index Condition index\r\n        @return bool\r\n     */\r\n    function allocationsValid(uint256 _index) external view returns (bool);\r\n\r\n    /**\r\n        @notice Allows keeper to manually add data to IngestType.Manual slots after executeIngests\r\n        @dev Only Keeper, only manual slots\r\n        @param _slot Destination slot\r\n        @param _data Data to be added\r\n     */\r\n    function addData(bytes32 _slot, bytes memory _data) external;\r\n\r\n    /**\r\n        @notice Get most recent data of a slot\r\n        @param _slot slotId\r\n        @return data\r\n     */\r\n    function getData(bytes32 _slot) external view returns (bytes memory data);\r\n\r\n    /**\r\n        @notice Get data for each condition from a slot\r\n        @param _slot slotId\r\n        @return data\r\n     */\r\n    function getAllData(bytes32 _slot)\r\n        external\r\n        view\r\n        returns (bytes[] memory data);\r\n\r\n    /**\r\n        @notice Register callback expected by a downstream Solver for some data\r\n        @dev only downstream Solver\r\n        @param _slot Slot being waited on by downstream Solver\r\n        @param _chainIndex Index of the Solver requesting this callback\r\n     */\r\n    function registerOutgoingCallback(bytes32 _slot, uint256 _chainIndex)\r\n        external;\r\n\r\n    /**\r\n        @notice Handle upstream Solver making callback and ingest the data\r\n        @dev only upstream Solver\r\n        @param _slot Destination slot for the data being sent\r\n     */\r\n    function handleCallback(bytes32 _slot) external;\r\n\r\n    /**\r\n        @notice A simple getter that requires upstream slot ver. == our condition ver.\r\n        @param _slot Slot containing data\r\n        @return data\r\n     */\r\n    function getCallbackOutput(bytes32 _slot)\r\n        external\r\n        view\r\n        returns (bytes memory data);\r\n\r\n    /**\r\n        @notice Propose payouts (AKA outcomes) for a condition\r\n        @param _index Index of condition\r\n        @param _payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\r\n     */\r\n    function proposePayouts(uint256 _index, uint256[] calldata _payouts)\r\n        external;\r\n\r\n    /**\r\n        @notice Confirm payouts for condition (reportPayouts to ConditionalTokens contract)\r\n        @param _index Index of condition\r\n     */\r\n    function confirmPayouts(uint256 _index) external;\r\n\r\n    /**\r\n        @notice Sets condition.status to ArbitrationRequested.\r\n        @param _index Index of condition\r\n     */\r\n    function requestArbitration(uint256 _index) external;\r\n\r\n    /**\r\n        @notice Allows arbitrator to unilaterally make a payout report.\r\n        @param _index Index of condition\r\n        @param payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\r\n     */\r\n    function arbitrate(uint256 _index, uint256[] memory payouts) external;\r\n\r\n    /**\r\n        @notice Returns condition.status to OutcomeProposed without a ruling.\r\n        @param _index Index of condition\r\n     */\r\n    function arbitrateNull(uint256 _index) external;\r\n\r\n    /**\r\n        @notice Get address for a Solver by its index in the chain\r\n        @param _index Index of Solver\r\n        @return _address\r\n     */\r\n    function addressFromChainIndex(uint256 _index)\r\n        external\r\n        view\r\n        returns (address _address);\r\n\r\n    /**\r\n        @notice Get condition\r\n        @param index Index of condition\r\n     */\r\n    function condition(uint256 index)\r\n        external\r\n        view\r\n        returns (SolverLib.Condition memory);\r\n\r\n    function getConditions()\r\n        external\r\n        view\r\n        returns (SolverLib.Condition[] memory);\r\n\r\n    /**\r\n        @notice Get Solver config\r\n     */\r\n    function getConfig() external view returns (SolverLib.Config memory);\r\n\r\n    /**\r\n        @notice Get Keeper address \r\n    */\r\n    function keeper() external view returns (address);\r\n\r\n    /**\r\n        @notice Get Arbitrator address \r\n    */\r\n    function arbitrator() external view returns (address);\r\n\r\n    /**\r\n        @notice set ID that will be passed as data for conditional token transfers\r\n        @param _trackingId bytes32\r\n    */\r\n    function setTrackingId(bytes32 _trackingId) external;\r\n\r\n    function trackingId() external returns (bytes32 trackingId);\r\n\r\n    /**\r\n        @notice Get balance of collateral token on Solver\r\n        @return balance\r\n    */\r\n    function collateralBalance() external view returns (uint256 balance);\r\n\r\n    /**\r\n        @notice Basic getter\r\n     */\r\n    function timelocks(uint256 conditionIndex)\r\n        external\r\n        view\r\n        returns (uint256 timelock);\r\n\r\n    /**\r\n        @notice Returns recipient addresses for a condition\r\n        @param account address to check\r\n        @param conditionIndex condition to check\r\n        @return bool\r\n     */\r\n    function isRecipient(address account, uint256 conditionIndex)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n        @notice Get status of a condition\r\n        @param conditionIndex index of condition\r\n        @return status\r\n     */\r\n    function getStatus(uint256 conditionIndex)\r\n        external\r\n        view\r\n        returns (SolverLib.Status status);\r\n\r\n    function setTimelock(uint256 _index, uint256 _date) external;\r\n\r\n    /**\r\n        @notice Redeems CTs held by this Solver. See ConditionalTokens contract for more info.\r\n        @dev only Keeper\r\n     */\r\n    function redeemPosition(\r\n        IERC20 _collateralToken,\r\n        bytes32 _parentCollectionId,\r\n        bytes32 _conditionId,\r\n        uint256[] calldata _indexSets\r\n    ) external;\r\n\r\n    function hasRole(bytes32 role, address account)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function setState(bytes32 key, bytes calldata data) external;\r\n\r\n    function getState(bytes32 key) external view returns (bytes memory data);\r\n\r\n    function ctfAddress() external view returns (address);\r\n}\r\n"
    },
    "contracts/conditionalTokens/ConditionalTokens.sol": {
      "content": "/** \r\n    SPDX-License-Identifier: LGPL-3.0\r\n    Copied from Gnosis\r\n    Updated for Solidity 0.8.0\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\n\r\nimport {CTHelpers} from \"./CTHelpers.sol\";\r\n\r\n// Mainnet (ID: 1) canonical address: 0xC59b0e4De5F1248C1140964E0fF287B192407E0C\r\n// Rinkeby (ID: 4) canonical address: 0x36bede640D19981A82090519bC1626249984c908\r\n\r\ncontract ConditionalTokens is ERC1155 {\r\n    /// @dev Emitted upon the successful preparation of a condition.\r\n    /// @param conditionId The condition's ID. This ID may be derived from the other three parameters via ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``.\r\n    /// @param oracle The account assigned to report the result for the prepared condition.\r\n    /// @param questionId An identifier for the question to be answered by the oracle.\r\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\r\n    event ConditionPreparation(\r\n        bytes32 indexed conditionId,\r\n        address indexed oracle,\r\n        bytes32 indexed questionId,\r\n        uint256 outcomeSlotCount\r\n    );\r\n\r\n    event ConditionResolution(\r\n        bytes32 indexed conditionId,\r\n        address indexed oracle,\r\n        bytes32 indexed questionId,\r\n        uint256 outcomeSlotCount,\r\n        uint256[] payoutNumerators\r\n    );\r\n\r\n    /// @dev Emitted when a position is successfully split.\r\n    event PositionSplit(\r\n        address indexed stakeholder,\r\n        IERC20 collateralToken,\r\n        bytes32 indexed parentCollectionId,\r\n        bytes32 indexed conditionId,\r\n        uint256[] partition,\r\n        uint256 amount\r\n    );\r\n    /// @dev Emitted when positions are successfully merged.\r\n    event PositionsMerge(\r\n        address indexed stakeholder,\r\n        IERC20 collateralToken,\r\n        bytes32 indexed parentCollectionId,\r\n        bytes32 indexed conditionId,\r\n        uint256[] partition,\r\n        uint256 amount\r\n    );\r\n    event PayoutRedemption(\r\n        address indexed redeemer,\r\n        IERC20 indexed collateralToken,\r\n        bytes32 indexed parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256[] indexSets,\r\n        uint256 payout\r\n    );\r\n\r\n    /// Mapping key is an condition ID. Value represents numerators of the payout vector associated with the condition. This array is initialized with a length equal to the outcome slot count. E.g. Condition with 3 outcomes [A, B, C] and two of those correct [0.5, 0.5, 0]. In Ethereum there are no decimal values, so here, 0.5 is represented by fractions like 1/2 == 0.5. That's why we need numerator and denominator values. Payout numerators are also used as a check of initialization. If the numerators array is empty (has length zero), the condition was not created/prepared. See getOutcomeSlotCount.\r\n    mapping(bytes32 => uint256[]) public payoutNumerators;\r\n    /// Denominator is also used for checking if the condition has been resolved. If the denominator is non-zero, then the condition has been resolved.\r\n    mapping(bytes32 => uint256) public payoutDenominator;\r\n\r\n    constructor() ERC1155(\"\") {}\r\n\r\n    /// @dev This function prepares a condition by initializing a payout vector associated with the condition.\r\n    /// @param oracle The account assigned to report the result for the prepared condition.\r\n    /// @param questionId An identifier for the question to be answered by the oracle.\r\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\r\n    function prepareCondition(\r\n        address oracle,\r\n        bytes32 questionId,\r\n        uint256 outcomeSlotCount\r\n    ) external {\r\n        // Limit of 256 because we use a partition array that is a number of 256 bits.\r\n        require(outcomeSlotCount <= 256, \"too many outcome slots\");\r\n        require(\r\n            outcomeSlotCount > 1,\r\n            \"there should be more than one outcome slot\"\r\n        );\r\n        bytes32 conditionId = CTHelpers.getConditionId(\r\n            oracle,\r\n            questionId,\r\n            outcomeSlotCount\r\n        );\r\n        require(\r\n            payoutNumerators[conditionId].length == 0,\r\n            \"condition already prepared\"\r\n        );\r\n        payoutNumerators[conditionId] = new uint256[](outcomeSlotCount);\r\n        emit ConditionPreparation(\r\n            conditionId,\r\n            oracle,\r\n            questionId,\r\n            outcomeSlotCount\r\n        );\r\n    }\r\n\r\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``, where oracle is the message sender, questionId is one of the parameters of this function, and outcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.\r\n    /// @param questionId The question ID the oracle is answering for\r\n    /// @param payouts The oracle's answer\r\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts)\r\n        external\r\n    {\r\n        uint256 outcomeSlotCount = payouts.length;\r\n        require(\r\n            outcomeSlotCount > 1,\r\n            \"there should be more than one outcome slot\"\r\n        );\r\n        // IMPORTANT, the oracle is enforced to be the sender because it's part of the hash.\r\n        bytes32 conditionId = CTHelpers.getConditionId(\r\n            msg.sender,\r\n            questionId,\r\n            outcomeSlotCount\r\n        );\r\n        require(\r\n            payoutNumerators[conditionId].length == outcomeSlotCount,\r\n            \"condition not prepared or found\"\r\n        );\r\n        require(\r\n            payoutDenominator[conditionId] == 0,\r\n            \"payout denominator already set\"\r\n        );\r\n\r\n        uint256 den = 0;\r\n        for (uint256 i = 0; i < outcomeSlotCount; i++) {\r\n            uint256 num = payouts[i];\r\n            den = den + num;\r\n\r\n            require(\r\n                payoutNumerators[conditionId][i] == 0,\r\n                \"payout numerator already set\"\r\n            );\r\n            payoutNumerators[conditionId][i] = num;\r\n        }\r\n        require(den > 0, \"payout is all zeroes\");\r\n        payoutDenominator[conditionId] = den;\r\n        emit ConditionResolution(\r\n            conditionId,\r\n            msg.sender,\r\n            questionId,\r\n            outcomeSlotCount,\r\n            payoutNumerators[conditionId]\r\n        );\r\n    }\r\n\r\n    /// @dev This function splits a position. If splitting from the collateral, this contract will attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this contract will burn `amount` stake held by the message sender in the position being split worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the split target positions. If any of the transfers, mints, or burns fail, the transaction will revert. The transaction will also revert if the given partition is trivial, invalid, or refers to more slots than the condition is prepared with.\r\n    /// @param collateralToken The address of the positions' backing collateral token.\r\n    /// @param parentCollectionId The ID of the outcome collections common to the position being split and the split target positions. May be null, in which only the collateral is shared.\r\n    /// @param conditionId The ID of the condition to split on.\r\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint). Each element's a number which, together with the condition, represents the outcome collection. E.g. 0b110 is A|B, 0b010 is B, etc.\r\n    /// @param amount The amount of collateral or stake to split.\r\n    function splitPosition(\r\n        IERC20 collateralToken,\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256[] calldata partition,\r\n        uint256 amount\r\n    ) external {\r\n        require(partition.length > 1, \"got empty or singleton partition\");\r\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\r\n        require(outcomeSlotCount > 0, \"condition not prepared yet\");\r\n\r\n        // For a condition with 4 outcomes fullIndexSet's 0b1111; for 5 it's 0b11111...\r\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\r\n        // freeIndexSet starts as the full collection\r\n        uint256 freeIndexSet = fullIndexSet;\r\n        // This loop checks that all condition sets are disjoint (the same outcome is not part of more than 1 set)\r\n        uint256[] memory positionIds = new uint256[](partition.length);\r\n        uint256[] memory amounts = new uint256[](partition.length);\r\n        for (uint256 i = 0; i < partition.length; i++) {\r\n            uint256 indexSet = partition[i];\r\n            require(\r\n                indexSet > 0 && indexSet < fullIndexSet,\r\n                \"got invalid index set\"\r\n            );\r\n            require(\r\n                (indexSet & freeIndexSet) == indexSet,\r\n                \"partition not disjoint\"\r\n            );\r\n            freeIndexSet ^= indexSet;\r\n            positionIds[i] = CTHelpers.getPositionId(\r\n                collateralToken,\r\n                CTHelpers.getCollectionId(\r\n                    parentCollectionId,\r\n                    conditionId,\r\n                    indexSet\r\n                )\r\n            );\r\n            amounts[i] = amount;\r\n        }\r\n\r\n        if (freeIndexSet == 0) {\r\n            // Partitioning the full set of outcomes for the condition in this branch\r\n            if (parentCollectionId == bytes32(0)) {\r\n                require(\r\n                    collateralToken.transferFrom(\r\n                        msg.sender,\r\n                        address(this),\r\n                        amount\r\n                    ),\r\n                    \"could not receive collateral tokens\"\r\n                );\r\n            } else {\r\n                _burn(\r\n                    msg.sender,\r\n                    CTHelpers.getPositionId(\r\n                        collateralToken,\r\n                        parentCollectionId\r\n                    ),\r\n                    amount\r\n                );\r\n            }\r\n        } else {\r\n            // Partitioning a subset of outcomes for the condition in this branch.\r\n            // For example, for a condition with three outcomes A, B, and C, this branch\r\n            // allows the splitting of a position $:(A|C) to positions $:(A) and $:(C).\r\n            _burn(\r\n                msg.sender,\r\n                CTHelpers.getPositionId(\r\n                    collateralToken,\r\n                    CTHelpers.getCollectionId(\r\n                        parentCollectionId,\r\n                        conditionId,\r\n                        fullIndexSet ^ freeIndexSet\r\n                    )\r\n                ),\r\n                amount\r\n            );\r\n        }\r\n\r\n        _mintBatch(\r\n            msg.sender,\r\n            // position ID is the ERC 1155 token ID\r\n            positionIds,\r\n            amounts,\r\n            \"\"\r\n        );\r\n        emit PositionSplit(\r\n            msg.sender,\r\n            collateralToken,\r\n            parentCollectionId,\r\n            conditionId,\r\n            partition,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function mergePositions(\r\n        IERC20 collateralToken,\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256[] calldata partition,\r\n        uint256 amount\r\n    ) external {\r\n        require(partition.length > 1, \"got empty or singleton partition\");\r\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\r\n        require(outcomeSlotCount > 0, \"condition not prepared yet\");\r\n\r\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\r\n        uint256 freeIndexSet = fullIndexSet;\r\n        uint256[] memory positionIds = new uint256[](partition.length);\r\n        uint256[] memory amounts = new uint256[](partition.length);\r\n        for (uint256 i = 0; i < partition.length; i++) {\r\n            uint256 indexSet = partition[i];\r\n            require(\r\n                indexSet > 0 && indexSet < fullIndexSet,\r\n                \"got invalid index set\"\r\n            );\r\n            require(\r\n                (indexSet & freeIndexSet) == indexSet,\r\n                \"partition not disjoint\"\r\n            );\r\n            freeIndexSet ^= indexSet;\r\n            positionIds[i] = CTHelpers.getPositionId(\r\n                collateralToken,\r\n                CTHelpers.getCollectionId(\r\n                    parentCollectionId,\r\n                    conditionId,\r\n                    indexSet\r\n                )\r\n            );\r\n            amounts[i] = amount;\r\n        }\r\n        _burnBatch(msg.sender, positionIds, amounts);\r\n\r\n        if (freeIndexSet == 0) {\r\n            if (parentCollectionId == bytes32(0)) {\r\n                require(\r\n                    collateralToken.transfer(msg.sender, amount),\r\n                    \"could not send collateral tokens\"\r\n                );\r\n            } else {\r\n                _mint(\r\n                    msg.sender,\r\n                    CTHelpers.getPositionId(\r\n                        collateralToken,\r\n                        parentCollectionId\r\n                    ),\r\n                    amount,\r\n                    \"\"\r\n                );\r\n            }\r\n        } else {\r\n            _mint(\r\n                msg.sender,\r\n                CTHelpers.getPositionId(\r\n                    collateralToken,\r\n                    CTHelpers.getCollectionId(\r\n                        parentCollectionId,\r\n                        conditionId,\r\n                        fullIndexSet ^ freeIndexSet\r\n                    )\r\n                ),\r\n                amount,\r\n                \"\"\r\n            );\r\n        }\r\n\r\n        emit PositionsMerge(\r\n            msg.sender,\r\n            collateralToken,\r\n            parentCollectionId,\r\n            conditionId,\r\n            partition,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function redeemPositions(\r\n        IERC20 collateralToken,\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256[] calldata indexSets\r\n    ) external {\r\n        uint256 den = payoutDenominator[conditionId];\r\n        require(den > 0, \"result for condition not received yet\");\r\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\r\n        require(outcomeSlotCount > 0, \"condition not prepared yet\");\r\n\r\n        uint256 totalPayout = 0;\r\n\r\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\r\n        for (uint256 i = 0; i < indexSets.length; i++) {\r\n            uint256 indexSet = indexSets[i];\r\n            require(\r\n                indexSet > 0 && indexSet < fullIndexSet,\r\n                \"got invalid index set\"\r\n            );\r\n            uint256 positionId = CTHelpers.getPositionId(\r\n                collateralToken,\r\n                CTHelpers.getCollectionId(\r\n                    parentCollectionId,\r\n                    conditionId,\r\n                    indexSet\r\n                )\r\n            );\r\n\r\n            uint256 payoutNumerator = 0;\r\n            for (uint256 j = 0; j < outcomeSlotCount; j++) {\r\n                if (indexSet & (1 << j) != 0) {\r\n                    payoutNumerator =\r\n                        payoutNumerator +\r\n                        payoutNumerators[conditionId][j];\r\n                }\r\n            }\r\n\r\n            uint256 payoutStake = balanceOf(msg.sender, positionId);\r\n\r\n            if (payoutStake > 0) {\r\n                totalPayout =\r\n                    totalPayout +\r\n                    ((payoutStake * payoutNumerator) / den);\r\n                _burn(msg.sender, positionId, payoutStake);\r\n            }\r\n        }\r\n\r\n        if (totalPayout > 0) {\r\n            if (parentCollectionId == bytes32(0)) {\r\n                require(\r\n                    collateralToken.transfer(msg.sender, totalPayout),\r\n                    \"could not transfer payout to message sender\"\r\n                );\r\n            } else {\r\n                _mint(\r\n                    msg.sender,\r\n                    CTHelpers.getPositionId(\r\n                        collateralToken,\r\n                        parentCollectionId\r\n                    ),\r\n                    totalPayout,\r\n                    \"\"\r\n                );\r\n            }\r\n        }\r\n        emit PayoutRedemption(\r\n            msg.sender,\r\n            collateralToken,\r\n            parentCollectionId,\r\n            conditionId,\r\n            indexSets,\r\n            totalPayout\r\n        );\r\n    }\r\n\r\n    /// @dev Gets the outcome slot count of a condition.\r\n    /// @param conditionId ID of the condition.\r\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not been prepared yet.\r\n    function getOutcomeSlotCount(bytes32 conditionId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return payoutNumerators[conditionId].length;\r\n    }\r\n\r\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\r\n    /// @param oracle The account assigned to report the result for the prepared condition.\r\n    /// @param questionId An identifier for the question to be answered by the oracle.\r\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\r\n    function getConditionId(\r\n        address oracle,\r\n        bytes32 questionId,\r\n        uint256 outcomeSlotCount\r\n    ) external pure returns (bytes32) {\r\n        return CTHelpers.getConditionId(oracle, questionId, outcomeSlotCount);\r\n    }\r\n\r\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\r\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\r\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\r\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\r\n    function getCollectionId(\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256 indexSet\r\n    ) external view returns (bytes32) {\r\n        return\r\n            CTHelpers.getCollectionId(\r\n                parentCollectionId,\r\n                conditionId,\r\n                indexSet\r\n            );\r\n    }\r\n\r\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\r\n    /// @param collateralToken Collateral token which backs the position.\r\n    /// @param collectionId ID of the outcome collection associated with this position.\r\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\r\n        external\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return CTHelpers.getPositionId(collateralToken, collectionId);\r\n    }\r\n}\r\n"
    },
    "contracts/solvers/Solver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\nimport \"../interfaces/IConditionalTokens.sol\";\r\nimport \"../interfaces/ISolverFactory.sol\";\r\nimport \"../interfaces/ISolver.sol\";\r\nimport \"../interfaces/IModule.sol\";\r\n\r\nimport \"./SolverLib.sol\";\r\n\r\nimport \"../modules/Modulated.sol\";\r\n\r\nabstract contract Solver is Modulated, Initializable, ERC1155Receiver {\r\n    using SafeERC20 for IERC20;\r\n\r\n    ISolverFactory public solverFactory; // Factory which creates Solver proxies\r\n    address public deployerAddress; // Address which called SolverFactory to deploy this Solver\r\n\r\n    SolverLib.Config public config; // Primary config of the Solver\r\n    SolverLib.Condition[] public conditions; // Array of conditions\r\n\r\n    address public chainParent; // Parent solver\r\n    address public chainChild; // Child solver\r\n    uint256 public chainIndex; // This Solver's index in chain\r\n\r\n    uint256[] public timelocks; // Current timelock, indexed by condition\r\n    bytes32 public trackingId; // Settable for adding some higher-level trackingId (eg. id of a proposal this solver belongs to)\r\n\r\n    SolverLib.Callbacks callbacks;\r\n    SolverLib.Datas datas;\r\n\r\n    event ChangedStatus(bytes32 conditionId);\r\n\r\n    event DeployedChild(address child);\r\n\r\n    event DeliveredNullArbitration(bytes32 conditionId);\r\n\r\n    event IngestedData(); // Emited on executeIngests(), handleCallback(), addData()\r\n\r\n    event PreparedSolve(address solver, uint256 solveIndex);\r\n\r\n    // Recommended disabling of initializer for the implementation. Not called by clones\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    /**\r\n        @notice Called by SolverFactory when contract is created. Nothing else should ever need to call this\r\n        @dev initializer\r\n        @param _chainParent The address of the Solver above this one in the chain. address(0) if this Solver is first.\r\n        @param _chainIndex The index of this Solver in the chain\r\n        @param _solverConfig The configuration of this Solver\r\n    */\r\n    function init(\r\n        address _deployer,\r\n        address _chainParent,\r\n        uint256 _chainIndex,\r\n        SolverLib.Config calldata _solverConfig\r\n    ) external initializer {\r\n        require(_solverConfig.keeper != address(0), \"Keeper invalid\");\r\n        deployerAddress = _deployer;\r\n        solverFactory = ISolverFactory(msg.sender);\r\n        chainParent = _chainParent;\r\n        chainIndex = _chainIndex;\r\n        config = _solverConfig;\r\n\r\n        for (uint256 i = 0; i < _solverConfig.ingests.length; i++) {\r\n            datas.slotIngestIdx[_solverConfig.ingests[i].slot] = i;\r\n        }\r\n\r\n        loadModules(_solverConfig.moduleLoaders);\r\n    }\r\n\r\n    // ********************************************************************************** //\r\n    // ********************************** SETUP ***************************************** //\r\n    // ********************************************************************************** //\r\n\r\n    /**\r\n        @notice Creates a new condition, associated timelock, and executes ingests for this Solver and any child Solvers\r\n        @param _index Index of the new condition to be created.\r\n    */\r\n    function prepareSolve(uint256 _index) external {\r\n        if (conditions.length > 0) {\r\n            require(\r\n                msg.sender == config.keeper ||\r\n                    msg.sender == chainParent ||\r\n                    isPermittedModule(this.prepareSolve.selector),\r\n                \"Not permitted\"\r\n            );\r\n        }\r\n\r\n        require(_index == conditions.length, \"Invalid index\");\r\n        require(callbacks.numOutgoing == 0, \"outgoing cbs\");\r\n        require(callbacks.numIncoming == 0, \"incoming cbs\");\r\n\r\n        conditions.push(\r\n            SolverLib.createCondition(\r\n                solverFactory.ctf(),\r\n                config.conditionBase,\r\n                chainParent,\r\n                conditions.length\r\n            )\r\n        );\r\n        timelocks.push(0);\r\n\r\n        executeIngests();\r\n\r\n        emit PreparedSolve(address(this), _index);\r\n\r\n        if (chainChild != address(0)) {\r\n            ISolver(chainChild).prepareSolve(_index);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Deploys a new Solver as a child\r\n        @param _config Configuration of the child Solver\r\n        @return address\r\n    */\r\n    function deployChild(SolverLib.Config calldata _config)\r\n        public\r\n        returns (address)\r\n    {\r\n        require(\r\n            msg.sender == config.keeper ||\r\n                isPermittedModule(this.deployChild.selector),\r\n            \"Only keeper\"\r\n        );\r\n        require(chainChild == address(0), \"Has child\");\r\n\r\n        chainChild = SolverLib.deployChild(\r\n            solverFactory,\r\n            _config,\r\n            chainIndex,\r\n            trackingId\r\n        );\r\n\r\n        return chainChild;\r\n    }\r\n\r\n    // ********************************************************************************** //\r\n    // ****************************** EXECUTION ***************************************** //\r\n    // ********************************************************************************** //\r\n\r\n    /**\r\n        @notice Mints conditional tokens, allocates them to recipients specified by ingested data and tries to do the same for child Solver\r\n        @dev require(ingestsValid())\r\n        @param _index Index of condition to execute on\r\n     */\r\n    function executeSolve(uint256 _index) public {\r\n        require(ingestsValid() == true, \"ingests invalid\");\r\n\r\n        SolverLib.executeSolve(\r\n            _index,\r\n            solverFactory.ctf(),\r\n            solverFactory.erc1155Rescue(),\r\n            conditions[_index],\r\n            config.conditionBase,\r\n            datas,\r\n            trackingId,\r\n            chainParent,\r\n            abi.decode(\r\n                datas.slots[config.conditionBase.amountSlot][_index],\r\n                (uint256)\r\n            )\r\n        );\r\n\r\n        cascade(_index);\r\n    }\r\n\r\n    function cascade(uint256 _index) internal {\r\n        if (\r\n            chainChild != address(0) &&\r\n            ISolver(chainChild).ingestsValid() &&\r\n            ISolver(chainChild).allocationsValid(_index)\r\n        ) {\r\n            ISolver(chainChild).executeSolve(_index);\r\n        }\r\n    }\r\n\r\n    // ********************************************************************************** //\r\n    // ********************************** DATA ****************************************** //\r\n    // ********************************************************************************** //\r\n\r\n    /**\r\n        @dev Adds data to slot (if valid ver.) and executes any callbacks for this slot\r\n        @param _slot Destination slot\r\n        @param _data Data added to slot\r\n     */\r\n    function router(bytes32 _slot, bytes memory _data) private {\r\n        require(\r\n            datas.slots[_slot].length == (conditions.length - 1),\r\n            \"Slot version invalid\"\r\n        );\r\n        datas.slots[_slot].push(_data);\r\n\r\n        callback(_slot);\r\n    }\r\n\r\n    /**\r\n        @dev Executes ingests from config. Registers callbacks for ingests which wait for upstream solver data\r\n     */\r\n    function executeIngests() private {\r\n        for (uint256 i; i < config.ingests.length; i++) {\r\n            if (config.ingests[i].ingestType != SolverLib.IngestType.Callback) {\r\n                ingest(config.ingests[i]);\r\n            } else {\r\n                address _cbSolver = ISolver(address(this))\r\n                    .addressFromChainIndex(config.ingests[i].solverIndex);\r\n                registerIncomingCallback(_cbSolver, i);\r\n                ISolver(_cbSolver).registerOutgoingCallback(\r\n                    abi.decode(config.ingests[i].data, (bytes32)),\r\n                    chainIndex\r\n                );\r\n            }\r\n        }\r\n        emit IngestedData();\r\n    }\r\n\r\n    function ingest(SolverLib.Ingest storage _ingest) private {\r\n        require(uint256(_ingest.ingestType) <= 3, \"Invalid ingestType\");\r\n        _ingest.executions++;\r\n\r\n        if (_ingest.ingestType != SolverLib.IngestType.Manual) {\r\n            router(_ingest.slot, SolverLib.ingest(_ingest));\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Verifies that all ingests have been performed for a condition\r\n        @return bool\r\n     */\r\n    function ingestsValid() public view returns (bool) {\r\n        return SolverLib.ingestsValid(config.ingests, conditions.length);\r\n    }\r\n\r\n    /**\r\n        @notice Verifies that all slots corresponding to recipients have been filled before CT allocation\r\n        @param _index Condition index\r\n        @return bool\r\n     */\r\n    function allocationsValid(uint256 _index) public view returns (bool) {\r\n        return SolverLib.allocationsValid(_index, datas, config.conditionBase);\r\n    }\r\n\r\n    /**\r\n        @notice Allows keeper to manually add data to IngestType.Manual slots after executeIngests\r\n        @dev Only Keeper, only manual slots\r\n        @param _slot Destination slot\r\n        @param _data Data to be added\r\n     */\r\n    function addData(bytes32 _slot, bytes memory _data) external {\r\n        require(\r\n            msg.sender == config.keeper ||\r\n                isPermittedModule(this.addData.selector),\r\n            \"Only Keeper\"\r\n        );\r\n        require(\r\n            config.ingests[datas.slotIngestIdx[_slot]].ingestType ==\r\n                SolverLib.IngestType.Manual,\r\n            \"only IngestType.Manual\"\r\n        );\r\n\r\n        router(_slot, _data);\r\n        emit IngestedData();\r\n    }\r\n\r\n    /**\r\n        @notice Get most recent data of a slot\r\n        @param _slot slotId\r\n        @return data\r\n     */\r\n    function getData(bytes32 _slot) public view returns (bytes memory data) {\r\n        data = datas.slots[_slot][datas.slots[_slot].length - 1];\r\n    }\r\n\r\n    /**\r\n        @notice Get data for each condition from a slot\r\n        @param _slot slotId\r\n        @return data\r\n     */\r\n    function getAllData(bytes32 _slot)\r\n        public\r\n        view\r\n        returns (bytes[] memory data)\r\n    {\r\n        data = datas.slots[_slot];\r\n    }\r\n\r\n    // ********************************************************************************** //\r\n    // ****************************** CALLBACKS ***************************************** //\r\n    // ********************************************************************************** //\r\n\r\n    /**\r\n        @dev Register callback that an upstream Solver will call when some data is added\r\n        @param _cbSolver Address of the Solver making the callback\r\n        @param _ingestIndex Index of the ingest registering this callback\r\n     */\r\n    function registerIncomingCallback(address _cbSolver, uint256 _ingestIndex)\r\n        private\r\n    {\r\n        callbacks.incoming[\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    _cbSolver,\r\n                    abi.decode(config.ingests[_ingestIndex].data, (bytes32))\r\n                )\r\n            )\r\n        ] = _ingestIndex;\r\n        callbacks.numIncoming++;\r\n    }\r\n\r\n    /**\r\n        @notice Register callback expected by a downstream Solver for some data\r\n        @dev only downstream Solver\r\n        @param _slot Slot being waited on by downstream Solver\r\n        @param _chainIndex Index of the Solver requesting this callback\r\n     */\r\n    function registerOutgoingCallback(bytes32 _slot, uint256 _chainIndex)\r\n        external\r\n    {\r\n        require(_chainIndex > chainIndex, \"solver not downstream\");\r\n        require(\r\n            msg.sender == addressFromChainIndex(_chainIndex),\r\n            \"msg.sender not solver\"\r\n        );\r\n\r\n        if (\r\n            datas.slots[_slot].length > 0 &&\r\n            datas.slots[_slot].length == conditions.length\r\n        ) {\r\n            // Downchain Solver is preparing a new condition before us and is happy with the existing data\r\n            ISolver(msg.sender).handleCallback(_slot);\r\n        } else {\r\n            callbacks.outgoing[_slot].push(msg.sender);\r\n            callbacks.numOutgoing++;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Handle upstream Solver making callback and ingest the data\r\n        @dev only upstream Solver\r\n        @param _slot Destination slot for the data being sent\r\n     */\r\n    function handleCallback(bytes32 _slot) external {\r\n        bytes32 _cb = keccak256(abi.encodePacked(msg.sender, _slot));\r\n        require(\r\n            msg.sender ==\r\n                addressFromChainIndex(\r\n                    config.ingests[callbacks.incoming[_cb]].solverIndex\r\n                ),\r\n            \"msg.sender not solver\"\r\n        );\r\n        require(\r\n            config.ingests[callbacks.incoming[_cb]].ingestType ==\r\n                SolverLib.IngestType.Callback,\r\n            \"not Cb\"\r\n        );\r\n\r\n        config.ingests[callbacks.incoming[_cb]].executions++;\r\n\r\n        router(\r\n            config.ingests[callbacks.incoming[_cb]].slot,\r\n            ISolver(msg.sender).getCallbackOutput(\r\n                abi.decode(\r\n                    config.ingests[callbacks.incoming[_cb]].data,\r\n                    (bytes32)\r\n                )\r\n            )\r\n        );\r\n        delete callbacks.incoming[_cb];\r\n        callbacks.numIncoming--;\r\n\r\n        emit IngestedData();\r\n    }\r\n\r\n    /**\r\n        @dev Make any callbacks that were waiting on _slot\r\n        @param _slot Slot being waited on by downstream Solvers\r\n     */\r\n    function callback(bytes32 _slot) private {\r\n        for (uint256 i; i < callbacks.outgoing[_slot].length; i++) {\r\n            if (address(callbacks.outgoing[_slot][i]) != address(0)) {\r\n                ISolver(address(callbacks.outgoing[_slot][i])).handleCallback(\r\n                    _slot\r\n                );\r\n                delete callbacks.outgoing[_slot][i];\r\n                callbacks.numOutgoing--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice A simple getter that requires upstream slot ver. == our condition ver.\r\n        @param _slot Slot containing data\r\n        @return data\r\n     */\r\n    function getCallbackOutput(bytes32 _slot)\r\n        public\r\n        view\r\n        returns (bytes memory data)\r\n    {\r\n        require(\r\n            datas.slots[_slot].length == conditions.length,\r\n            \"Slot invalid ver.\"\r\n        );\r\n\r\n        data = datas.slots[_slot][datas.slots[_slot].length - 1];\r\n    }\r\n\r\n    // ********************************************************************************** //\r\n    // ****************************** REPORTING ***************************************** //\r\n    // ********************************************************************************** //\r\n\r\n    /**\r\n        @notice Propose payouts (AKA outcomes) for a condition\r\n        @param _index Index of condition\r\n        @param _payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\r\n     */\r\n    function proposePayouts(uint256 _index, uint256[] calldata _payouts)\r\n        external\r\n    {\r\n        require(\r\n            msg.sender == config.keeper ||\r\n                isPermittedModule(this.proposePayouts.selector),\r\n            \"Only Keeper\"\r\n        );\r\n        require(\r\n            _payouts.length == config.conditionBase.outcomeSlots,\r\n            \"length must match outcomeSlots\"\r\n        );\r\n        require(\r\n            conditions[_index].status == SolverLib.Status.Executed,\r\n            \"Not Executed\"\r\n        );\r\n\r\n        SolverLib.proposePayouts(conditions[_index], _payouts);\r\n        updateTimelock(_index);\r\n    }\r\n\r\n    /**\r\n        @notice Confirm payouts for condition (reportPayouts to ConditionalTokens contract)\r\n        @param _index Index of condition\r\n     */\r\n    function confirmPayouts(uint256 _index) external {\r\n        require(block.timestamp > timelocks[_index], \"Timelocked\");\r\n        require(\r\n            conditions[_index].status == SolverLib.Status.OutcomeProposed,\r\n            \"Not proposed\"\r\n        );\r\n        SolverLib.confirmPayouts(solverFactory.ctf(), conditions[_index]);\r\n    }\r\n\r\n    // ********************************************************************************** //\r\n    // ***************************** ARBITRATION **************************************** //\r\n    // ********************************************************************************** //\r\n\r\n    /**\r\n        @notice Sets condition.status to ArbitrationRequested.\r\n        @param _index Index of condition\r\n     */\r\n    function requestArbitration(uint256 _index) external {\r\n        require(\r\n            msg.sender == config.arbitrator ||\r\n                isPermittedModule(this.requestArbitration.selector),\r\n            \"Only arbitrator\"\r\n        );\r\n        require(\r\n            conditions[_index].status == SolverLib.Status.OutcomeProposed ||\r\n                conditions[_index].status ==\r\n                SolverLib.Status.ArbitrationRequested,\r\n            \"Cannot request\"\r\n        );\r\n\r\n        SolverLib.requestArbitration(conditions[_index]);\r\n        updateTimelock(_index);\r\n    }\r\n\r\n    /**\r\n        @notice Allows arbitrator to unilaterally make a payout report.\r\n        @param _index Index of condition\r\n        @param payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\r\n     */\r\n    function arbitrate(uint256 _index, uint256[] memory payouts) external {\r\n        require(\r\n            msg.sender == config.arbitrator ||\r\n                isPermittedModule(this.arbitrate.selector),\r\n            \"Only arbitrator\"\r\n        );\r\n        require(\r\n            conditions[_index].status == SolverLib.Status.ArbitrationRequested,\r\n            \"Not ArbitrationRequested\"\r\n        );\r\n        require(block.timestamp > timelocks[_index], \"Timelocked\");\r\n        require(\r\n            payouts.length == config.conditionBase.outcomeSlots,\r\n            \"length must match outcomeSlots\"\r\n        );\r\n        SolverLib.arbitrate(solverFactory.ctf(), conditions[_index], payouts);\r\n    }\r\n\r\n    /**\r\n        @notice Returns condition.status to OutcomeProposed without a ruling.\r\n        @param _index Index of condition\r\n     */\r\n    function arbitrateNull(uint256 _index) external {\r\n        require(\r\n            msg.sender == config.arbitrator ||\r\n                isPermittedModule(this.arbitrateNull.selector),\r\n            \"Only arbitrator\"\r\n        );\r\n        require(\r\n            conditions[_index].status == SolverLib.Status.ArbitrationRequested,\r\n            \"Not ArbitrationRequested\"\r\n        );\r\n        SolverLib.arbitrateNull(conditions[_index]);\r\n        updateTimelock(_index);\r\n    }\r\n\r\n    // ********************************************************************************** //\r\n    // ******************************** UTILIY ****************************************** //\r\n    // ********************************************************************************** //\r\n\r\n    /**\r\n        @notice Get address for a Solver by its index in the chain\r\n        @dev Returns address(0) if no child or parent\r\n        @param _index Index of Solver\r\n        @return _address\r\n     */\r\n    function addressFromChainIndex(uint256 _index)\r\n        public\r\n        view\r\n        returns (address _address)\r\n    {\r\n        if (_index == chainIndex) {\r\n            _address = address(this);\r\n        } else if (_index < chainIndex) {\r\n            if (chainParent == address(0)) {\r\n                _address = address(0);\r\n            } else {\r\n                _address = ISolver(chainParent).addressFromChainIndex(_index);\r\n            }\r\n        } else if (_index > chainIndex) {\r\n            if (chainChild == address(0)) {\r\n                _address = address(0);\r\n            } else {\r\n                _address = ISolver(chainChild).addressFromChainIndex(_index);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Get one condition\r\n        @param index Index of condition\r\n     */\r\n    function condition(uint256 index)\r\n        public\r\n        view\r\n        returns (SolverLib.Condition memory)\r\n    {\r\n        return conditions[index];\r\n    }\r\n\r\n    /**\r\n        @notice Get all conditions\r\n     */\r\n    function getConditions()\r\n        public\r\n        view\r\n        returns (SolverLib.Condition[] memory)\r\n    {\r\n        return conditions;\r\n    }\r\n\r\n    /**\r\n        @notice Get Solver config\r\n     */\r\n    function getConfig() public view returns (SolverLib.Config memory) {\r\n        return config;\r\n    }\r\n\r\n    /**\r\n        @notice Get Keeper address \r\n    */\r\n    function keeper() public view returns (address) {\r\n        return config.keeper;\r\n    }\r\n\r\n    /**\r\n        @notice Get Arbitrator address \r\n    */\r\n    function arbitrator() public view returns (address) {\r\n        return config.arbitrator;\r\n    }\r\n\r\n    /**\r\n        @notice set ID that will be passed as data for conditional token transfers\r\n        @param _trackingId bytes32\r\n    */\r\n    function setTrackingId(bytes32 _trackingId) public {\r\n        require(trackingId == bytes32(0), \"TrackingId set\");\r\n        require(msg.sender == deployerAddress);\r\n        trackingId = _trackingId;\r\n    }\r\n\r\n    /**\r\n        @notice Update timelock for a condition\r\n        @param _index Timelock/Condition index to be updated\r\n    */\r\n    function updateTimelock(uint256 _index) internal {\r\n        timelocks[_index] =\r\n            block.timestamp +\r\n            (config.timelockSeconds * 1 seconds);\r\n    }\r\n\r\n    /**\r\n        @notice Set new timelock for a condition\r\n        @param _index Timelock/Condition index to be updated\r\n    */\r\n    function setTimelock(uint256 _index, uint256 _date) external {\r\n        require(isPermittedModule(this.setTimelock.selector), \"Not permitted\");\r\n        timelocks[_index] = _date * 1 seconds;\r\n    }\r\n\r\n    /**\r\n        @notice Get balance of collateral token on Solver\r\n        @return balance\r\n    */\r\n    function collateralBalance() public view returns (uint256 balance) {\r\n        balance = IERC20(config.conditionBase.collateralToken).balanceOf(\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n        @notice Returns recipient addresses for a condition\r\n        @param account address to check\r\n        @param conditionIndex condition to check\r\n        @return bool\r\n     */\r\n    function isRecipient(address account, uint256 conditionIndex)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        for (uint256 i; i < config.conditionBase.allocations.length; i++) {\r\n            address recipient = abi.decode(\r\n                datas.slots[\r\n                    config.conditionBase.allocations[i].recipientAddressSlot\r\n                ][conditionIndex],\r\n                (address)\r\n            );\r\n\r\n            if (account == recipient) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n        @notice Get status of a condition\r\n        @param conditionIndex index of condition\r\n        @return status\r\n     */\r\n    function getStatus(uint256 conditionIndex)\r\n        public\r\n        view\r\n        returns (SolverLib.Status status)\r\n    {\r\n        status = conditions[conditionIndex].status;\r\n    }\r\n\r\n    // ********************************************************************************** //\r\n    // ******************************** TOKENS ****************************************** //\r\n    // ********************************************************************************** //\r\n\r\n    /**\r\n        @notice Redeems CTs held by this Solver. See ConditionalTokens contract for more info.\r\n        @dev only Keeper or module\r\n     */\r\n    function redeemPosition(\r\n        IERC20 _collateralToken,\r\n        bytes32 _parentCollectionId,\r\n        bytes32 _conditionId,\r\n        uint256[] calldata _indexSets\r\n    ) external {\r\n        require(\r\n            msg.sender == config.keeper ||\r\n                isPermittedModule(this.redeemPosition.selector),\r\n            \"Only Keeper\"\r\n        );\r\n        IConditionalTokens(solverFactory.ctf()).redeemPositions(\r\n            _collateralToken,\r\n            _parentCollectionId,\r\n            _conditionId,\r\n            _indexSets\r\n        );\r\n    }\r\n\r\n    function transferERC20(\r\n        IERC20 token,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public {\r\n        require(isPermittedModule(this.transferERC20.selector), \"Only module\");\r\n        IERC20(token).safeTransfer(recipient, amount);\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n"
    },
    "contracts/solvers/SolverLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./Solver.sol\";\r\nimport \"../interfaces/ISolver.sol\";\r\nimport \"../interfaces/IConditionalTokens.sol\";\r\nimport \"../interfaces/ISolverFactory.sol\";\r\nimport \"../interfaces/IModule.sol\";\r\nimport \"../modules/Modulated.sol\";\r\nimport \"../FullMath.sol\";\r\n\r\nlibrary SolverLib {\r\n    // Ingest Types\r\n    enum IngestType {\r\n        Callback,\r\n        Constant,\r\n        Function,\r\n        Manual\r\n    }\r\n\r\n    // Status state for Conditions\r\n    enum Status {\r\n        Initiated, // Default state\r\n        Executed, // Solver has executed according to configuration\r\n        OutcomeProposed, // Outcome has been proposed for reporting\r\n        ArbitrationRequested, // Arbitration has been requested for this condition\r\n        ArbitrationDelivered, // Arbitration (except 'null' arbitration) has been delivered for this condition\r\n        OutcomeReported // Outcome has been reported to the CTF via reportPayouts()\r\n    }\r\n\r\n    // Expected sources of data being ingested into the Solver\r\n    struct Ingest {\r\n        uint256 executions; // Number of times this Ingest has been executed\r\n        IngestType ingestType;\r\n        bytes32 slot; // Destination slot for data\r\n        uint256 solverIndex; // Index of the Solver in the chain to make function call to or register callback\r\n        bytes data; // Raw when isConstant=true, slot index of upstream solver data when callback, else an encoded function call\r\n    }\r\n\r\n    // Condition object created by addCondition() from ConditionBase\r\n    struct Condition {\r\n        IERC20 collateralToken;\r\n        bytes32 questionId; // // keccak256(abi.encodePacked(config.conditionBase.metadata, address(this), conditions.length))\r\n        bytes32 parentCollectionId; // ID of the parent collection above this Solver in the CTF\r\n        bytes32 conditionId; // ID of this condition in the CTF\r\n        uint256[] payouts; // Currently proposed payouts. Final if reported == true\r\n        Status status; // Status of this condition\r\n    }\r\n\r\n    // Configuration of this Solver\r\n    struct Config {\r\n        Solver implementation; // The implementation address for this Solver\r\n        address keeper; // Keeper address\r\n        address arbitrator; // Arbitrator address\r\n        uint256 timelockSeconds; // Number of seconds to increment timelock for during critical activities\r\n        Modulated.Loader[] moduleLoaders;\r\n        Ingest[] ingests; // Data ingests to be performed to bring data in from other Solver\r\n        ConditionBase conditionBase; // Base to create conditions from\r\n    }\r\n\r\n    struct Datas {\r\n        mapping(bytes32 => bytes[]) slots;\r\n        mapping(bytes32 => uint256) slotIngestIdx;\r\n    }\r\n\r\n    struct Callbacks {\r\n        uint256 numIncoming;\r\n        uint256 numOutgoing;\r\n        mapping(bytes32 => address[]) outgoing; // This Slot => Solver expecting callback\r\n        mapping(bytes32 => uint256) incoming; // keccack256(Address, CallerSlot) => Receiving Ingest\r\n    }\r\n\r\n    // Immutable data regarding conditions which may be created\r\n    struct ConditionBase {\r\n        IERC20 collateralToken;\r\n        uint256 outcomeSlots; // Num outcome slots\r\n        uint256 parentCollectionIndexSet; // IndexSet to get parentCollectionId from parent Solver\r\n        bytes32 amountSlot; // Slot for amount of collateral being used        // TODO maybe make this dynamic also\r\n        uint256[] partition; // Partition of positions for payouts\r\n        Allocation[] allocations; // Allocations for each partition\r\n        string[] outcomeURIs; // Resource containing human-friendly descriptions of the conditions for this Solver\r\n    }\r\n\r\n    struct Allocation {\r\n        bytes32 recipientAddressSlot; // Slot containing address of recipient\r\n        bytes32[] recipientAmountSlots; // recipientAmountSlots[i] => amount for partition[i]\r\n    }\r\n\r\n    event DeployedChild(address child);\r\n    event ChangedStatus(bytes32 conditionId);\r\n    event DeliveredNullArbitration(bytes32 conditionId);\r\n\r\n    function executeSolve(\r\n        uint256 index,\r\n        address ctfAddress,\r\n        address erc1155Rescue,\r\n        Condition storage condition,\r\n        ConditionBase storage base,\r\n        Datas storage datas,\r\n        bytes32 trackingId,\r\n        address chainParent,\r\n        uint256 amount\r\n    ) public {\r\n        require(\r\n            condition.status == SolverLib.Status.Initiated,\r\n            \"not Initiated\"\r\n        );\r\n        require(\r\n            allocationsValid(index, datas, base),\r\n            \"Recipient slot requires updating\"\r\n        );\r\n\r\n        condition.status = SolverLib.Status.Executed;\r\n        emit ChangedStatus(condition.conditionId);\r\n\r\n        splitPosition(ctfAddress, chainParent, base, condition, amount);\r\n        allocatePartition(\r\n            index,\r\n            ctfAddress,\r\n            erc1155Rescue,\r\n            condition,\r\n            base,\r\n            datas,\r\n            trackingId\r\n        );\r\n    }\r\n\r\n    function createCondition(\r\n        address ctfAddress,\r\n        ConditionBase calldata base,\r\n        address chainParent,\r\n        uint256 conditionIdx\r\n    ) public returns (Condition memory condition) {\r\n        condition.questionId = keccak256(\r\n            abi.encode(base.outcomeURIs, address(this), conditionIdx)\r\n        );\r\n\r\n        if (chainParent == address(0)) {\r\n            condition.parentCollectionId = bytes32(\"\"); // top level collection\r\n        } else {\r\n            Condition[] memory _chainParentConditions = ISolver(chainParent)\r\n                .getConditions();\r\n\r\n            require(\r\n                _chainParentConditions.length > 0,\r\n                \"Parent has no conditions\"\r\n            );\r\n\r\n            condition.parentCollectionId = getCollectionId(\r\n                ctfAddress,\r\n                _chainParentConditions[_chainParentConditions.length - 1],\r\n                base.parentCollectionIndexSet\r\n            );\r\n        }\r\n\r\n        condition.conditionId = IConditionalTokens(ctfAddress).getConditionId(\r\n            address(this), // Solver is Oracle\r\n            condition.questionId,\r\n            base.outcomeSlots\r\n        );\r\n\r\n        condition.collateralToken = base.collateralToken;\r\n\r\n        IConditionalTokens(ctfAddress).prepareCondition(\r\n            address(this),\r\n            condition.questionId,\r\n            base.outcomeSlots\r\n        );\r\n    }\r\n\r\n    function deployChild(\r\n        ISolverFactory factory,\r\n        Config calldata config,\r\n        uint256 solverIndex,\r\n        bytes32 trackingId\r\n    ) public returns (address child) {\r\n        child = factory.createSolver(address(this), solverIndex + 1, config);\r\n\r\n        if (trackingId != bytes32(\"\")) {\r\n            ISolver(child).setTrackingId(trackingId);\r\n        }\r\n\r\n        emit DeployedChild(child);\r\n\r\n        return child;\r\n    }\r\n\r\n    function getPositionId(\r\n        address ctfAddress,\r\n        Condition memory condition,\r\n        IERC20 collateralToken,\r\n        uint256 partition\r\n    ) public view returns (uint256 positionId) {\r\n        IConditionalTokens ct = IConditionalTokens(ctfAddress);\r\n        positionId = ct.getPositionId(\r\n            collateralToken,\r\n            ct.getCollectionId(\r\n                condition.parentCollectionId,\r\n                condition.conditionId,\r\n                partition\r\n            )\r\n        );\r\n    }\r\n\r\n    function splitPosition(\r\n        address ctfAddress,\r\n        address chainParent,\r\n        ConditionBase storage base,\r\n        Condition storage condition,\r\n        uint256 amount\r\n    ) public {\r\n        uint256 _balance;\r\n\r\n        IConditionalTokens ICT = IConditionalTokens(ctfAddress);\r\n\r\n        if (chainParent == address(0)) {\r\n            _balance = IERC20(base.collateralToken).balanceOf(address(this));\r\n            base.collateralToken.approve(ctfAddress, bpToNum(amount, _balance));\r\n        } else {\r\n            _balance = ICT.balanceOf(\r\n                address(this),\r\n                ICT.getPositionId(\r\n                    base.collateralToken,\r\n                    condition.parentCollectionId\r\n                )\r\n            );\r\n        }\r\n\r\n        ICT.splitPosition(\r\n            base.collateralToken,\r\n            condition.parentCollectionId,\r\n            condition.conditionId,\r\n            base.partition,\r\n            bpToNum(amount, _balance)\r\n        );\r\n    }\r\n\r\n    function reportPayouts(address ctfAddress, Condition storage condition)\r\n        public\r\n    {\r\n        IConditionalTokens(ctfAddress).reportPayouts(\r\n            condition.questionId,\r\n            condition.payouts\r\n        );\r\n        emit ChangedStatus(condition.conditionId);\r\n    }\r\n\r\n    function reportPayouts(\r\n        address ctfAddress,\r\n        Condition storage condition,\r\n        uint256[] memory payouts\r\n    ) public {\r\n        IConditionalTokens(ctfAddress).reportPayouts(\r\n            condition.questionId,\r\n            payouts\r\n        );\r\n        emit ChangedStatus(condition.conditionId);\r\n    }\r\n\r\n    function proposePayouts(\r\n        Condition storage condition,\r\n        uint256[] calldata _payouts\r\n    ) public {\r\n        condition.status = Status.OutcomeProposed;\r\n        condition.payouts = _payouts;\r\n\r\n        emit ChangedStatus(condition.conditionId);\r\n    }\r\n\r\n    function confirmPayouts(address ctfAddress, Condition storage condition)\r\n        public\r\n    {\r\n        condition.status = Status.OutcomeReported;\r\n        reportPayouts(ctfAddress, condition);\r\n    }\r\n\r\n    function requestArbitration(Condition storage condition) public {\r\n        condition.status = Status.ArbitrationRequested;\r\n        emit ChangedStatus(condition.conditionId);\r\n    }\r\n\r\n    function arbitrateNull(Condition storage condition) public {\r\n        condition.status = Status.OutcomeProposed;\r\n        emit ChangedStatus(condition.conditionId);\r\n        emit DeliveredNullArbitration(condition.conditionId);\r\n    }\r\n\r\n    function arbitrate(\r\n        address ctfAddress,\r\n        Condition storage condition,\r\n        uint256[] memory payouts\r\n    ) public {\r\n        condition.status = Status.ArbitrationDelivered;\r\n        reportPayouts(ctfAddress, condition, payouts);\r\n        emit ChangedStatus(condition.conditionId);\r\n    }\r\n\r\n    function allocationsValid(\r\n        uint256 conditionVer,\r\n        Datas storage datas,\r\n        ConditionBase storage conditionBase\r\n    ) public view returns (bool valid) {\r\n        valid = true;\r\n\r\n        for (uint256 i = 0; i < conditionBase.allocations.length; i++) {\r\n            if (\r\n                datas\r\n                    .slots[conditionBase.allocations[i].recipientAddressSlot]\r\n                    .length != (conditionVer + 1)\r\n            ) {\r\n                valid = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function allocatePartition(\r\n        uint256 conditionVer,\r\n        address ctfAddress,\r\n        address erc1155Rescue,\r\n        Condition storage condition,\r\n        ConditionBase storage base,\r\n        Datas storage data,\r\n        bytes32 trackingId\r\n    ) public {\r\n        uint256[] memory _tokens = new uint256[](base.partition.length);\r\n        uint256[] memory _balances = new uint256[](base.partition.length);\r\n        address[] memory _addressThis = new address[](base.partition.length);\r\n\r\n        for (uint256 i; i < base.partition.length; i++) {\r\n            _tokens[i] = getPositionId(\r\n                ctfAddress,\r\n                condition,\r\n                base.collateralToken,\r\n                base.partition[i]\r\n            );\r\n            _addressThis[i] = address(this); // For more efficient balanceOfBatch call\r\n        }\r\n\r\n        _balances = IConditionalTokens(ctfAddress).balanceOfBatch(\r\n            _addressThis,\r\n            _tokens\r\n        );\r\n\r\n        for (uint256 i; i < base.allocations.length; i++) {\r\n            uint256[] memory _amounts = new uint256[](base.partition.length);\r\n\r\n            for (\r\n                uint256 j;\r\n                j < base.allocations[i].recipientAmountSlots.length;\r\n                j++\r\n            ) {\r\n                uint256 _pctValue = abi.decode(\r\n                    data.slots[base.allocations[i].recipientAmountSlots[j]][\r\n                        conditionVer\r\n                    ],\r\n                    (uint256)\r\n                );\r\n                if (_pctValue == 0) {\r\n                    _amounts[j] = 0;\r\n                } else {\r\n                    _amounts[j] = bpToNum(_pctValue, _balances[j]);\r\n                }\r\n            }\r\n\r\n            address recipient = abi.decode(\r\n                data.slots[base.allocations[i].recipientAddressSlot][\r\n                    conditionVer\r\n                ],\r\n                (address)\r\n            );\r\n\r\n            try\r\n                IConditionalTokens(ctfAddress).safeBatchTransferFrom(\r\n                    address(this),\r\n                    recipient,\r\n                    _tokens,\r\n                    _amounts,\r\n                    abi.encode(trackingId)\r\n                )\r\n            {} catch {\r\n                IConditionalTokens(ctfAddress).safeBatchTransferFrom(\r\n                    address(this),\r\n                    erc1155Rescue,\r\n                    _tokens,\r\n                    _amounts,\r\n                    abi.encode(recipient, trackingId)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function bpToNum(uint256 bp, uint256 num) public pure returns (uint256) {\r\n        return FullMath.mulDiv(bp, num, 10000);\r\n    }\r\n\r\n    function ingest(Ingest storage _ingest)\r\n        public\r\n        view\r\n        returns (bytes memory data)\r\n    {\r\n        require(\r\n            _ingest.ingestType != IngestType.Manual,\r\n            \"Manual ingests should not get here\"\r\n        );\r\n\r\n        if (_ingest.ingestType == IngestType.Constant) {\r\n            data = _ingest.data;\r\n        } else {\r\n            address _solver = ISolver(address(this)).addressFromChainIndex(\r\n                _ingest.solverIndex\r\n            );\r\n            (bool success, bytes memory retData) = _solver.staticcall(\r\n                _ingest.data\r\n            );\r\n            require(success, \"Ingest staticcall failed\");\r\n            data = retData;\r\n        }\r\n    }\r\n\r\n    function ingestsValid(Ingest[] calldata ingests, uint256 conditionVer)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        for (uint256 i; i < ingests.length; i++) {\r\n            if (ingests[i].executions != conditionVer) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getCollectionId(\r\n        address ctfAddress,\r\n        Condition memory condition,\r\n        uint256 partition\r\n    ) public view returns (bytes32 collectionId) {\r\n        collectionId = IConditionalTokens(ctfAddress).getCollectionId(\r\n            condition.parentCollectionId,\r\n            condition.conditionId,\r\n            partition\r\n        );\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/conditionalTokens/CTHelpers.sol": {
      "content": "/** \r\n    SPDX-License-Identifier: LGPL-3.0\r\n    Copied from Gnosis\r\n    Updated for Solidity 0.8.0\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nlibrary CTHelpers {\r\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\r\n    /// @param oracle The account assigned to report the result for the prepared condition.\r\n    /// @param questionId An identifier for the question to be answered by the oracle.\r\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\r\n    function getConditionId(\r\n        address oracle,\r\n        bytes32 questionId,\r\n        uint256 outcomeSlotCount\r\n    ) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\r\n    }\r\n\r\n    uint256 constant P =\r\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n    uint256 constant B = 3;\r\n\r\n    function sqrt(uint256 x) private pure returns (uint256 y) {\r\n        uint256 p = P;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // add chain generated via https://crypto.stackexchange.com/q/27179/71252\r\n            // and transformed to the following program:\r\n\r\n            // x=1; y=x+x; z=y+y; z=z+z; y=y+z; x=x+y; y=y+x; z=y+y; t=z+z; t=z+t; t=t+t;\r\n            // t=t+t; z=z+t; x=x+z; z=x+x; z=z+z; y=y+z; z=y+y; z=z+z; z=z+z; z=y+z; x=x+z;\r\n            // z=x+x; z=z+z; z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; z=y+y; t=z+z;\r\n            // t=t+t; t=t+t; z=z+t; x=x+z; y=y+x; z=y+y; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\r\n            // z=x+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; t=z+z; t=t+t; t=z+t; t=y+t; t=t+t;\r\n            // t=t+t; t=t+t; t=t+t; z=z+t; x=x+z; z=x+x; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z;\r\n            // t=z+z; t=z+t; w=t+t; w=w+w; w=w+w; w=w+w; w=w+w; t=t+w; z=z+t; x=x+z; y=y+x;\r\n            // z=y+y; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; z=z+z; y=y+z; z=y+y;\r\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; x=x+z; y=y+x; x=x+y; y=y+x; z=y+y; z=z+z;\r\n            // z=y+z; x=x+z; z=x+x; z=x+z; y=y+z; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; z=y+z;\r\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x; t=z+z; t=t+t; t=z+t;\r\n            // t=x+t; t=t+t; t=t+t; t=t+t; t=t+t; z=z+t; y=y+z; x=x+y; y=y+x; x=x+y; z=x+x;\r\n            // z=x+z; z=z+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x;\r\n            // z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; x=x+y; z=x+x; y=y+z; x=x+y; y=y+x;\r\n            // z=y+y; z=y+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\r\n            // z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; t=x+z; t=t+t; t=t+t; z=z+t; y=y+z; z=y+y;\r\n            // x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; t=y+z; z=y+t; z=z+z; z=z+z;\r\n            // z=t+z; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; y=y+z; x=x+y; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\r\n            // x=x+x; x=x+x; x=x+x; x=x+x; res=y+x\r\n            // res == (P + 1) // 4\r\n\r\n            y := mulmod(x, x, p)\r\n            {\r\n                let z := mulmod(y, y, p)\r\n                z := mulmod(z, z, p)\r\n                y := mulmod(y, z, p)\r\n                x := mulmod(x, y, p)\r\n                y := mulmod(y, x, p)\r\n                z := mulmod(y, y, p)\r\n                {\r\n                    let t := mulmod(z, z, p)\r\n                    t := mulmod(z, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    z := mulmod(z, t, p)\r\n                    x := mulmod(x, z, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(z, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(y, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(x, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    x := mulmod(x, y, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(z, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    z := mulmod(y, y, p)\r\n                    t := mulmod(z, z, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    z := mulmod(z, t, p)\r\n                    x := mulmod(x, z, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(x, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(x, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    z := mulmod(y, y, p)\r\n                    t := mulmod(z, z, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(z, t, p)\r\n                    t := mulmod(y, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    z := mulmod(z, t, p)\r\n                    x := mulmod(x, z, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(x, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(y, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    t := mulmod(z, z, p)\r\n                    t := mulmod(z, t, p)\r\n                    {\r\n                        let w := mulmod(t, t, p)\r\n                        w := mulmod(w, w, p)\r\n                        w := mulmod(w, w, p)\r\n                        w := mulmod(w, w, p)\r\n                        w := mulmod(w, w, p)\r\n                        t := mulmod(t, w, p)\r\n                    }\r\n                    z := mulmod(z, t, p)\r\n                    x := mulmod(x, z, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    x := mulmod(x, z, p)\r\n                    y := mulmod(y, x, p)\r\n                    x := mulmod(x, y, p)\r\n                    y := mulmod(y, x, p)\r\n                    x := mulmod(x, y, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(x, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(z, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(y, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    y := mulmod(y, x, p)\r\n                    x := mulmod(x, y, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(y, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(x, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    x := mulmod(x, y, p)\r\n                    y := mulmod(y, x, p)\r\n                    x := mulmod(x, y, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(y, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(y, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    z := mulmod(x, x, p)\r\n                    t := mulmod(z, z, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(z, t, p)\r\n                    t := mulmod(x, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    z := mulmod(z, t, p)\r\n                    y := mulmod(y, z, p)\r\n                    x := mulmod(x, y, p)\r\n                    y := mulmod(y, x, p)\r\n                    x := mulmod(x, y, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(x, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(x, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(y, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(x, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    x := mulmod(x, y, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(z, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    x := mulmod(x, y, p)\r\n                    z := mulmod(x, x, p)\r\n                    y := mulmod(y, z, p)\r\n                    x := mulmod(x, y, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(y, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    z := mulmod(y, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    x := mulmod(x, z, p)\r\n                    z := mulmod(x, x, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(x, z, p)\r\n                    y := mulmod(y, z, p)\r\n                    x := mulmod(x, y, p)\r\n                    z := mulmod(x, x, p)\r\n                    t := mulmod(x, z, p)\r\n                    t := mulmod(t, t, p)\r\n                    t := mulmod(t, t, p)\r\n                    z := mulmod(z, t, p)\r\n                    y := mulmod(y, z, p)\r\n                    z := mulmod(y, y, p)\r\n                    x := mulmod(x, z, p)\r\n                    y := mulmod(y, x, p)\r\n                    x := mulmod(x, y, p)\r\n                    y := mulmod(y, x, p)\r\n                    x := mulmod(x, y, p)\r\n                    y := mulmod(y, x, p)\r\n                    z := mulmod(y, y, p)\r\n                    t := mulmod(y, z, p)\r\n                    z := mulmod(y, t, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(z, z, p)\r\n                    z := mulmod(t, z, p)\r\n                }\r\n                x := mulmod(x, z, p)\r\n                y := mulmod(y, x, p)\r\n                x := mulmod(x, y, p)\r\n                y := mulmod(y, x, p)\r\n                x := mulmod(x, y, p)\r\n                z := mulmod(x, x, p)\r\n                z := mulmod(x, z, p)\r\n                y := mulmod(y, z, p)\r\n            }\r\n            x := mulmod(x, y, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            x := mulmod(x, x, p)\r\n            y := mulmod(y, x, p)\r\n        }\r\n    }\r\n\r\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\r\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\r\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\r\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\r\n    function getCollectionId(\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256 indexSet\r\n    ) internal view returns (bytes32) {\r\n        uint256 x1 = uint256(\r\n            keccak256(abi.encodePacked(conditionId, indexSet))\r\n        );\r\n        bool odd = x1 >> 255 != 0;\r\n        uint256 y1;\r\n        uint256 yy;\r\n        do {\r\n            x1 = addmod(x1, 1, P);\r\n            yy = addmod(mulmod(x1, mulmod(x1, x1, P), P), B, P);\r\n            y1 = sqrt(yy);\r\n        } while (mulmod(y1, y1, P) != yy);\r\n        if ((odd && y1 % 2 == 0) || (!odd && y1 % 2 == 1)) y1 = P - y1;\r\n\r\n        uint256 x2 = uint256(parentCollectionId);\r\n        if (x2 != 0) {\r\n            odd = x2 >> 254 != 0;\r\n            x2 = (x2 << 2) >> 2;\r\n            yy = addmod(mulmod(x2, mulmod(x2, x2, P), P), B, P);\r\n            uint256 y2 = sqrt(yy);\r\n            if ((odd && y2 % 2 == 0) || (!odd && y2 % 2 == 1)) y2 = P - y2;\r\n            require(mulmod(y2, y2, P) == yy, \"invalid parentID\");\r\n\r\n            (bool success, bytes memory ret) = address(6).staticcall(\r\n                abi.encode(x1, y1, x2, y2)\r\n            );\r\n            require(success, \"ecadd failed\");\r\n            (x1, y1) = abi.decode(ret, (uint256, uint256));\r\n        }\r\n\r\n        if (y1 % 2 == 1) x1 ^= 1 << 254;\r\n\r\n        return bytes32(x1);\r\n    }\r\n\r\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\r\n    /// @param collateralToken Collateral token which backs the position.\r\n    /// @param collectionId ID of the outcome collection associated with this position.\r\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return\r\n            uint256(keccak256(abi.encodePacked(collateralToken, collectionId)));\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][account] = accountBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IConditionalTokens.sol": {
      "content": "/** \r\n    SPDX-License-Identifier: LGPL-3.0\r\n*/\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\n\r\n// Mainnet (ID: 1) canonical address: 0xC59b0e4De5F1248C1140964E0fF287B192407E0C\r\n// Rinkeby (ID: 4) canonical address: 0x36bede640D19981A82090519bC1626249984c908\r\n\r\ninterface IConditionalTokens is IERC1155 {\r\n    /// @dev This function prepares a condition by initializing a payout vector associated with the condition.\r\n    /// @param oracle The account assigned to report the result for the prepared condition.\r\n    /// @param questionId An identifier for the question to be answered by the oracle.\r\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\r\n    function prepareCondition(\r\n        address oracle,\r\n        bytes32 questionId,\r\n        uint256 outcomeSlotCount\r\n    ) external;\r\n\r\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``, where oracle is the message sender, questionId is one of the parameters of this function, and outcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.\r\n    /// @param questionId The question ID the oracle is answering for\r\n    /// @param payouts The oracle's answer\r\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts)\r\n        external;\r\n\r\n    /// @dev This function splits a position. If splitting from the collateral, this contract will attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this contract will burn `amount` stake held by the message sender in the position being split worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the split target positions. If any of the transfers, mints, or burns fail, the transaction will revert. The transaction will also revert if the given partition is trivial, invalid, or refers to more slots than the condition is prepared with.\r\n    /// @param collateralToken The address of the positions' backing collateral token.\r\n    /// @param parentCollectionId The ID of the outcome collections common to the position being split and the split target positions. May be null, in which only the collateral is shared.\r\n    /// @param conditionId The ID of the condition to split on.\r\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint). Each element's a number which, together with the condition, represents the outcome collection. E.g. 0b110 is A|B, 0b010 is B, etc.\r\n    /// @param amount The amount of collateral or stake to split.\r\n    function splitPosition(\r\n        IERC20 collateralToken,\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256[] calldata partition,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function mergePositions(\r\n        IERC20 collateralToken,\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256[] calldata partition,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function redeemPositions(\r\n        IERC20 collateralToken,\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256[] calldata indexSets\r\n    ) external;\r\n\r\n    /// @dev Gets the outcome slot count of a condition.\r\n    /// @param conditionId ID of the condition.\r\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not been prepared yet.\r\n    function getOutcomeSlotCount(bytes32 conditionId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\r\n    /// @param oracle The account assigned to report the result for the prepared condition.\r\n    /// @param questionId An identifier for the question to be answered by the oracle.\r\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\r\n    function getConditionId(\r\n        address oracle,\r\n        bytes32 questionId,\r\n        uint256 outcomeSlotCount\r\n    ) external pure returns (bytes32);\r\n\r\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\r\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\r\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\r\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\r\n    function getCollectionId(\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256 indexSet\r\n    ) external view returns (bytes32);\r\n\r\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\r\n    /// @param collateralToken Collateral token which backs the position.\r\n    /// @param collectionId ID of the outcome collection associated with this position.\r\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\r\n        external\r\n        pure\r\n        returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/ISolverFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"../solvers/SolverLib.sol\";\r\n\r\ninterface ISolverFactory {\r\n    function createSolver(\r\n        address chainParent,\r\n        uint256 chainIndex,\r\n        SolverLib.Config calldata solverConfig\r\n    ) external returns (address);\r\n\r\n    function ctf() external view returns (address);\r\n\r\n    function erc1155Rescue() external view returns (address);\r\n}\r\n"
    },
    "contracts/interfaces/IModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\ninterface IModule is IERC165 {\r\n    function load(bytes calldata data) external;\r\n\r\n    function fetchPermits() external view returns (bytes4[] memory);\r\n\r\n    function isPermitted(bytes4 selector) external view returns (bool);\r\n}\r\n"
    },
    "contracts/modules/Modulated.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\nimport \"../interfaces/IModule.sol\";\r\nimport \"../interfaces/ISolver.sol\";\r\n\r\nabstract contract Modulated {\r\n    address private _context;\r\n\r\n    struct Loader {\r\n        IModule module;\r\n        bytes data;\r\n    }\r\n\r\n    mapping(address => bool) private modules; // module => true/false\r\n\r\n    mapping(bytes32 => bytes) private state;\r\n\r\n    function loadModules(Loader[] calldata loaders) internal virtual {\r\n        for (uint256 i; i < loaders.length; i++) {\r\n            modules[address(loaders[i].module)] = true;\r\n            loaders[i].module.load(loaders[i].data);\r\n        }\r\n    }\r\n\r\n    function setState(bytes32 key, bytes memory data) external virtual {\r\n        require(isPermittedModule(this.setState.selector), \"Not permitted\");\r\n        state[key] = data;\r\n    }\r\n\r\n    function getState(bytes32 key) public view returns (bytes memory data) {\r\n        data = state[key];\r\n    }\r\n\r\n    function isPermittedModule(bytes4 selector) public view returns (bool) {\r\n        if (modules[msg.sender]) {\r\n            bool res = IModule(msg.sender).isPermitted(selector);\r\n            return res;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = a * b\r\n        // Compute the product mod 2**256 and mod 2**256 - 1\r\n        // then use the Chinese Remainder Theorem to reconstruct\r\n        // the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2**256 + prod0\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2**256.\r\n        // Also prevents denominator == 0\r\n        require(denominator > prod1);\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0]\r\n        // Compute remainder using mulmod\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        // Subtract 256 bit number from 512 bit number\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator\r\n        // Compute largest power of two divisor of denominator.\r\n        // Always >= 1.\r\n        uint256 twos = denominator & (~denominator + 1);\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        // Invert denominator mod 2**256\r\n        // Now that denominator is an odd number, it has an inverse\r\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n        // Compute the inverse by starting with a seed that is correct\r\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n        // Now use Newton-Raphson iteration to improve the precision.\r\n        // Thanks to Hensel's lifting lemma, this also works in modular\r\n        // arithmetic, doubling the correct bits in each step.\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        // Because the division is now exact we can divide by multiplying\r\n        // with the modular inverse of denominator. This will give us the\r\n        // correct result modulo 2**256. Since the precoditions guarantee\r\n        // that the outcome is less than 2**256, this is the final result.\r\n        // We don't need to compute the high bits of the result and prod1\r\n        // is no longer required.\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n\r\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n            require(result < type(uint256).max);\r\n            result++;\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/modules/RepeatableProposal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"../solvers/SolverLib.sol\";\r\nimport \"../interfaces/ISolver.sol\";\r\nimport \"./Module.sol\";\r\n\r\nimport \"../interfaces/IProposalsHub.sol\";\r\n\r\nimport \"../hubs/ProposalsHub.sol\";\r\n\r\ncontract RepeatableProposal is Module {\r\n    IProposalsHub public immutable proposalsHub;\r\n\r\n    struct Repeater {\r\n        bool enabled; // do repeats\r\n        uint256[] contributions;\r\n        mapping(address => uint256[]) contributorIndices;\r\n    }\r\n\r\n    mapping(address => Repeater) public repeaters; // Solver => Repeater\r\n\r\n    event Repeated(\r\n        address indexed solver,\r\n        bytes32 indexed trackingId,\r\n        uint256 conditionIndex\r\n    );\r\n\r\n    event FundedRepeater(\r\n        address indexed solver,\r\n        bytes32 indexed trackingId,\r\n        uint256 amount,\r\n        address from\r\n    );\r\n\r\n    event DefundedRepeater(\r\n        address indexed solver,\r\n        bytes32 indexed trackingId,\r\n        uint256 amount,\r\n        address to\r\n    );\r\n\r\n    constructor(IProposalsHub proposalsHub_) {\r\n        proposalsHub = proposalsHub_;\r\n        permits.push(ISolver.prepareSolve.selector);\r\n    }\r\n\r\n    function load(bytes memory data) external override {\r\n        data;\r\n        Repeater storage repeater = repeaters[msg.sender];\r\n        repeater.enabled = true;\r\n        emit LoadedModule(address(this), msg.sender);\r\n    }\r\n\r\n    function fund(ISolver solver, uint256 amount) external {\r\n        Repeater storage repeater = repeaters[address(solver)];\r\n        require(repeater.enabled, \"Disabled\");\r\n        require(amount > 0, \"Amount must be > 0\");\r\n\r\n        bytes32 trackingId = solver.trackingId();\r\n\r\n        ProposalsHub.Proposal memory proposal = proposalsHub.getProposal(\r\n            trackingId\r\n        );\r\n\r\n        IERC20 token = proposal.collateralToken;\r\n\r\n        uint256 beforeBalance = token.balanceOf(address(this));\r\n\r\n        require(\r\n            token.transferFrom(msg.sender, address(this), amount),\r\n            \"Could not transfer from msg.sender\"\r\n        );\r\n\r\n        require(\r\n            token.balanceOf(address(this)) - beforeBalance == amount,\r\n            \"Incorrect balance after transfer\"\r\n        );\r\n\r\n        repeater.contributions.push(amount);\r\n\r\n        repeater.contributorIndices[msg.sender].push(\r\n            repeater.contributions.length - 1\r\n        );\r\n\r\n        emit FundedRepeater(address(solver), trackingId, amount, msg.sender);\r\n    }\r\n\r\n    function defund(ISolver solver, uint256 amount) external {\r\n        Repeater storage repeater = repeaters[address(solver)];\r\n\r\n        uint256[] memory contributionIndices = repeater.contributorIndices[\r\n            msg.sender\r\n        ];\r\n\r\n        uint256 sum = 0;\r\n\r\n        for (uint256 i = 0; i < contributionIndices.length; i++) {\r\n            if (sum < amount) {\r\n                uint256 contribution = repeater.contributions[\r\n                    contributionIndices[i]\r\n                ];\r\n\r\n                if (contribution > 0) {\r\n                    if (sum + contribution <= amount) {\r\n                        sum += contribution;\r\n                        delete repeater.contributions[contributionIndices[i]];\r\n                    } else {\r\n                        repeater.contributions[contributionIndices[i]] -=\r\n                            amount -\r\n                            sum;\r\n                        sum += amount - sum;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        require(sum == amount, \"Not enough funds\");\r\n\r\n        bytes32 trackingId = solver.trackingId();\r\n\r\n        ProposalsHub.Proposal memory proposal = proposalsHub.getProposal(\r\n            trackingId\r\n        );\r\n\r\n        uint256 beforeBalance = proposal.collateralToken.balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        require(\r\n            proposal.collateralToken.transfer(msg.sender, amount),\r\n            \"Transfer failed\"\r\n        );\r\n\r\n        require(\r\n            beforeBalance - proposal.collateralToken.balanceOf(address(this)) ==\r\n                amount,\r\n            \"Before and after balance wrong\"\r\n        );\r\n\r\n        emit DefundedRepeater(address(solver), trackingId, amount, msg.sender);\r\n    }\r\n\r\n    function repeat(ISolver solver) external {\r\n        require(msg.sender == solver.keeper(), \"Only Keeper\");\r\n        Repeater storage repeater = repeaters[address(solver)];\r\n        require(repeater.enabled, \"Disabled\");\r\n\r\n        bytes32 trackingId = solver.trackingId();\r\n\r\n        ProposalsHub.Proposal memory proposal = proposalsHub.getProposal(\r\n            trackingId\r\n        );\r\n\r\n        require(proposal.isExecuted, \"Initial proposal not executed\");\r\n\r\n        SolverLib.Condition[] memory conditions = solver.getConditions();\r\n\r\n        SolverLib.Condition memory condition = conditions[\r\n            conditions.length - 1\r\n        ];\r\n\r\n        require(\r\n            condition.status == SolverLib.Status.ArbitrationDelivered ||\r\n                condition.status == SolverLib.Status.OutcomeReported,\r\n            \"Not ready to repeat\"\r\n        );\r\n\r\n        uint256 sum = 0;\r\n\r\n        for (uint256 i = 0; i < repeater.contributions.length; i++) {\r\n            if (sum < proposal.fundingGoal) {\r\n                uint256 contribution = repeater.contributions[i];\r\n\r\n                if (contribution > 0) {\r\n                    if (sum + contribution <= proposal.fundingGoal) {\r\n                        sum += contribution;\r\n                        delete repeater.contributions[i];\r\n                    } else {\r\n                        repeater.contributions[i] -= proposal.fundingGoal - sum;\r\n                        sum += proposal.fundingGoal - sum;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        require(sum == proposal.fundingGoal, \"Not enough funds\");\r\n\r\n        require(\r\n            proposal.collateralToken.transfer(\r\n                address(solver),\r\n                proposal.fundingGoal\r\n            ),\r\n            \"Token transfer failed\"\r\n        );\r\n\r\n        solver.prepareSolve(conditions.length);\r\n\r\n        try solver.executeSolve(conditions.length) {} catch {}\r\n\r\n        emit Repeated(address(solver), trackingId, conditions.length);\r\n    }\r\n\r\n    function disable(ISolver solver) external {\r\n        require(msg.sender == solver.keeper(), \"Only Keeper\");\r\n        repeaters[address(solver)].enabled = false;\r\n    }\r\n\r\n    function enable(ISolver solver) external {\r\n        require(msg.sender == solver.keeper(), \"Only Keeper\");\r\n        repeaters[address(solver)].enabled = true;\r\n    }\r\n\r\n    function getFunding(address solver) external view returns (uint256 sum) {\r\n        for (uint256 i = 0; i < repeaters[solver].contributions.length; i++) {\r\n            sum += repeaters[solver].contributions[i];\r\n        }\r\n    }\r\n\r\n    function getFundingFrom(address solver, address account)\r\n        external\r\n        view\r\n        returns (uint256 sum)\r\n    {\r\n        for (\r\n            uint256 i = 0;\r\n            i < repeaters[solver].contributorIndices[account].length;\r\n            i++\r\n        ) {\r\n            sum += repeaters[solver].contributions[\r\n                repeaters[solver].contributorIndices[account][i]\r\n            ];\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/modules/Module.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\nimport \"./Modulated.sol\";\r\n\r\nimport \"../interfaces/IModule.sol\";\r\n\r\nabstract contract Module is IModule {\r\n    bytes4[] permits;\r\n    bytes32 immutable STATEKEY = keccak256(abi.encode(address(this)));\r\n\r\n    event LoadedModule(address indexed module, address indexed solver);\r\n\r\n    constructor() {\r\n        permits.push(Modulated.setState.selector);\r\n    }\r\n\r\n    function fetchPermits() external view returns (bytes4[] memory) {\r\n        return permits;\r\n    }\r\n\r\n    function isPermitted(bytes4 selector) external view returns (bool) {\r\n        for (uint256 i = 0; i < permits.length; i++) {\r\n            if (permits[i] == selector) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function load(bytes calldata data) external virtual {\r\n        Modulated(msg.sender).setState(STATEKEY, data);\r\n        emit LoadedModule(address(this), msg.sender);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(Module).interfaceId ||\r\n            interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IProposalsHub.sol": {
      "content": "pragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../solvers/SolverLib.sol\";\r\nimport \"../hubs/ProposalsHub.sol\";\r\nimport \"./IIPFSSolutionsHub.sol\";\r\n\r\ninterface IProposalsHub {\r\n    function executeProposal(bytes32 proposalId) external;\r\n\r\n    function executeIPFSProposal(\r\n        bytes32 proposalId,\r\n        SolverLib.Config[] calldata solverConfigs\r\n    ) external;\r\n\r\n    function approveERC20Transfer(bytes32 proposalId, address solver) external;\r\n\r\n    function createProposal(\r\n        IERC20 collateralToken,\r\n        address solutionsHub,\r\n        uint256 fundingGoal,\r\n        bytes32 safeBaseId,\r\n        SolverLib.Config[] memory solverConfigs,\r\n        string calldata metadataURI\r\n    ) external;\r\n\r\n    function createIPFSSolutionAndProposal(\r\n        bytes32 solutionId,\r\n        IERC20 collateralToken,\r\n        IIPFSSolutionsHub ipfsSolutionsHub,\r\n        uint256 fundingGoal,\r\n        SolverLib.Config[] calldata solverConfigs,\r\n        string calldata solverConfigsURI,\r\n        string calldata metadataURI\r\n    ) external returns (bytes32 solutionID, bytes32 proposalID);\r\n\r\n    function fundProposal(\r\n        bytes32 proposalId,\r\n        IERC20 token,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function defundProposal(\r\n        bytes32 proposalId,\r\n        IERC20 token,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function getMetadataCID(bytes32 id) external view returns (string memory);\r\n\r\n    function isProposal(bytes32 id) external view returns (bool);\r\n\r\n    function getProposal(bytes32 id)\r\n        external\r\n        view\r\n        returns (ProposalsHub.Proposal memory proposal);\r\n\r\n    function transferERC20(bytes32 proposalId, address solver) external;\r\n\r\n    function reclaimTokens(bytes32 proposalId, uint256 tokenId) external;\r\n}\r\n"
    },
    "contracts/hubs/ProposalsHub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\r\n\r\nimport \"../interfaces/IIPFSSolutionsHub.sol\";\r\nimport \"../interfaces/IConditionalTokens.sol\";\r\n\r\nimport \"../solvers/SolverLib.sol\";\r\n\r\ncontract ProposalsHub is ERC1155Receiver {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Used to allow funders to reclaim conditional tokens sent to this address\r\n    IConditionalTokens public immutable conditionalTokens;\r\n\r\n    // Increment for unique proposal IDs\r\n    mapping(bytes32 => uint256) public nonces;\r\n\r\n    struct Proposal {\r\n        bool isExecuted;\r\n        IERC20 collateralToken;\r\n        address proposer;\r\n        address solutionsHub;\r\n        bytes32 id;\r\n        bytes32 solutionId;\r\n        uint256 funding;\r\n        uint256 fundingGoal;\r\n        string metadataURI;\r\n    }\r\n\r\n    mapping(bytes32 => Proposal) public proposals;\r\n    mapping(bytes32 => mapping(address => uint256)) public funderAmountMap;\r\n\r\n    // Used to allow funders to reclaim conditional tokens sent to this address\r\n    mapping(bytes32 => mapping(uint256 => uint256)) public reclaimableTokens;\r\n    mapping(uint256 => mapping(address => uint256)) public reclaimedTokens;\r\n\r\n    event CreateProposal(bytes32 indexed id);\r\n    event ExecuteProposal(bytes32 indexed id);\r\n    event FundProposal(bytes32 indexed id, uint256 amount, address from);\r\n    event DefundProposal(bytes32 indexed id, uint256 amount, address to);\r\n\r\n    constructor(address _ctfAddress) {\r\n        conditionalTokens = IConditionalTokens(_ctfAddress);\r\n    }\r\n\r\n    /**\r\n        @dev Executes a proposal for Solutions where on the *hash* of solver configs is stored on-chain\r\n        @param proposalId ID of proposal\r\n        @param solverConfigs Configurations of Solvers to be run for the proposed solution\r\n     */\r\n    function executeIPFSProposal(\r\n        bytes32 proposalId,\r\n        SolverLib.Config[] calldata solverConfigs\r\n    ) external {\r\n        require(\r\n            proposals[proposalId].funding >= proposals[proposalId].fundingGoal,\r\n            \"Proposal not fully funded\"\r\n        );\r\n        require(\r\n            proposals[proposalId].isExecuted == false,\r\n            \"ProposalsHub::Proposal already executed\"\r\n        );\r\n\r\n        proposals[proposalId].isExecuted = true;\r\n\r\n        IIPFSSolutionsHub(proposals[proposalId].solutionsHub).executeSolution(\r\n            proposalId,\r\n            proposals[proposalId].solutionId,\r\n            solverConfigs\r\n        );\r\n\r\n        emit ExecuteProposal(proposalId);\r\n    }\r\n\r\n    /**\r\n        @dev Called by SolutionsHub after deploying Solvers\r\n        @param proposalId Proposal that collateral is being transferred from\r\n        @param solver Solver receiving collateral\r\n     */\r\n    function transferERC20(bytes32 proposalId, address solver) external {\r\n        require(\r\n            msg.sender == proposals[proposalId].solutionsHub,\r\n            \"msg.sender not solutionsHub\"\r\n        );\r\n        require(solver != address(0), \"Invalid address\");\r\n        require(\r\n            IIPFSSolutionsHub(proposals[proposalId].solutionsHub)\r\n                .solverFromIndex(proposals[proposalId].solutionId, 0) == solver,\r\n            \"Incorrect solver address\"\r\n        );\r\n\r\n        IERC20 _token = IERC20(proposals[proposalId].collateralToken);\r\n        uint256 beforeBalance = _token.balanceOf(address(this));\r\n        _token.safeTransfer(solver, proposals[proposalId].funding);\r\n        require(\r\n            beforeBalance - _token.balanceOf(address(this)) ==\r\n                proposals[proposalId].fundingGoal,\r\n            \"Incorrect balance after transfer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n        @dev Creates a Proposal from an existing Solution.Base\r\n        @param collateralToken ERC20 token being used as collateral for conditional tokens\r\n        @param solutionsHub Address of the SolutionsHub contract managing the Solution\r\n        @param fundingGoal Amount of ERC20 collateral requested for the Proposal\r\n        @param safeBaseId ID of the Solution.Base for which a new instance and proposal is created\r\n        @notice Ceramic Interop: safeBaseId == keccak256(abi.encode(keccak256(abi.encode(templateCommitID, proposalCommitID)), nonce))\r\n    */\r\n    function createProposal(\r\n        IERC20 collateralToken,\r\n        address solutionsHub,\r\n        uint256 fundingGoal,\r\n        bytes32 safeBaseId,\r\n        SolverLib.Config[] memory solverConfigs,\r\n        string calldata metadataURI\r\n    ) public returns (bytes32 solutionId, bytes32 proposalId) {\r\n        require(\r\n            IIPFSSolutionsHub(solutionsHub).verifyHash(\r\n                safeBaseId,\r\n                solverConfigs\r\n            ),\r\n            \"Incorrect Solver Configs\"\r\n        );\r\n\r\n        nonces[safeBaseId]++; // Prevents DOS by frontrunning safeBaseId\r\n\r\n        proposalId = keccak256(\r\n            abi.encode(safeBaseId, metadataURI, nonces[safeBaseId])\r\n        );\r\n\r\n        solutionId = IIPFSSolutionsHub(solutionsHub).createInstance(safeBaseId);\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n        proposal.id = proposalId;\r\n\r\n        IIPFSSolutionsHub(solutionsHub).linkToProposal(\r\n            proposalId,\r\n            solutionId,\r\n            collateralToken\r\n        );\r\n\r\n        proposal.collateralToken = collateralToken;\r\n        proposal.proposer = msg.sender;\r\n        proposal.solutionsHub = solutionsHub;\r\n        proposal.solutionId = solutionId;\r\n        proposal.fundingGoal = fundingGoal;\r\n        proposal.metadataURI = metadataURI;\r\n\r\n        emit CreateProposal(proposalId);\r\n\r\n        return (solutionId, proposalId);\r\n    }\r\n\r\n    function createIPFSSolutionAndProposal(\r\n        bytes32 baseId,\r\n        IERC20 collateralToken,\r\n        IIPFSSolutionsHub ipfsSolutionsHub,\r\n        uint256 fundingGoal,\r\n        SolverLib.Config[] calldata solverConfigs,\r\n        string calldata solverConfigsURI,\r\n        string calldata metadataURI\r\n    ) external returns (bytes32 solutionId, bytes32 proposalId) {\r\n        bytes32 safeBaseId = ipfsSolutionsHub.createBase(\r\n            baseId,\r\n            collateralToken,\r\n            solverConfigs,\r\n            solverConfigsURI\r\n        );\r\n\r\n        (solutionId, proposalId) = createProposal(\r\n            collateralToken,\r\n            address(ipfsSolutionsHub),\r\n            fundingGoal,\r\n            safeBaseId,\r\n            solverConfigs,\r\n            metadataURI\r\n        );\r\n    }\r\n\r\n    /**\r\n        @dev Called by user to add funding to a Proposal\r\n        @param proposalId ID of Proposal being funded\r\n        @param token ERC20 token to be funded with\r\n        @param amount Amount to be funded\r\n    */\r\n    function fundProposal(\r\n        bytes32 proposalId,\r\n        IERC20 token,\r\n        uint256 amount\r\n    ) external {\r\n        require(proposals[proposalId].id != 0, \"Proposal does not exist\");\r\n        require(\r\n            proposals[proposalId].isExecuted == false,\r\n            \"ProposalsHub::Proposal already executed\"\r\n        );\r\n        require(\r\n            proposals[proposalId].collateralToken == token,\r\n            \"Proposal does not include this token to be funded\"\r\n        );\r\n        require(amount > 0, \"Amount cannot be zero\");\r\n        require(\r\n            amount + proposals[proposalId].funding <=\r\n                proposals[proposalId].fundingGoal,\r\n            \"Can't fund more than goal\"\r\n        );\r\n\r\n        uint256 beforeBalance = token.balanceOf(address(this));\r\n        token.safeTransferFrom(msg.sender, address(this), amount);\r\n        require(\r\n            token.balanceOf(address(this)) - beforeBalance == amount,\r\n            \"Incorrect balance after transfer\"\r\n        );\r\n\r\n        proposals[proposalId].funding += amount;\r\n        funderAmountMap[proposalId][msg.sender] += amount;\r\n\r\n        emit FundProposal(proposalId, amount, msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev Called by user to remove their funding from a Proposal\r\n        @param proposalId ID of Proposal being defunded\r\n        @param token ERC20 token to be defunded\r\n        @param amount Amount to be defunded\r\n    */\r\n    function defundProposal(\r\n        bytes32 proposalId,\r\n        IERC20 token,\r\n        uint256 amount\r\n    ) external {\r\n        require(proposals[proposalId].id != 0, \"Proposal does not exist\");\r\n        require(\r\n            proposals[proposalId].isExecuted == false,\r\n            \"ProposalsHub::Proposal already executed\"\r\n        );\r\n        require(\r\n            proposals[proposalId].collateralToken == token,\r\n            \"Proposal does not include this token to be funded\"\r\n        );\r\n        require(amount > 0, \"Amount cannot be zero\");\r\n        require(\r\n            amount <= funderAmountMap[proposalId][msg.sender],\r\n            \"Committed funds is lower than amount.\"\r\n        );\r\n        uint256 beforeBalance = token.balanceOf(address(this));\r\n\r\n        proposals[proposalId].funding -= amount;\r\n        funderAmountMap[proposalId][msg.sender] -= amount;\r\n\r\n        token.safeTransfer(msg.sender, amount);\r\n\r\n        require(\r\n            beforeBalance - token.balanceOf(address(this)) == amount,\r\n            \"Before and after balance wrong\"\r\n        );\r\n\r\n        emit DefundProposal(proposalId, amount, msg.sender);\r\n    }\r\n\r\n    function getProposal(bytes32 id)\r\n        external\r\n        view\r\n        returns (Proposal memory proposal)\r\n    {\r\n        return proposals[id];\r\n    }\r\n\r\n    function getMetadataCID(bytes32 id) external view returns (string memory) {\r\n        return proposals[id].metadataURI;\r\n    }\r\n\r\n    function isProposal(bytes32 id) external view returns (bool) {\r\n        return proposals[id].id != bytes32(0);\r\n    }\r\n\r\n    /**\r\n        @dev Called when contract receives ERC1155 with data referring to a proposalId\r\n        @param proposalId ID of proposal being referred to by tx\r\n        @param tokenId ID of ERC1155 token that was received\r\n        @param amount Amount of token received\r\n     */\r\n    function postReclaimableTokens(\r\n        bytes32 proposalId,\r\n        uint256 tokenId,\r\n        uint256 amount\r\n    ) private {\r\n        reclaimableTokens[proposalId][tokenId] += amount;\r\n    }\r\n\r\n    /**\r\n        @dev Transfers reclaimable CTs to a claimer and lowers their reclaimable balance for that token\r\n        @param proposalId ID of proposal being reclaimed from\r\n        @param tokenId ERC1155 token being reclaimed\r\n     */\r\n    function reclaimTokens(bytes32 proposalId, uint256 tokenId) external {\r\n        require(\r\n            funderAmountMap[proposalId][msg.sender] > 0,\r\n            \"ProposalsHub::msg.sender has no claim\"\r\n        );\r\n        uint256 _claimDenominator = proposals[proposalId].funding /\r\n            funderAmountMap[proposalId][msg.sender];\r\n\r\n        uint256 _claimAmount = (reclaimableTokens[proposalId][tokenId] /\r\n            _claimDenominator) - reclaimedTokens[tokenId][msg.sender];\r\n        require(_claimAmount > 0, \"ProposalsHub::Claim is 0\");\r\n        require(\r\n            _claimAmount <= reclaimableTokens[proposalId][tokenId],\r\n            \"ProposalsHub::Claim is too large\"\r\n        );\r\n        reclaimedTokens[tokenId][msg.sender] += _claimAmount;\r\n\r\n        conditionalTokens.safeTransferFrom(\r\n            address(this),\r\n            msg.sender,\r\n            tokenId,\r\n            _claimAmount,\r\n            abi.encode(proposalId)\r\n        );\r\n    }\r\n\r\n    /** \r\n        IMPORTANT!\r\n        Any CTs sent to this contract are reclaimable by the funders in proportion to their funding.\r\n        If a user reclaims CTs and sends them back again to this contract, they will only be able to \r\n        regain from them a fraction of their original funding.\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external virtual override returns (bytes4) {\r\n        bytes32 _proposalId = abi.decode(data, (bytes32));\r\n        require(\r\n            proposals[_proposalId].id == _proposalId,\r\n            \"ProposalsHub::Data is not valid proposalId\"\r\n        );\r\n        require(\r\n            proposals[_proposalId].isExecuted,\r\n            \"ProposalsHub::Proposal has not been executed\"\r\n        );\r\n        postReclaimableTokens(_proposalId, id, value);\r\n\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external virtual override returns (bytes4) {\r\n        bytes32 _proposalId = abi.decode(data, (bytes32));\r\n        require(\r\n            proposals[_proposalId].id == _proposalId,\r\n            \"ProposalsHub::Data is not valid proposalId\"\r\n        );\r\n        require(\r\n            proposals[_proposalId].isExecuted,\r\n            \"ProposalsHub::Proposal has not been executed\"\r\n        );\r\n        for (uint256 i; i < ids.length; i++) {\r\n            postReclaimableTokens(_proposalId, ids[i], values[i]);\r\n        }\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IIPFSSolutionsHub.sol": {
      "content": "pragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../hubs/IPFSSolutionsHub.sol\";\r\nimport \"../solvers/SolverLib.sol\";\r\n\r\ninterface IIPFSSolutionsHub {\r\n    function createBase(\r\n        bytes32 baseId,\r\n        IERC20 collateralToken,\r\n        SolverLib.Config[] calldata solverConfigs,\r\n        string calldata solverConfigsURI\r\n    ) external returns (bytes32 safeBaseId);\r\n\r\n    function createInstance(bytes32 baseId)\r\n        external\r\n        returns (bytes32 solutionId);\r\n\r\n    function createSolution(\r\n        bytes32 _id,\r\n        IERC20 _collateralToken,\r\n        SolverLib.Config[] calldata _solverConfigs,\r\n        string calldata _solverConfigsURI\r\n    ) external returns (bytes32 _solutionId);\r\n\r\n    function linkToProposal(\r\n        bytes32 proposalId,\r\n        bytes32 solutionId,\r\n        IERC20 collateralToken\r\n    ) external;\r\n\r\n    function executeSolution(\r\n        bytes32 _proposalId,\r\n        bytes32 _solutionId,\r\n        SolverLib.Config[] calldata solverConfigs\r\n    ) external;\r\n\r\n    function solverFromIndex(bytes32 _solutionId, uint256 _solverIndex)\r\n        external\r\n        view\r\n        returns (address solver);\r\n\r\n    function getSolvers(bytes32 _solutionId)\r\n        external\r\n        view\r\n        returns (address[] memory solvers);\r\n\r\n    function verifyHash(\r\n        bytes32 solutionId,\r\n        SolverLib.Config[] memory solverConfigs\r\n    ) external view returns (bool);\r\n\r\n    function getSolution(bytes32 id)\r\n        external\r\n        view\r\n        returns (IPFSSolutionsHub.Solution memory);\r\n}\r\n"
    },
    "contracts/hubs/IPFSSolutionsHub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../interfaces/ISolverFactory.sol\";\r\nimport \"../interfaces/IProposalsHub.sol\";\r\nimport \"../solvers/Solver.sol\";\r\nimport \"../solvers/SolverLib.sol\";\r\n\r\ncontract IPFSSolutionsHub {\r\n    mapping(bytes32 => uint256) public nonces;\r\n\r\n    ISolverFactory immutable solverFactory;\r\n    IProposalsHub immutable proposalsHub;\r\n\r\n    struct Base {\r\n        IERC20 collateralToken;\r\n        bytes32 id;\r\n        bytes32 solverConfigsHash;\r\n        string solverConfigsURI;\r\n    }\r\n\r\n    struct Instance {\r\n        bool executed;\r\n        bytes32 id;\r\n        bytes32 baseId;\r\n        address[] solverAddresses;\r\n    }\r\n\r\n    struct Solution {\r\n        bool executed;\r\n        IERC20 collateralToken;\r\n        address proposalsHub;\r\n        bytes32 proposalId;\r\n        bytes32 id;\r\n        bytes32 solverConfigsHash;\r\n        string solverConfigsURI;\r\n        address[] solverAddresses;\r\n    }\r\n\r\n    mapping(bytes32 => Base) public bases;\r\n    mapping(bytes32 => Instance) public instances;\r\n\r\n    mapping(bytes32 => bytes32) public instanceId_to_ProposalId;\r\n\r\n    event CreateBase(bytes32 id);\r\n    event CreateSolution(bytes32 id);\r\n    event ExecuteSolution(bytes32 id);\r\n    event ErrorNotHandled(bytes reason);\r\n\r\n    constructor(\r\n        ISolverFactory factoryAddress,\r\n        IProposalsHub proposalsHubAddress\r\n    ) {\r\n        solverFactory = factoryAddress;\r\n        proposalsHub = proposalsHubAddress;\r\n    }\r\n\r\n    function linkToProposal(\r\n        bytes32 proposalId,\r\n        bytes32 solutionId,\r\n        IERC20 collateralToken\r\n    ) external {\r\n        require(\r\n            proposalsHub.isProposal(proposalId),\r\n            \"Proposal is not valid at proposalsHub\"\r\n        );\r\n        require(\r\n            bases[instances[solutionId].baseId].collateralToken ==\r\n                collateralToken,\r\n            \"Wrong collateral token\"\r\n        );\r\n\r\n        instanceId_to_ProposalId[solutionId] = proposalId;\r\n    }\r\n\r\n    function deploySolverChain(\r\n        bytes32 _solutionId,\r\n        SolverLib.Config[] calldata solverConfigs\r\n    ) private {\r\n        address _solverAddress;\r\n\r\n        for (uint256 i; i < solverConfigs.length; i++) {\r\n            if (i == 0) {\r\n                _solverAddress = solverFactory.createSolver(\r\n                    address(0),\r\n                    i,\r\n                    solverConfigs[i]\r\n                );\r\n\r\n                require(\r\n                    _solverAddress != address(0),\r\n                    \"Invalid address for Solver\"\r\n                );\r\n            } else {\r\n                _solverAddress = Solver(_solverAddress).deployChild(\r\n                    solverConfigs[i]\r\n                );\r\n            }\r\n            instances[_solutionId].solverAddresses.push(_solverAddress);\r\n        }\r\n    }\r\n\r\n    // Ceramic Interop: baseId == keccak256(abi.encode(templateCommitID, proposalCommitID))\r\n    function createBase(\r\n        bytes32 baseId,\r\n        IERC20 collateralToken,\r\n        SolverLib.Config[] calldata solverConfigs,\r\n        string calldata solverConfigsURI\r\n    ) public returns (bytes32 safeBaseId) {\r\n        nonces[baseId]++;\r\n        safeBaseId = keccak256(abi.encode(baseId, nonces[baseId]));\r\n\r\n        require(bases[safeBaseId].id != safeBaseId, \"Base ID already exists\");\r\n\r\n        Base storage base = bases[safeBaseId];\r\n        base.id = safeBaseId;\r\n        base.collateralToken = collateralToken;\r\n        base.solverConfigsHash = keccak256(abi.encode(solverConfigs));\r\n        base.solverConfigsURI = solverConfigsURI;\r\n        emit CreateBase(safeBaseId);\r\n    }\r\n\r\n    function createInstance(bytes32 baseId)\r\n        public\r\n        returns (bytes32 solutionId)\r\n    {\r\n        nonces[baseId]++;\r\n\r\n        bytes32 instanceId = keccak256(\r\n            abi.encode(baseId, nonces[baseId], blockhash(block.number - 1))\r\n        );\r\n        require(\r\n            instances[instanceId].id != instanceId,\r\n            \"Instance ID already exists\"\r\n        );\r\n        require(bases[baseId].id != bytes32(\"\"), \"Base not found\");\r\n\r\n        Instance storage instance = instances[instanceId];\r\n        instance.id = instanceId;\r\n        instance.baseId = baseId;\r\n\r\n        emit CreateSolution(instanceId);\r\n        return instanceId;\r\n    }\r\n\r\n    function createSolution(\r\n        bytes32 baseId,\r\n        IERC20 collateralToken,\r\n        SolverLib.Config[] calldata solverConfigs,\r\n        string calldata solverConfigsURI\r\n    ) public returns (bytes32 instanceId) {\r\n        require(\r\n            instances[instanceId].id != instanceId,\r\n            \"SolutionsHub::Instance ID already exists\"\r\n        );\r\n        createBase(baseId, collateralToken, solverConfigs, solverConfigsURI);\r\n        instanceId = createInstance(baseId);\r\n\r\n        emit CreateSolution(instanceId);\r\n    }\r\n\r\n    function executeSolution(\r\n        bytes32 proposalId,\r\n        bytes32 solutionId,\r\n        SolverLib.Config[] calldata solverConfigs\r\n    ) external {\r\n        require(\r\n            verifyHash(instances[solutionId].baseId, solverConfigs),\r\n            \"Incorrect SolverConfig content\"\r\n        );\r\n        require(\r\n            msg.sender == address(proposalsHub),\r\n            \"Not correct proposalsHub\"\r\n        );\r\n        require(\r\n            instanceId_to_ProposalId[solutionId] == proposalId,\r\n            \"Wrong proposalId\"\r\n        );\r\n        require(\r\n            instances[solutionId].executed == false,\r\n            \"Solution already executed\"\r\n        );\r\n\r\n        instances[solutionId].executed = true;\r\n\r\n        deploySolverChain(solutionId, solverConfigs);\r\n\r\n        IProposalsHub(msg.sender).transferERC20(\r\n            proposalId,\r\n            instances[solutionId].solverAddresses[0]\r\n        );\r\n\r\n        for (uint256 i; i < instances[solutionId].solverAddresses.length; i++) {\r\n            ISolver _solver = ISolver(instances[solutionId].solverAddresses[i]);\r\n            _solver.setTrackingId(instanceId_to_ProposalId[solutionId]);\r\n        }\r\n        // Prepare first Solver\r\n        ISolver(instances[solutionId].solverAddresses[0]).prepareSolve(0);\r\n\r\n        if (\r\n            ISolver(instances[solutionId].solverAddresses[0]).ingestsValid() &&\r\n            ISolver(instances[solutionId].solverAddresses[0]).allocationsValid(\r\n                0\r\n            )\r\n        ) {\r\n            ISolver(instances[solutionId].solverAddresses[0]).executeSolve(0);\r\n        }\r\n\r\n        emit ExecuteSolution(solutionId);\r\n    }\r\n\r\n    function verifyHash(bytes32 baseId, SolverLib.Config[] memory solverConfigs)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            bases[baseId].solverConfigsHash ==\r\n            keccak256(abi.encode(solverConfigs));\r\n    }\r\n\r\n    function solverFromIndex(bytes32 solutionId, uint256 index)\r\n        public\r\n        view\r\n        returns (address solverAddress)\r\n    {\r\n        if (instances[solutionId].solverAddresses.length > 0) {\r\n            return instances[solutionId].solverAddresses[index];\r\n        } else {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    function getSolvers(bytes32 solutionId)\r\n        public\r\n        view\r\n        returns (address[] memory solvers)\r\n    {\r\n        solvers = instances[solutionId].solverAddresses;\r\n    }\r\n\r\n    function getSolution(bytes32 instanceId)\r\n        public\r\n        view\r\n        returns (Solution memory solution)\r\n    {\r\n        Instance memory instance = instances[instanceId];\r\n        Base memory base = bases[instance.baseId];\r\n\r\n        solution.id = instance.id;\r\n        solution.executed = instance.executed;\r\n        solution.collateralToken = base.collateralToken;\r\n        solution.proposalId = instanceId_to_ProposalId[instanceId];\r\n        solution.solverConfigsHash = base.solverConfigsHash;\r\n        solution.solverConfigsURI = base.solverConfigsURI;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/modules/arbitration/Arbitrator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\n\r\nimport \"../../interfaces/ISolver.sol\";\r\n\r\nabstract contract Arbitrator {\r\n    function requestArbitration(ISolver solver, uint256 conditionIndex)\r\n        external\r\n        payable\r\n        virtual\r\n    {\r\n        _requestArbitration(solver, conditionIndex);\r\n    }\r\n\r\n    function arbitrateNull(ISolver solver, uint256 conditionIndex)\r\n        external\r\n        virtual\r\n    {\r\n        _arbitrateNull(solver, conditionIndex);\r\n    }\r\n\r\n    function arbitrate(\r\n        ISolver solver,\r\n        uint256 conditionIndex,\r\n        uint256[] memory outcomes\r\n    ) external virtual {\r\n        _arbitrate(solver, conditionIndex, outcomes);\r\n    }\r\n\r\n    function _requestArbitration(ISolver solver, uint256 conditionIndex)\r\n        internal\r\n    {\r\n        solver.requestArbitration(conditionIndex);\r\n    }\r\n\r\n    function _arbitrateNull(ISolver solver, uint256 conditionIndex) internal {\r\n        solver.arbitrateNull(conditionIndex);\r\n    }\r\n\r\n    function _arbitrate(\r\n        ISolver solver,\r\n        uint256 conditionIndex,\r\n        uint256[] memory outcomes\r\n    ) internal {\r\n        solver.arbitrate(conditionIndex, outcomes);\r\n    }\r\n}\r\n"
    },
    "contracts/arbitration/BasicArbitrator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\r\npragma solidity ^0.8.14;\r\n\r\nimport \"../interfaces/ISolver.sol\";\r\nimport \"../interfaces/IArbitratorFactory.sol\";\r\nimport \"../solvers/SolverLib.sol\";\r\nimport \"../modules/arbitration/Arbitrator.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\ncontract BasicArbitrator is\r\n    Arbitrator,\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    ReentrancyGuard\r\n{\r\n    struct Dispute {\r\n        ISolver solver;\r\n        uint256 conditionIndex;\r\n        uint256 fee;\r\n        uint256 lapse;\r\n        bytes32 id;\r\n        address[] disputers;\r\n        uint256[][] choices;\r\n    }\r\n\r\n    IArbitratorFactory private arbitratorFactory; // Set during init\r\n\r\n    uint256 public fee; // wei\r\n    uint256 public lapse; // Seconds after timelock ends when a Dispute is considered to have \"lapsed\"\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(bytes32 => Dispute) private disputes; // keccak256(abi.encode(address solver, conditionIndex)) => Dispute\r\n\r\n    event Withdrawal(address indexed to, uint256 amount);\r\n\r\n    modifier isRequested(bytes32 disputeId) {\r\n        Dispute storage dispute = disputes[disputeId];\r\n\r\n        require(dispute.id != bytes32(\"\"), \"Invalid Dispute\");\r\n\r\n        require(\r\n            dispute.solver.getStatus(dispute.conditionIndex) ==\r\n                SolverLib.Status.ArbitrationRequested,\r\n            \"Arbitration not requested\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Recommended disabling of initializers on implementation contract. Not called by clones.\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    /**\r\n     * @notice Sets fee and immediately transfers ownership to _newOwner\r\n     * @param initParams bytearray of init parameters\r\n     * @dev initializer\r\n     * @dev _newOwner | Address to immediately transfer ownership to\r\n     * @dev _fee | Arbitration fee (per disputer) in wei\r\n     * @dev _lapse | Seconds after timelock ends when a Dispute is considered to have \"lapsed\"\r\n     */\r\n    function init(bytes calldata initParams) external initializer {\r\n        (address _newOwner, uint256 _fee, uint256 _lapse) = abi.decode(\r\n            initParams,\r\n            (address, uint256, uint256)\r\n        );\r\n        arbitratorFactory = IArbitratorFactory(msg.sender);\r\n        fee = _fee;\r\n        lapse = _lapse;\r\n\r\n        __Ownable_init();\r\n        transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice If Dispute already exists, returns the fee from when was created. Else, the current fee\r\n     * @param solver Solver address\r\n     * @param conditionIndex Condition index\r\n     */\r\n    function getFee(ISolver solver, uint256 conditionIndex)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        bytes32 disputeId = keccak256(abi.encode(solver, conditionIndex));\r\n        if (disputes[disputeId].id != bytes32(\"\")) {\r\n            // Dispute exists\r\n            return disputes[disputeId].fee;\r\n        } else {\r\n            return fee;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set a new arbitration fee. Does not affect active Disputes\r\n     * @dev onlyOwner\r\n     * @param _fee New fee in wei\r\n     */\r\n    function setFee(uint256 _fee) external onlyOwner {\r\n        fee = _fee;\r\n    }\r\n\r\n    /**\r\n     * @notice Set a new lapse duration. Does not affect active Disputes\r\n     * @dev onlyOwner\r\n     * @param _lapse New lapse in seconds\r\n     */\r\n    function setLapse(uint256 _lapse) external onlyOwner {\r\n        require(_lapse > 0, \"Lapse cannot be 0 days\");\r\n        lapse = _lapse;\r\n    }\r\n\r\n    /**\r\n     * @notice Add additional lapse duration to an active dispute\r\n     * @dev onlyOwner\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     * @param extraTime Additional lapse in seconds\r\n     */\r\n    function extendLapse(bytes32 disputeId, uint256 extraTime)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(disputes[disputeId].id != bytes32(\"\"), \"Invalid dispute\");\r\n        disputes[disputeId].lapse += extraTime;\r\n    }\r\n\r\n    /**\r\n     * @notice True when a dispute has lapsed\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     */\r\n    function isLapsed(bytes32 disputeId) public view returns (bool) {\r\n        return\r\n            block.timestamp >\r\n            (disputes[disputeId].lapse + getTimelock(disputeId));\r\n    }\r\n\r\n    /**\r\n     * @notice Receives an arbitration request from a disputer\r\n     * @dev Callable only during Solver timelock\r\n     * @dev Only callable by recipients of the Solver condition\r\n     * @dev Only callable while Solver condition is Status.OutcomeProposed or Status.ArbitrationRequested\r\n     * @param solver Address of solver\r\n     * @param conditionIndex Index of condition for which arbitration is being requested\r\n     * @param outcomes Outcome report being requested by the disputer\r\n     */\r\n    function requestArbitration(\r\n        ISolver solver,\r\n        uint256 conditionIndex,\r\n        uint256[] calldata outcomes\r\n    ) external payable {\r\n        address _arbitrator = solver.arbitrator();\r\n\r\n        require(_arbitrator == address(this), \"Wrong arbitrator\");\r\n\r\n        require(\r\n            solver.isRecipient(msg.sender, conditionIndex),\r\n            \"Only recipients\"\r\n        );\r\n\r\n        SolverLib.Status status = solver.getStatus(conditionIndex);\r\n\r\n        require(\r\n            status == SolverLib.Status.OutcomeProposed ||\r\n                status == SolverLib.Status.ArbitrationRequested,\r\n            \"Condition status invalid for arbitration\"\r\n        );\r\n\r\n        require(\r\n            block.timestamp < solver.timelocks(conditionIndex),\r\n            \"Timelock elapsed\"\r\n        );\r\n\r\n        bytes32 _disputeId = keccak256(abi.encode(solver, conditionIndex));\r\n\r\n        require(\r\n            msg.value >= getFee(solver, conditionIndex),\r\n            \"Insufficient fee\"\r\n        );\r\n        balances[msg.sender] += msg.value - fee; // Refund the difference to msg.sender's balance\r\n\r\n        Dispute storage dispute = disputes[_disputeId];\r\n\r\n        // Create Dispute if it doesn't exist\r\n        if (dispute.id == bytes32(\"\")) {\r\n            dispute.id = _disputeId;\r\n            dispute.solver = solver;\r\n            dispute.conditionIndex = conditionIndex;\r\n            dispute.fee = fee;\r\n            dispute.lapse = lapse;\r\n\r\n            // First Disputer is the Keeper\r\n            dispute.disputers.push(solver.keeper());\r\n\r\n            //  First Choice is the disputed payouts\r\n            SolverLib.Condition memory condition = solver.condition(\r\n                conditionIndex\r\n            );\r\n            dispute.choices.push(condition.payouts);\r\n        }\r\n\r\n        dispute.disputers.push(msg.sender);\r\n        dispute.choices.push(outcomes);\r\n        _requestArbitration(solver, conditionIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Deliver a null arbitration. Resets disputes and choices to empty arrays and reimburses disputers\r\n     * @dev Callable on any active dispute\r\n     * @dev onlyOwner\r\n     * @dev isRequested\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     */\r\n    function arbitrateNull(bytes32 disputeId)\r\n        public\r\n        onlyOwner\r\n        isRequested(disputeId)\r\n    {\r\n        Dispute storage dispute = disputes[disputeId];\r\n\r\n        _arbitrateNull(dispute.solver, dispute.conditionIndex);\r\n\r\n        reimburse(disputeId);\r\n\r\n        // Delete disputers & choices (AFTER reimburse)\r\n        delete dispute.disputers;\r\n        delete dispute.choices;\r\n    }\r\n\r\n    /**\r\n     * @notice Deliver arbitration\r\n     * @dev Callable only when timelock has passed\r\n     * @dev onlyOwner\r\n     * @dev isRequested\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     * @param choice index of the chosen desiredOutcome from dispute.choices\r\n     */\r\n    function arbitrate(bytes32 disputeId, uint256 choice)\r\n        public\r\n        onlyOwner\r\n        isRequested(disputeId)\r\n    {\r\n        Dispute storage dispute = disputes[disputeId];\r\n        require(dispute.id == disputeId, \"Invalid Dispute\");\r\n\r\n        require(\r\n            block.timestamp > dispute.solver.timelocks(dispute.conditionIndex),\r\n            \"Timelocked\"\r\n        );\r\n\r\n        _arbitrate(\r\n            dispute.solver,\r\n            dispute.conditionIndex,\r\n            dispute.choices[choice]\r\n        );\r\n\r\n        imburse(disputeId, choice);\r\n    }\r\n\r\n    /**\r\n     * @notice Delivers arbitration as the Keeper's proposed report and refunds all disputers who requested arbitration\r\n     * @dev Callable when a dispute has lapsed. Also hides this arbitrator in ArbitratorFactory\r\n     * @dev isRequested\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     */\r\n    function claimLapse(bytes32 disputeId) external isRequested(disputeId) {\r\n        Dispute memory dispute = disputes[disputeId];\r\n\r\n        require(isLapsed(disputeId), \"Not lapsed\");\r\n\r\n        SolverLib.Condition memory condition = disputes[disputeId]\r\n            .solver\r\n            .condition(dispute.conditionIndex);\r\n\r\n        _arbitrate(dispute.solver, dispute.conditionIndex, condition.payouts);\r\n        reimburse(disputeId);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds withdrawal balance to the arbitrator and disputers whose choice matched the arbitrator's ruling\r\n     * @dev Arbitrator must select from disputed choices\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     * @param choice index of the chosen desiredOutcome from dispute.choices\r\n     */\r\n    function imburse(bytes32 disputeId, uint256 choice) private {\r\n        Dispute storage dispute = disputes[disputeId];\r\n\r\n        // Skip first disputer/choice, they are automatically the Keeper/proposed payouts\r\n        uint256 remainingFee = dispute.fee * (dispute.disputers.length - 1);\r\n        for (uint256 i = 1; i < dispute.disputers.length; i++) {\r\n            if (\r\n                keccak256(abi.encode(dispute.choices[i])) ==\r\n                keccak256(abi.encode(dispute.choices[choice]))\r\n            ) {\r\n                balances[dispute.disputers[i]] += dispute.fee;\r\n                remainingFee -= dispute.fee;\r\n            }\r\n        }\r\n\r\n        balances[owner()] += remainingFee;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds withdrawal balance to all disputers\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     */\r\n    function reimburse(bytes32 disputeId) private {\r\n        Dispute storage dispute = disputes[disputeId];\r\n\r\n        // Skip first disputer/choice, they are automatically the Keeper/proposed payouts\r\n        for (uint256 i = 1; i < dispute.disputers.length; i++) {\r\n            balances[dispute.disputers[i]] += dispute.fee;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets timelock of the condition being disputed\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     */\r\n    function getTimelock(bytes32 disputeId)\r\n        public\r\n        view\r\n        returns (uint256 timelock)\r\n    {\r\n        timelock = disputes[disputeId].solver.timelocks(\r\n            disputes[disputeId].conditionIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Dispute getter\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionIndex))\r\n     */\r\n    function getDispute(bytes32 disputeId)\r\n        public\r\n        view\r\n        returns (Dispute memory dispute)\r\n    {\r\n        dispute = disputes[disputeId];\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws ETH and reduces balance of msg.sender\r\n     * @dev nonReentrant\r\n     */\r\n    function withdraw() external nonReentrant {\r\n        require(balances[msg.sender] > 0, \"No balance\");\r\n        uint256 balance = balances[msg.sender];\r\n        balances[msg.sender] -= balance;\r\n        (bool success, bytes memory ret) = msg.sender.call{value: balance}(\"\");\r\n        require(success, \"Transfer failed\");\r\n\r\n        emit Withdrawal(msg.sender, balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Increases current owner's balance\r\n     */\r\n    receive() external payable {\r\n        balances[owner()] += msg.value;\r\n    }\r\n\r\n    // Overrides\r\n    function requestArbitration(ISolver solver, uint256 conditionIndex)\r\n        external\r\n        payable\r\n        override\r\n    {\r\n        solver;\r\n        conditionIndex;\r\n        revert(\r\n            \"Call requestArbitration(bytes32 disputeId, uint256 choice) instead\"\r\n        );\r\n    }\r\n\r\n    // Overrides\r\n    function arbitrate(\r\n        ISolver solver,\r\n        uint256 conditionIndex,\r\n        uint256[] memory outcomes\r\n    ) external pure override {\r\n        solver;\r\n        conditionIndex;\r\n        outcomes;\r\n        revert(\"Call arbitrate(bytes32 disputeId, uint256 choice) instead\");\r\n    }\r\n\r\n    // Overrides\r\n    function arbitrateNull(ISolver solver, uint256 conditionIndex)\r\n        external\r\n        pure\r\n        override\r\n    {\r\n        solver;\r\n        conditionIndex;\r\n        revert(\"Call arbitrateNull(bytes32 disputeId) instead\");\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IArbitratorFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ninterface IArbitratorFactory {\r\n    function enableImplementation(address implementation) external;\r\n\r\n    function disableImplementation(address implementation) external;\r\n\r\n    function createArbitrator(address implementation, bytes calldata initParams)\r\n        external;\r\n\r\n    function hideArbitrator() external;\r\n\r\n    function unhideArbitrator() external;\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/solvers/SolverFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./Solver.sol\";\r\nimport \"./SolverLib.sol\";\r\n\r\ncontract SolverFactory {\r\n    address public immutable ctf;\r\n    address public immutable erc1155Rescue;\r\n\r\n    address[] public solvers;\r\n\r\n    event SolverCreated(address newSolverAddress);\r\n\r\n    constructor(address _ctf, address _erc1155Rescue) {\r\n        ctf = _ctf;\r\n        erc1155Rescue = _erc1155Rescue;\r\n    }\r\n\r\n    /**\r\n        @notice Deploys Solver clone and calls init function\r\n        @param chainParent Parent solver, or address(0)\r\n        @param chainIndex Index of solver in its chain\r\n        @param solverConfig Solver configuration\r\n    */\r\n    function createSolver(\r\n        address chainParent,\r\n        uint256 chainIndex,\r\n        SolverLib.Config calldata solverConfig\r\n    ) external returns (address) {\r\n        require(\r\n            address(solverConfig.implementation) != address(0),\r\n            \"SolverFactory::Invalid implementation address\"\r\n        );\r\n        require(\r\n            (chainParent == address(0) && chainIndex == 0) ||\r\n                (chainParent != address(0) && chainIndex > 0),\r\n            \"SolverFactory::Invalid chain parent/index\"\r\n        );\r\n\r\n        address clone = Clones.clone(address(solverConfig.implementation));\r\n\r\n        Solver(clone).init(msg.sender, chainParent, chainIndex, solverConfig);\r\n\r\n        solvers.push(clone);\r\n\r\n        emit SolverCreated(clone);\r\n        return clone;\r\n    }\r\n}\r\n"
    },
    "contracts/arbitration/ArbitratorFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract ArbitratorFactory is Ownable {\r\n    bytes4 private constant CLONE_INIT_SELECTOR =\r\n        bytes4(keccak256(\"init(bytes)\"));\r\n\r\n    struct Arbitrator {\r\n        uint256 index;\r\n        address arbitrator;\r\n        address implementation;\r\n    }\r\n\r\n    Arbitrator[] public arbitrators; // All available arbitrators\r\n    address[] public implementations; // All implementations that have ever been allowed\r\n\r\n    mapping(address => Arbitrator) public address_to_arbitrator;\r\n\r\n    event CreatedArbitrator(\r\n        address indexed arbitrator,\r\n        address indexed implementation\r\n    );\r\n\r\n    /**\r\n     * @notice Deploys a clone of an implementation and initializes it\r\n     * @param implementation Address of the implementation contract\r\n     * @param initParams Params for the initializer function of the implementation\r\n     */\r\n    function createArbitrator(address implementation, bytes calldata initParams)\r\n        external\r\n        returns (address)\r\n    {\r\n        address clone = Clones.clone(implementation);\r\n\r\n        bytes memory data = abi.encodeWithSelector(\r\n            CLONE_INIT_SELECTOR,\r\n            initParams\r\n        );\r\n        (bool success, bytes memory retData) = clone.call{value: 0}(data);\r\n\r\n        require(success, \"Initialization call failed\");\r\n\r\n        Arbitrator memory arbitrator;\r\n        arbitrator.arbitrator = clone;\r\n        arbitrator.implementation = implementation;\r\n        arbitrator.index = arbitrators.length; // Array index for new arbitrator\r\n\r\n        // Add to arbitrators array and map\r\n        arbitrators.push(arbitrator);\r\n        address_to_arbitrator[clone] = arbitrator;\r\n\r\n        emit CreatedArbitrator(clone, implementation);\r\n        return clone;\r\n    }\r\n}\r\n"
    },
    "contracts/modules/keepers/Unanimity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"../../interfaces/ISolver.sol\";\r\n\r\nimport \"../../solvers/SolverLib.sol\";\r\n\r\nimport \"../Module.sol\";\r\n\r\ncontract Unanimity is Module {\r\n    constructor() {\r\n        permits.push(ISolver.setTimelock.selector);\r\n    }\r\n\r\n    function load(bytes calldata data) external override {\r\n        ISolver(msg.sender).setState(\r\n            STATEKEY,\r\n            abi.encode(getNumUniqueRecipients(ISolver(msg.sender)))\r\n        );\r\n        emit LoadedModule(address(this), msg.sender);\r\n    }\r\n\r\n    function approveOutcome(ISolver solver, uint256 conditionIndex)\r\n        external\r\n        returns (address[] memory approved)\r\n    {\r\n        require(\r\n            solver.isRecipient(msg.sender, conditionIndex),\r\n            \"Only recipients\"\r\n        );\r\n        require(\r\n            solver.getStatus(conditionIndex) ==\r\n                SolverLib.Status.OutcomeProposed,\r\n            \"Not proposes\"\r\n        );\r\n\r\n        uint256 numRecipients = abi.decode(\r\n            solver.getState(STATEKEY),\r\n            (uint256)\r\n        );\r\n\r\n        bytes32 APPROVERS_STATEKEY = keccak256(\r\n            abi.encode(STATEKEY, \"APPROVERS_STATEKEY\", conditionIndex)\r\n        );\r\n\r\n        address[] memory approvers;\r\n\r\n        bytes memory approverData = solver.getState(APPROVERS_STATEKEY);\r\n\r\n        if (approverData.length > 0) {\r\n            approvers = abi.decode(approverData, (address[]));\r\n        }\r\n\r\n        for (uint256 i = 0; i < approvers.length; i++) {\r\n            if (msg.sender == approvers[i]) {\r\n                revert(\"Already approved\");\r\n            }\r\n        }\r\n\r\n        if (approvers.length + 1 == numRecipients) {\r\n            solver.setTimelock(conditionIndex, 0);\r\n            solver.confirmPayouts(conditionIndex);\r\n        } else {\r\n            address[] memory newApprovers = new address[](approvers.length + 1);\r\n            for (uint256 i = 0; i < approvers.length; i++) {\r\n                newApprovers[i] = approvers[i];\r\n            }\r\n            newApprovers[approvers.length] = msg.sender;\r\n            solver.setState(APPROVERS_STATEKEY, abi.encode(newApprovers));\r\n        }\r\n\r\n        return approvers;\r\n    }\r\n\r\n    function getNumUniqueRecipients(ISolver solver)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        SolverLib.Config memory config = solver.getConfig();\r\n\r\n        bytes32[] memory recipientSlots = new bytes32[](\r\n            config.conditionBase.allocations.length\r\n        );\r\n\r\n        uint256 numDuplicates = 0;\r\n\r\n        for (uint256 i = 0; i < config.conditionBase.allocations.length; i++) {\r\n            bool duplicate = false;\r\n\r\n            for (uint256 j = 0; j < recipientSlots.length; j++) {\r\n                if (\r\n                    recipientSlots[j] ==\r\n                    config.conditionBase.allocations[i].recipientAddressSlot\r\n                ) {\r\n                    duplicate = true;\r\n                }\r\n            }\r\n\r\n            if (!duplicate) {\r\n                recipientSlots[i - numDuplicates] = (\r\n                    config.conditionBase.allocations[i].recipientAddressSlot\r\n                );\r\n            } else {\r\n                numDuplicates++;\r\n            }\r\n        }\r\n\r\n        return recipientSlots.length - numDuplicates;\r\n    }\r\n}\r\n"
    },
    "contracts/modules/keepers/Keeper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"../../interfaces/IConditionalTokens.sol\";\r\nimport \"../../interfaces/ISolver.sol\";\r\n\r\nimport \"../../interfaces/ISolver.sol\";\r\nimport \"../../solvers/SolverLib.sol\";\r\n\r\nimport \"../Module.sol\";\r\n\r\nabstract contract Keeper is Module {\r\n    function prepareSolve(address solver, uint256 conditionIndex)\r\n        public\r\n        virtual\r\n    {\r\n        ISolver(solver).prepareSolve(conditionIndex);\r\n    }\r\n\r\n    function deployChild(address solver, SolverLib.Config calldata config)\r\n        public\r\n        virtual\r\n    {\r\n        ISolver(solver).deployChild(config);\r\n    }\r\n\r\n    function executeSolve(address solver, uint256 conditionIndex)\r\n        public\r\n        virtual\r\n    {\r\n        ISolver(solver).executeSolve(conditionIndex);\r\n    }\r\n\r\n    function addData(\r\n        address solver,\r\n        bytes32 slot,\r\n        bytes memory data\r\n    ) public virtual {\r\n        ISolver(solver).addData(slot, data);\r\n    }\r\n\r\n    function proposePayouts(\r\n        address solver,\r\n        uint256 index,\r\n        uint256[] calldata payouts\r\n    ) public virtual {\r\n        ISolver(solver).proposePayouts(index, payouts);\r\n    }\r\n\r\n    function confirmPayouts(address solver, uint256 index) public virtual {\r\n        ISolver(solver).confirmPayouts(index);\r\n    }\r\n\r\n    function redeemPosition(\r\n        address solver,\r\n        IERC20 collateralToken,\r\n        bytes32 parentCollectionId,\r\n        bytes32 conditionId,\r\n        uint256[] calldata indexSets\r\n    ) public virtual {\r\n        ISolver(solver).redeemPosition(\r\n            collateralToken,\r\n            parentCollectionId,\r\n            conditionId,\r\n            indexSets\r\n        );\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(Keeper).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n"
    },
    "contracts/modules/IPFSTextSubmitter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"../solvers/SolverLib.sol\";\r\nimport \"../interfaces/ISolver.sol\";\r\nimport \"./Module.sol\";\r\n\r\ncontract IPFSTextSubmitter is Module {\r\n    event SubmittedWork(\r\n        address indexed solver,\r\n        string cid,\r\n        address submitter,\r\n        bytes32 indexed conditionId\r\n    );\r\n\r\n    function load(bytes memory data) external override {\r\n        ISolver(msg.sender).setState(STATEKEY, data);\r\n\r\n        emit LoadedModule(address(this), msg.sender);\r\n    }\r\n\r\n    function submitter(ISolver solver) public view returns (address) {\r\n        return\r\n            abi.decode(\r\n                solver.getData(bytes32(solver.getState(STATEKEY))),\r\n                (address)\r\n            );\r\n    }\r\n\r\n    function submit(\r\n        ISolver solver,\r\n        string calldata cid,\r\n        uint256 conditionIndex\r\n    ) external {\r\n        require(msg.sender == submitter(solver), \"Only Submitter\");\r\n        SolverLib.Condition memory condition = solver.condition(conditionIndex);\r\n\r\n        require(condition.status == SolverLib.Status.Executed, \"Disabled\");\r\n        emit SubmittedWork(\r\n            address(solver),\r\n            cid,\r\n            msg.sender,\r\n            condition.conditionId\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/solvers/ERC1155Rescue.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../conditionalTokens/ConditionalTokens.sol\";\r\n\r\ncontract ERC1155Rescue is ERC1155Receiver {\r\n    using SafeERC20 for IERC20;\r\n\r\n    ConditionalTokens ctf;\r\n\r\n    struct Bag {\r\n        bool rescued;\r\n        address recipient;\r\n        bytes32 id;\r\n        bytes32 trackingId;\r\n        uint256[] tokens;\r\n        uint256[] amounts;\r\n    }\r\n\r\n    mapping(bytes32 => Bag) bags;\r\n\r\n    event ReceivedBag(\r\n        bytes32 indexed id,\r\n        address indexed recipient,\r\n        uint256[] tokenIds,\r\n        uint256[] amounts\r\n    );\r\n\r\n    event RescuedBag(\r\n        bytes32 indexed id,\r\n        address indexed to,\r\n        uint256[] tokenIds,\r\n        uint256[] amounts\r\n    );\r\n\r\n    constructor(ConditionalTokens _ctf) {\r\n        ctf = _ctf;\r\n    }\r\n\r\n    function rescueBag(bytes32 bagId, address to) external {\r\n        Bag storage bag = bags[bagId];\r\n        require(\r\n            msg.sender == bag.recipient,\r\n            \"ERC1155Rescue::Only OG recipient\"\r\n        );\r\n        require(bag.id == bagId, \"ERC1155Rescue::Invalid bagId\");\r\n        require(bag.rescued == false, \"ERC1155Rescue::Rescued\");\r\n\r\n        bag.rescued = true;\r\n\r\n        ctf.safeBatchTransferFrom(\r\n            address(this),\r\n            to,\r\n            bag.tokens,\r\n            bag.amounts,\r\n            abi.encode(bag.trackingId)\r\n        );\r\n\r\n        emit RescuedBag(bagId, to, bag.tokens, bag.amounts);\r\n    }\r\n\r\n    function getBagId(\r\n        address solver,\r\n        uint256[] calldata tokenIds,\r\n        uint256[] calldata tokenAmounts\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(solver, tokenIds, tokenAmounts));\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external virtual override returns (bytes4) {\r\n        // Should only receive batch transfers from solver during `executeSolve`\r\n        require(operator == from, \"ERC1155Rescue::operator != from\");\r\n        bytes32 bagId = getBagId(from, ids, values);\r\n\r\n        Bag storage bag = bags[bagId];\r\n        require(bag.id != bagId, \"ERC1155Rescue::Bag already exists\");\r\n\r\n        bag.id = bagId;\r\n        bag.tokens = ids;\r\n        bag.amounts = values;\r\n\r\n        (bag.recipient, bag.trackingId) = abi.decode(data, (address, bytes32));\r\n\r\n        emit ReceivedBag(bagId, bag.recipient, ids, values);\r\n\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external virtual override returns (bytes4) {\r\n        operator;\r\n        from;\r\n        id;\r\n        value;\r\n        data;\r\n        revert();\r\n    }\r\n}\r\n"
    },
    "contracts/solvers/BasicSolverV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./Solver.sol\";\r\n\r\ncontract BasicSolverV1 is Solver {}\r\n"
    },
    "contracts/tokens/ToyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract ToyToken is ERC20 {\r\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\r\n\r\n    function mint(address account, uint256 amount) external {\r\n        _mint(account, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IBasicArbitrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.14;\r\nimport \"./ISolver.sol\";\r\n\r\ninterface IBasicArbitrator {\r\n    /**\r\n     * @notice Sets fee and immediately transfers ownership to _newOwner\r\n     * @param initParams bytearray of init parameters\r\n     * @dev _newOwner | Address to immediately transfer ownership to\r\n     * @dev _fee | Arbitration fee (per disputer) in wei\r\n     * @dev _lapse | Seconds after timelock ends when a Dispute is considered to have \"lapsed\"\r\n     */\r\n    function init(bytes calldata initParams) external;\r\n\r\n    /**\r\n     * @notice If Dispute already exists, returns the fee from when was created. Else, the current fee\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionId))\r\n     */\r\n    function getFee(bytes32 disputeId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Set a new arbitration fee. Does not affect active Disputes\r\n     * @dev onlyOwner\r\n     * @param _fee New fee in wei\r\n     */\r\n    function setFee(uint256 _fee) external;\r\n\r\n    /**\r\n     * @notice Set a new lapse duration. Does not affect active Disputes\r\n     * @dev onlyOwner\r\n     * @param _lapse New lapse in seconds\r\n     */\r\n\r\n    function setLapse(uint256 _lapse) external;\r\n\r\n    /**\r\n     * @notice Add additional lapse duration to an active dispute\r\n     * @dev onlyOwner\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionId))\r\n     * @param extraTime Additional lapse in seconds\r\n     */\r\n    function extendLapse(bytes32 disputeId, uint256 extraTime) external;\r\n\r\n    /**\r\n     * @notice True when a dispute has lapsed\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionId))\r\n     */\r\n    function isLapsed(bytes32 disputeId) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Receives an arbitration request from a disputer\r\n     * @dev Callable only during Solver timelock\r\n     * @dev Only callable by recipients of the Solver condition\r\n     * @dev Only callable while Solver condition is Status.OutcomeProposed or Status.ArbitrationRequested\r\n     * @param solver Address of solver\r\n     * @param conditionIndex Index of condition for which arbitration is being requested\r\n     * @param desiredOutcome Outcome report being requested by the disputer\r\n     */\r\n    function requestArbitration(\r\n        ISolver solver,\r\n        uint256 conditionIndex,\r\n        uint256[] calldata desiredOutcome\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Deliver a null arbitration\r\n     * @dev Callable on any active dispute\r\n     * @dev Resets disputes and choices to empty arrays and reimburses disputers\r\n     * @dev onlyOwner\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionId))\r\n     */\r\n    function arbitrateNull(bytes32 disputeId) external;\r\n\r\n    /**\r\n     * @notice Deliver arbitration\r\n     * @dev Callable only when timelock has passed\r\n     * @dev onlyOwner\r\n     * @dev isRequested\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionId))\r\n     * @param choice index of the chosen desiredOutcome from dispute.choices\r\n     */\r\n    function arbitrate(bytes32 disputeId, uint256 choice) external;\r\n\r\n    /**\r\n     * @notice Delivers arbitration as the Keeper's proposed report and refunds all disputers who requested arbitration\r\n     * @dev Callable when a dispute has lapsed. Also hides this arbitrator in ArbitratorFactory\r\n     * @dev isRequested\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionId))\r\n     */\r\n    function claimLapse(bytes32 disputeId) external;\r\n\r\n    /**\r\n     * @notice Gets timelock of the condition being disputed\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionId))\r\n     */\r\n    function getTimelock(bytes32 disputeId)\r\n        external\r\n        view\r\n        returns (uint256 timelock);\r\n\r\n    /**\r\n     * @notice Dispute getter\r\n     * @param disputeId keccak256(abi.encode(address solver, uint256 conditionId))\r\n     */\r\n    function getDispute(bytes32 disputeId) external view;\r\n\r\n    /**\r\n     * @notice Withdraws ETH and reduces balance of msg.sender\r\n     * @dev nonReentrant\r\n     */\r\n    function withdraw() external;\r\n\r\n    /**\r\n     * @notice Sets visible=true on ArbitratorFactory's list of arbitrators\r\n     * @dev onlyOwner\r\n     */\r\n    function unhideArbitrator() external;\r\n\r\n    /**\r\n     * @notice Sets visible=false on ArbitratorFactory's list of arbitrators\r\n     * @dev onlyOwner\r\n     */\r\n    function hideArbitrator() external;\r\n\r\n    /**\r\n     * @notice Increases current owner's balance\r\n     */\r\n    receive() external payable;\r\n}\r\n"
    },
    "contracts/interfaces/IERC1155Rescue.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.14;\r\n\r\ninterface IERC1155Rescue {\r\n    function rescueBag(bytes32 bagId, address to) external;\r\n\r\n    function getBagId(\r\n        address solver,\r\n        uint256[] calldata tokenIds,\r\n        uint256[] calldata tokenAmounts\r\n    ) external pure returns (bytes32);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n"
    },
    "contracts/test/ERC1155Unsafe.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.14;\r\n\r\nimport \"../interfaces/IERC1155Rescue.sol\";\r\n\r\ncontract ERC1155Unsafe {\r\n    IERC1155Rescue rescue;\r\n\r\n    constructor(IERC1155Rescue _rescue) {\r\n        rescue = _rescue;\r\n    }\r\n\r\n    function rescueBag(bytes32 bagId, address to) external {\r\n        rescue.rescueBag(bagId, to);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}