{
  "address": "0x2009d1DBf6a753030129BF3F83805b5d0217a694",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_ctfAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "CreateProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "DefundProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "ExecuteProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "from",
          "type": "address"
        }
      ],
      "name": "FundProposal",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "conditionalTokens",
      "outputs": [
        {
          "internalType": "contract IConditionalTokens",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "baseId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "collateralToken",
          "type": "address"
        },
        {
          "internalType": "contract IIPFSSolutionsHub",
          "name": "ipfsSolutionsHub",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "fundingGoal",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "contract Solver",
              "name": "implementation",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "keeper",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "arbitrator",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "timelockSeconds",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "contract IModule",
                  "name": "module",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                }
              ],
              "internalType": "struct Modulated.Loader[]",
              "name": "moduleLoaders",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "executions",
                  "type": "uint256"
                },
                {
                  "internalType": "enum SolverLib.IngestType",
                  "name": "ingestType",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "slot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "solverIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                }
              ],
              "internalType": "struct SolverLib.Ingest[]",
              "name": "ingests",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "contract IERC20",
                  "name": "collateralToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "outcomeSlots",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "parentCollectionIndexSet",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "amountSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256[]",
                  "name": "partition",
                  "type": "uint256[]"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "recipientAddressSlot",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "bytes32[]",
                      "name": "recipientAmountSlots",
                      "type": "bytes32[]"
                    }
                  ],
                  "internalType": "struct SolverLib.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                },
                {
                  "internalType": "string[]",
                  "name": "outcomeURIs",
                  "type": "string[]"
                }
              ],
              "internalType": "struct SolverLib.ConditionBase",
              "name": "conditionBase",
              "type": "tuple"
            }
          ],
          "internalType": "struct SolverLib.Config[]",
          "name": "solverConfigs",
          "type": "tuple[]"
        },
        {
          "internalType": "string",
          "name": "solverConfigsURI",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "metadataURI",
          "type": "string"
        }
      ],
      "name": "createIPFSSolutionAndProposal",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "solutionId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "collateralToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "solutionsHub",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "fundingGoal",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "safeBaseId",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "contract Solver",
              "name": "implementation",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "keeper",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "arbitrator",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "timelockSeconds",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "contract IModule",
                  "name": "module",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                }
              ],
              "internalType": "struct Modulated.Loader[]",
              "name": "moduleLoaders",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "executions",
                  "type": "uint256"
                },
                {
                  "internalType": "enum SolverLib.IngestType",
                  "name": "ingestType",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "slot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "solverIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                }
              ],
              "internalType": "struct SolverLib.Ingest[]",
              "name": "ingests",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "contract IERC20",
                  "name": "collateralToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "outcomeSlots",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "parentCollectionIndexSet",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "amountSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256[]",
                  "name": "partition",
                  "type": "uint256[]"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "recipientAddressSlot",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "bytes32[]",
                      "name": "recipientAmountSlots",
                      "type": "bytes32[]"
                    }
                  ],
                  "internalType": "struct SolverLib.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                },
                {
                  "internalType": "string[]",
                  "name": "outcomeURIs",
                  "type": "string[]"
                }
              ],
              "internalType": "struct SolverLib.ConditionBase",
              "name": "conditionBase",
              "type": "tuple"
            }
          ],
          "internalType": "struct SolverLib.Config[]",
          "name": "solverConfigs",
          "type": "tuple[]"
        },
        {
          "internalType": "string",
          "name": "metadataURI",
          "type": "string"
        }
      ],
      "name": "createProposal",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "solutionId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "defundProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "contract Solver",
              "name": "implementation",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "keeper",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "arbitrator",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "timelockSeconds",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "contract IModule",
                  "name": "module",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                }
              ],
              "internalType": "struct Modulated.Loader[]",
              "name": "moduleLoaders",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "executions",
                  "type": "uint256"
                },
                {
                  "internalType": "enum SolverLib.IngestType",
                  "name": "ingestType",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "slot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "solverIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "data",
                  "type": "bytes"
                }
              ],
              "internalType": "struct SolverLib.Ingest[]",
              "name": "ingests",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "contract IERC20",
                  "name": "collateralToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "outcomeSlots",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "parentCollectionIndexSet",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "amountSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256[]",
                  "name": "partition",
                  "type": "uint256[]"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "recipientAddressSlot",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "bytes32[]",
                      "name": "recipientAmountSlots",
                      "type": "bytes32[]"
                    }
                  ],
                  "internalType": "struct SolverLib.Allocation[]",
                  "name": "allocations",
                  "type": "tuple[]"
                },
                {
                  "internalType": "string[]",
                  "name": "outcomeURIs",
                  "type": "string[]"
                }
              ],
              "internalType": "struct SolverLib.ConditionBase",
              "name": "conditionBase",
              "type": "tuple"
            }
          ],
          "internalType": "struct SolverLib.Config[]",
          "name": "solverConfigs",
          "type": "tuple[]"
        }
      ],
      "name": "executeIPFSProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "fundProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "funderAmountMap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "getMetadataCID",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "getProposal",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isExecuted",
              "type": "bool"
            },
            {
              "internalType": "contract IERC20",
              "name": "collateralToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "proposer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "solutionsHub",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "id",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "solutionId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "funding",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fundingGoal",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "metadataURI",
              "type": "string"
            }
          ],
          "internalType": "struct ProposalsHub.Proposal",
          "name": "proposal",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "isProposal",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "nonces",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onERC1155BatchReceived",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "proposals",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isExecuted",
          "type": "bool"
        },
        {
          "internalType": "contract IERC20",
          "name": "collateralToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "solutionsHub",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "id",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "solutionId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "funding",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fundingGoal",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "metadataURI",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "reclaimTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "reclaimableTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "reclaimedTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "proposalId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "solver",
          "type": "address"
        }
      ],
      "name": "transferERC20",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x41ba244a5eb0461d574e478d0f208340d04c48c3559e1ffd6efb84f480f9050c",
  "receipt": {
    "to": null,
    "from": "0x582B5C951E7e6f599c87E86f32B7C5549B34158d",
    "contractAddress": "0x2009d1DBf6a753030129BF3F83805b5d0217a694",
    "transactionIndex": 156,
    "gasUsed": "3121069",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2241006f90bd761b0c924687202a6d0dc0fb35d9b0d74c1ae9d207b2fa1ae22e",
    "transactionHash": "0x41ba244a5eb0461d574e478d0f208340d04c48c3559e1ffd6efb84f480f9050c",
    "logs": [],
    "blockNumber": 8009855,
    "cumulativeGasUsed": "28303526",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5f19190Ef34D955ff4dE42da2F21DFA6770a38B8"
  ],
  "numDeployments": 3,
  "solcInputHash": "40b90df2a1b8bf39e22495621c66ed0c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ctfAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"CreateProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"DefundProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ExecuteProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"FundProposal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"conditionalTokens\",\"outputs\":[{\"internalType\":\"contract IConditionalTokens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"baseId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"contract IIPFSSolutionsHub\",\"name\":\"ipfsSolutionsHub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingGoal\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract Solver\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelockSeconds\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IModule\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Modulated.Loader[]\",\"name\":\"moduleLoaders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"executions\",\"type\":\"uint256\"},{\"internalType\":\"enum SolverLib.IngestType\",\"name\":\"ingestType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"solverIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SolverLib.Ingest[]\",\"name\":\"ingests\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outcomeSlots\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parentCollectionIndexSet\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"amountSlot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"partition\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recipientAddressSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"recipientAmountSlots\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SolverLib.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"outcomeURIs\",\"type\":\"string[]\"}],\"internalType\":\"struct SolverLib.ConditionBase\",\"name\":\"conditionBase\",\"type\":\"tuple\"}],\"internalType\":\"struct SolverLib.Config[]\",\"name\":\"solverConfigs\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"solverConfigsURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"name\":\"createIPFSSolutionAndProposal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"solutionId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solutionsHub\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingGoal\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"safeBaseId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"contract Solver\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelockSeconds\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IModule\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Modulated.Loader[]\",\"name\":\"moduleLoaders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"executions\",\"type\":\"uint256\"},{\"internalType\":\"enum SolverLib.IngestType\",\"name\":\"ingestType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"solverIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SolverLib.Ingest[]\",\"name\":\"ingests\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outcomeSlots\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parentCollectionIndexSet\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"amountSlot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"partition\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recipientAddressSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"recipientAmountSlots\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SolverLib.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"outcomeURIs\",\"type\":\"string[]\"}],\"internalType\":\"struct SolverLib.ConditionBase\",\"name\":\"conditionBase\",\"type\":\"tuple\"}],\"internalType\":\"struct SolverLib.Config[]\",\"name\":\"solverConfigs\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"name\":\"createProposal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"solutionId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"defundProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"contract Solver\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelockSeconds\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IModule\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Modulated.Loader[]\",\"name\":\"moduleLoaders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"executions\",\"type\":\"uint256\"},{\"internalType\":\"enum SolverLib.IngestType\",\"name\":\"ingestType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"solverIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SolverLib.Ingest[]\",\"name\":\"ingests\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outcomeSlots\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parentCollectionIndexSet\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"amountSlot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"partition\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recipientAddressSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"recipientAmountSlots\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SolverLib.Allocation[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"outcomeURIs\",\"type\":\"string[]\"}],\"internalType\":\"struct SolverLib.ConditionBase\",\"name\":\"conditionBase\",\"type\":\"tuple\"}],\"internalType\":\"struct SolverLib.Config[]\",\"name\":\"solverConfigs\",\"type\":\"tuple[]\"}],\"name\":\"executeIPFSProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fundProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"funderAmountMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getMetadataCID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solutionsHub\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"solutionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"funding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingGoal\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"internalType\":\"struct ProposalsHub.Proposal\",\"name\":\"proposal\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"isProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solutionsHub\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"solutionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"funding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingGoal\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"reclaimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reclaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reclaimedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createProposal(address,address,uint256,bytes32,(address,address,address,uint256,(address,bytes)[],(uint256,uint8,bytes32,uint256,bytes)[],(address,uint256,uint256,bytes32,uint256[],(bytes32,bytes32[])[],string[]))[],string)\":{\"details\":\"Creates a Proposal from an existing Solution.Base\",\"params\":{\"collateralToken\":\"ERC20 token being used as collateral for conditional tokens\",\"fundingGoal\":\"Amount of ERC20 collateral requested for the Proposal\",\"safeBaseId\":\"ID of the Solution.Base for which a new instance and proposal is created\",\"solutionsHub\":\"Address of the SolutionsHub contract managing the Solution\"}},\"defundProposal(bytes32,address,uint256)\":{\"details\":\"Called by user to remove their funding from a Proposal\",\"params\":{\"amount\":\"Amount to be defunded\",\"proposalId\":\"ID of Proposal being defunded\",\"token\":\"ERC20 token to be defunded\"}},\"executeIPFSProposal(bytes32,(address,address,address,uint256,(address,bytes)[],(uint256,uint8,bytes32,uint256,bytes)[],(address,uint256,uint256,bytes32,uint256[],(bytes32,bytes32[])[],string[]))[])\":{\"details\":\"Executes a proposal for Solutions where on the *hash* of solver configs is stored on-chain\",\"params\":{\"proposalId\":\"ID of proposal\",\"solverConfigs\":\"Configurations of Solvers to be run for the proposed solution\"}},\"fundProposal(bytes32,address,uint256)\":{\"details\":\"Called by user to add funding to a Proposal\",\"params\":{\"amount\":\"Amount to be funded\",\"proposalId\":\"ID of Proposal being funded\",\"token\":\"ERC20 token to be funded with\"}},\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\":{\"details\":\"Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` (i.e. 0xbc197c81, or its own function selector).\",\"params\":{\"data\":\"Additional data with no specified format\",\"from\":\"The address which previously owned the token\",\"ids\":\"An array containing ids of each token being transferred (order and length must match values array)\",\"operator\":\"The address which initiated the batch transfer (i.e. msg.sender)\",\"values\":\"An array containing amounts of each token being transferred (order and length must match ids array)\"},\"returns\":{\"_0\":\"`bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\"}},\"reclaimTokens(bytes32,uint256)\":{\"details\":\"Transfers reclaimable CTs to a claimer and lowers their reclaimable balance for that token\",\"params\":{\"proposalId\":\"ID of proposal being reclaimed from\",\"tokenId\":\"ERC1155 token being reclaimed\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"transferERC20(bytes32,address)\":{\"details\":\"Called by SolutionsHub after deploying Solvers\",\"params\":{\"proposalId\":\"Proposal that collateral is being transferred from\",\"solver\":\"Solver receiving collateral\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createProposal(address,address,uint256,bytes32,(address,address,address,uint256,(address,bytes)[],(uint256,uint8,bytes32,uint256,bytes)[],(address,uint256,uint256,bytes32,uint256[],(bytes32,bytes32[])[],string[]))[],string)\":{\"notice\":\"Ceramic Interop: safeBaseId == keccak256(abi.encode(keccak256(abi.encode(templateCommitID, proposalCommitID)), nonce))\"},\"onERC1155Received(address,address,uint256,uint256,bytes)\":{\"notice\":\"IMPORTANT! Any CTs sent to this contract are reclaimable by the funders in proportion to their funding. If a user reclaims CTs and sends them back again to this contract, they will only be able to  regain from them a fraction of their original funding.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/hubs/ProposalsHub.sol\":\"ProposalsHub\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7454006cccb737612b00104d2f606d728e2818b778e7e55542f063c614ce46ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][account] = accountBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\",\"keccak256\":\"0xbda715785876dbfc675396b89ac45bb9f4cceb968133a8258924d163a700f0e4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xfce1eb6398eae0e2b50251140866a70a3106193f101972c878bba1dbf44929ec\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7de6e64d4a8075e803a972cc77c4c91463e0c3777e4110eacfb5d4a71759b2fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x6ba0564f6970414d1166ee83127b834bbe7dbf699241a3005eb7ae64a2211975\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0x8c578d9e30c8f2bb7ac01d108766df87d42b73d4d3638f01d494a894fe7c1f4b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x02348b2e4b9f3200c7e3907c5c2661643a6d8520e9f79939fbb9b4005a54894d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3336baae5cf23e94274d75336e2d412193be508504aee185e61dc7d58cd05c8a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x5718c5df9bd67ac68a796961df938821bb5dc0cd4c6118d77e9145afb187409b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa28007762d9da9db878dd421960c8cb9a10471f47ab5c1b3309bfe48e9e79ff4\",\"license\":\"MIT\"},\"contracts/ABDKMath64x64.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\r\\n/*\\r\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\r\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\r\\n */\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * Smart contract library of mathematical functions operating with signed\\r\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\r\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\r\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\r\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\r\\n * represented by int128 type holding only the numerator.\\r\\n */\\r\\nlibrary ABDKMath64x64 {\\r\\n    /*\\r\\n     * Minimum value signed 64.64-bit fixed point number may have.\\r\\n     */\\r\\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\r\\n\\r\\n    /*\\r\\n     * Maximum value signed 64.64-bit fixed point number may have.\\r\\n     */\\r\\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n    /**\\r\\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\r\\n     * number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 256-bit integer number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function fromInt(int256 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\r\\n            return int128(x << 64);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\\r\\n     * rounding down.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64-bit integer number\\r\\n     */\\r\\n    function toInt(int128 x) internal pure returns (int64) {\\r\\n        unchecked {\\r\\n            return int64(x >> 64);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\r\\n     * number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function fromUInt(uint256 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x <= 0x7FFFFFFFFFFFFFFF);\\r\\n            return int128(int256(x << 64));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\r\\n     * number rounding down.  Revert on underflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return unsigned 64-bit integer number\\r\\n     */\\r\\n    function toUInt(int128 x) internal pure returns (uint64) {\\r\\n        unchecked {\\r\\n            require(x >= 0);\\r\\n            return uint64(uint128(x >> 64));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\r\\n     * number rounding down.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 128.128-bin fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function from128x128(int256 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 result = x >> 64;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\r\\n     * number.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 128.128 fixed point number\\r\\n     */\\r\\n    function to128x128(int128 x) internal pure returns (int256) {\\r\\n        unchecked {\\r\\n            return int256(x) << 64;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x + y.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function add(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 result = int256(x) + y;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x - y.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function sub(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 result = int256(x) - y;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x * y rounding down.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function mul(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 result = (int256(x) * y) >> 64;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\r\\n     * number and y is signed 256-bit integer number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64 fixed point number\\r\\n     * @param y signed 256-bit integer number\\r\\n     * @return signed 256-bit integer number\\r\\n     */\\r\\n    function muli(int128 x, int256 y) internal pure returns (int256) {\\r\\n        unchecked {\\r\\n            if (x == MIN_64x64) {\\r\\n                require(\\r\\n                    y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\r\\n                        y <= 0x1000000000000000000000000000000000000000000000000\\r\\n                );\\r\\n                return -y << 63;\\r\\n            } else {\\r\\n                bool negativeResult = false;\\r\\n                if (x < 0) {\\r\\n                    x = -x;\\r\\n                    negativeResult = true;\\r\\n                }\\r\\n                if (y < 0) {\\r\\n                    y = -y; // We rely on overflow behavior here\\r\\n                    negativeResult = !negativeResult;\\r\\n                }\\r\\n                uint256 absoluteResult = mulu(x, uint256(y));\\r\\n                if (negativeResult) {\\r\\n                    require(\\r\\n                        absoluteResult <=\\r\\n                            0x8000000000000000000000000000000000000000000000000000000000000000\\r\\n                    );\\r\\n                    return -int256(absoluteResult); // We rely on overflow behavior here\\r\\n                } else {\\r\\n                    require(\\r\\n                        absoluteResult <=\\r\\n                            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\r\\n                    );\\r\\n                    return int256(absoluteResult);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\r\\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64 fixed point number\\r\\n     * @param y unsigned 256-bit integer number\\r\\n     * @return unsigned 256-bit integer number\\r\\n     */\\r\\n    function mulu(int128 x, uint256 y) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            if (y == 0) return 0;\\r\\n\\r\\n            require(x >= 0);\\r\\n\\r\\n            uint256 lo = (uint256(int256(x)) *\\r\\n                (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\r\\n            uint256 hi = uint256(int256(x)) * (y >> 128);\\r\\n\\r\\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n            hi <<= 64;\\r\\n\\r\\n            require(\\r\\n                hi <=\\r\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF -\\r\\n                        lo\\r\\n            );\\r\\n            return hi + lo;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\r\\n     * zero.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function div(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(y != 0);\\r\\n            int256 result = (int256(x) << 64) / y;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\r\\n     * integer numbers.  Revert on overflow or when y is zero.\\r\\n     *\\r\\n     * @param x signed 256-bit integer number\\r\\n     * @param y signed 256-bit integer number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function divi(int256 x, int256 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(y != 0);\\r\\n\\r\\n            bool negativeResult = false;\\r\\n            if (x < 0) {\\r\\n                x = -x; // We rely on overflow behavior here\\r\\n                negativeResult = true;\\r\\n            }\\r\\n            if (y < 0) {\\r\\n                y = -y; // We rely on overflow behavior here\\r\\n                negativeResult = !negativeResult;\\r\\n            }\\r\\n            uint128 absoluteResult = divuu(uint256(x), uint256(y));\\r\\n            if (negativeResult) {\\r\\n                require(absoluteResult <= 0x80000000000000000000000000000000);\\r\\n                return -int128(absoluteResult); // We rely on overflow behavior here\\r\\n            } else {\\r\\n                require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n                return int128(absoluteResult); // We rely on overflow behavior here\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n     * integer numbers.  Revert on overflow or when y is zero.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @param y unsigned 256-bit integer number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function divu(uint256 x, uint256 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(y != 0);\\r\\n            uint128 result = divuu(x, y);\\r\\n            require(result <= uint128(MAX_64x64));\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate -x.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function neg(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x != MIN_64x64);\\r\\n            return -x;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate |x|.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function abs(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x != MIN_64x64);\\r\\n            return x < 0 ? -x : x;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\r\\n     * zero.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function inv(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x != 0);\\r\\n            int256 result = int256(0x100000000000000000000000000000000) / x;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function avg(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            return int128((int256(x) + int256(y)) >> 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\r\\n     * Revert on overflow or in case x * y is negative.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function gavg(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 m = int256(x) * int256(y);\\r\\n            require(m >= 0);\\r\\n            require(\\r\\n                m <\\r\\n                    0x4000000000000000000000000000000000000000000000000000000000000000\\r\\n            );\\r\\n            return int128(sqrtu(uint256(m)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\r\\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y uint256 value\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function pow(int128 x, uint256 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            bool negative = x < 0 && y & 1 == 1;\\r\\n\\r\\n            uint256 absX = uint128(x < 0 ? -x : x);\\r\\n            uint256 absResult;\\r\\n            absResult = 0x100000000000000000000000000000000;\\r\\n\\r\\n            if (absX <= 0x10000000000000000) {\\r\\n                absX <<= 63;\\r\\n                while (y != 0) {\\r\\n                    if (y & 0x1 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n\\r\\n                    if (y & 0x2 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n\\r\\n                    if (y & 0x4 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n\\r\\n                    if (y & 0x8 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n\\r\\n                    y >>= 4;\\r\\n                }\\r\\n\\r\\n                absResult >>= 64;\\r\\n            } else {\\r\\n                uint256 absXShift = 63;\\r\\n                if (absX < 0x1000000000000000000000000) {\\r\\n                    absX <<= 32;\\r\\n                    absXShift -= 32;\\r\\n                }\\r\\n                if (absX < 0x10000000000000000000000000000) {\\r\\n                    absX <<= 16;\\r\\n                    absXShift -= 16;\\r\\n                }\\r\\n                if (absX < 0x1000000000000000000000000000000) {\\r\\n                    absX <<= 8;\\r\\n                    absXShift -= 8;\\r\\n                }\\r\\n                if (absX < 0x10000000000000000000000000000000) {\\r\\n                    absX <<= 4;\\r\\n                    absXShift -= 4;\\r\\n                }\\r\\n                if (absX < 0x40000000000000000000000000000000) {\\r\\n                    absX <<= 2;\\r\\n                    absXShift -= 2;\\r\\n                }\\r\\n                if (absX < 0x80000000000000000000000000000000) {\\r\\n                    absX <<= 1;\\r\\n                    absXShift -= 1;\\r\\n                }\\r\\n\\r\\n                uint256 resultShift = 0;\\r\\n                while (y != 0) {\\r\\n                    require(absXShift < 64);\\r\\n\\r\\n                    if (y & 0x1 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                        resultShift += absXShift;\\r\\n                        if (absResult > 0x100000000000000000000000000000000) {\\r\\n                            absResult >>= 1;\\r\\n                            resultShift += 1;\\r\\n                        }\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n                    absXShift <<= 1;\\r\\n                    if (absX >= 0x100000000000000000000000000000000) {\\r\\n                        absX >>= 1;\\r\\n                        absXShift += 1;\\r\\n                    }\\r\\n\\r\\n                    y >>= 1;\\r\\n                }\\r\\n\\r\\n                require(resultShift < 64);\\r\\n                absResult >>= 64 - resultShift;\\r\\n            }\\r\\n            int256 result = negative ? -int256(absResult) : int256(absResult);\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function sqrt(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x >= 0);\\r\\n            return int128(sqrtu(uint256(int256(x)) << 64));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate binary logarithm of x.  Revert if x <= 0.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function log_2(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x > 0);\\r\\n\\r\\n            int256 msb = 0;\\r\\n            int256 xc = x;\\r\\n            if (xc >= 0x10000000000000000) {\\r\\n                xc >>= 64;\\r\\n                msb += 64;\\r\\n            }\\r\\n            if (xc >= 0x100000000) {\\r\\n                xc >>= 32;\\r\\n                msb += 32;\\r\\n            }\\r\\n            if (xc >= 0x10000) {\\r\\n                xc >>= 16;\\r\\n                msb += 16;\\r\\n            }\\r\\n            if (xc >= 0x100) {\\r\\n                xc >>= 8;\\r\\n                msb += 8;\\r\\n            }\\r\\n            if (xc >= 0x10) {\\r\\n                xc >>= 4;\\r\\n                msb += 4;\\r\\n            }\\r\\n            if (xc >= 0x4) {\\r\\n                xc >>= 2;\\r\\n                msb += 2;\\r\\n            }\\r\\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\\r\\n\\r\\n            int256 result = (msb - 64) << 64;\\r\\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\\r\\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\r\\n                ux *= ux;\\r\\n                uint256 b = ux >> 255;\\r\\n                ux >>= 127 + b;\\r\\n                result += bit * int256(b);\\r\\n            }\\r\\n\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate natural logarithm of x.  Revert if x <= 0.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function ln(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x > 0);\\r\\n\\r\\n            return\\r\\n                int128(\\r\\n                    int256(\\r\\n                        (uint256(int256(log_2(x))) *\\r\\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\\r\\n                    )\\r\\n                );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate binary exponent of x.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function exp_2(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x < 0x400000000000000000); // Overflow\\r\\n\\r\\n            if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n            uint256 result = 0x80000000000000000000000000000000;\\r\\n\\r\\n            if (x & 0x8000000000000000 > 0)\\r\\n                result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\\r\\n            if (x & 0x4000000000000000 > 0)\\r\\n                result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\\r\\n            if (x & 0x2000000000000000 > 0)\\r\\n                result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\\r\\n            if (x & 0x1000000000000000 > 0)\\r\\n                result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\\r\\n            if (x & 0x800000000000000 > 0)\\r\\n                result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\\r\\n            if (x & 0x400000000000000 > 0)\\r\\n                result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\\r\\n            if (x & 0x200000000000000 > 0)\\r\\n                result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\\r\\n            if (x & 0x100000000000000 > 0)\\r\\n                result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\\r\\n            if (x & 0x80000000000000 > 0)\\r\\n                result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\\r\\n            if (x & 0x40000000000000 > 0)\\r\\n                result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\\r\\n            if (x & 0x20000000000000 > 0)\\r\\n                result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\\r\\n            if (x & 0x10000000000000 > 0)\\r\\n                result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\\r\\n            if (x & 0x8000000000000 > 0)\\r\\n                result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\\r\\n            if (x & 0x4000000000000 > 0)\\r\\n                result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\\r\\n            if (x & 0x2000000000000 > 0)\\r\\n                result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\\r\\n            if (x & 0x1000000000000 > 0)\\r\\n                result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\\r\\n            if (x & 0x800000000000 > 0)\\r\\n                result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\\r\\n            if (x & 0x400000000000 > 0)\\r\\n                result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\\r\\n            if (x & 0x200000000000 > 0)\\r\\n                result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\\r\\n            if (x & 0x100000000000 > 0)\\r\\n                result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\\r\\n            if (x & 0x80000000000 > 0)\\r\\n                result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\\r\\n            if (x & 0x40000000000 > 0)\\r\\n                result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\\r\\n            if (x & 0x20000000000 > 0)\\r\\n                result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\\r\\n            if (x & 0x10000000000 > 0)\\r\\n                result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\\r\\n            if (x & 0x8000000000 > 0)\\r\\n                result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\\r\\n            if (x & 0x4000000000 > 0)\\r\\n                result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\\r\\n            if (x & 0x2000000000 > 0)\\r\\n                result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\\r\\n            if (x & 0x1000000000 > 0)\\r\\n                result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\\r\\n            if (x & 0x800000000 > 0)\\r\\n                result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\\r\\n            if (x & 0x400000000 > 0)\\r\\n                result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\\r\\n            if (x & 0x200000000 > 0)\\r\\n                result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\\r\\n            if (x & 0x100000000 > 0)\\r\\n                result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\\r\\n            if (x & 0x80000000 > 0)\\r\\n                result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\\r\\n            if (x & 0x40000000 > 0)\\r\\n                result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\\r\\n            if (x & 0x20000000 > 0)\\r\\n                result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\\r\\n            if (x & 0x10000000 > 0)\\r\\n                result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\\r\\n            if (x & 0x8000000 > 0)\\r\\n                result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\\r\\n            if (x & 0x4000000 > 0)\\r\\n                result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\\r\\n            if (x & 0x2000000 > 0)\\r\\n                result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\\r\\n            if (x & 0x1000000 > 0)\\r\\n                result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\\r\\n            if (x & 0x800000 > 0)\\r\\n                result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\\r\\n            if (x & 0x400000 > 0)\\r\\n                result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\\r\\n            if (x & 0x200000 > 0)\\r\\n                result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\\r\\n            if (x & 0x100000 > 0)\\r\\n                result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\\r\\n            if (x & 0x80000 > 0)\\r\\n                result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\\r\\n            if (x & 0x40000 > 0)\\r\\n                result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\\r\\n            if (x & 0x20000 > 0)\\r\\n                result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\\r\\n            if (x & 0x10000 > 0)\\r\\n                result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\\r\\n            if (x & 0x8000 > 0)\\r\\n                result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\\r\\n            if (x & 0x4000 > 0)\\r\\n                result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\\r\\n            if (x & 0x2000 > 0)\\r\\n                result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\\r\\n            if (x & 0x1000 > 0)\\r\\n                result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\\r\\n            if (x & 0x800 > 0)\\r\\n                result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\\r\\n            if (x & 0x400 > 0)\\r\\n                result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\\r\\n            if (x & 0x200 > 0)\\r\\n                result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\\r\\n            if (x & 0x100 > 0)\\r\\n                result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\\r\\n            if (x & 0x80 > 0)\\r\\n                result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\\r\\n            if (x & 0x40 > 0)\\r\\n                result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\\r\\n            if (x & 0x20 > 0)\\r\\n                result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\\r\\n            if (x & 0x10 > 0)\\r\\n                result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\\r\\n            if (x & 0x8 > 0)\\r\\n                result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\\r\\n            if (x & 0x4 > 0)\\r\\n                result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\\r\\n            if (x & 0x2 > 0)\\r\\n                result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\\r\\n            if (x & 0x1 > 0)\\r\\n                result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\\r\\n\\r\\n            result >>= uint256(int256(63 - (x >> 64)));\\r\\n            require(result <= uint256(int256(MAX_64x64)));\\r\\n\\r\\n            return int128(int256(result));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate natural exponent of x.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function exp(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x < 0x400000000000000000); // Overflow\\r\\n\\r\\n            if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n            return\\r\\n                exp_2(\\r\\n                    int128(\\r\\n                        (int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128\\r\\n                    )\\r\\n                );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n     * integer numbers.  Revert on overflow or when y is zero.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @param y unsigned 256-bit integer number\\r\\n     * @return unsigned 64.64-bit fixed point number\\r\\n     */\\r\\n    function divuu(uint256 x, uint256 y) private pure returns (uint128) {\\r\\n        unchecked {\\r\\n            require(y != 0);\\r\\n\\r\\n            uint256 result;\\r\\n\\r\\n            if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n                result = (x << 64) / y;\\r\\n            else {\\r\\n                uint256 msb = 192;\\r\\n                uint256 xc = x >> 192;\\r\\n                if (xc >= 0x100000000) {\\r\\n                    xc >>= 32;\\r\\n                    msb += 32;\\r\\n                }\\r\\n                if (xc >= 0x10000) {\\r\\n                    xc >>= 16;\\r\\n                    msb += 16;\\r\\n                }\\r\\n                if (xc >= 0x100) {\\r\\n                    xc >>= 8;\\r\\n                    msb += 8;\\r\\n                }\\r\\n                if (xc >= 0x10) {\\r\\n                    xc >>= 4;\\r\\n                    msb += 4;\\r\\n                }\\r\\n                if (xc >= 0x4) {\\r\\n                    xc >>= 2;\\r\\n                    msb += 2;\\r\\n                }\\r\\n                if (xc >= 0x2) msb += 1; // No need to shift xc anymore\\r\\n\\r\\n                result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\\r\\n                require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n                uint256 hi = result * (y >> 128);\\r\\n                uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n                uint256 xh = x >> 192;\\r\\n                uint256 xl = x << 64;\\r\\n\\r\\n                if (xl < lo) xh -= 1;\\r\\n                xl -= lo; // We rely on overflow behavior here\\r\\n                lo = hi << 128;\\r\\n                if (xl < lo) xh -= 1;\\r\\n                xl -= lo; // We rely on overflow behavior here\\r\\n\\r\\n                assert(xh == hi >> 128);\\r\\n\\r\\n                result += xl / y;\\r\\n            }\\r\\n\\r\\n            require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n            return uint128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\r\\n     * number.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @return unsigned 128-bit integer number\\r\\n     */\\r\\n    function sqrtu(uint256 x) private pure returns (uint128) {\\r\\n        unchecked {\\r\\n            if (x == 0) return 0;\\r\\n            else {\\r\\n                uint256 xx = x;\\r\\n                uint256 r = 1;\\r\\n                if (xx >= 0x100000000000000000000000000000000) {\\r\\n                    xx >>= 128;\\r\\n                    r <<= 64;\\r\\n                }\\r\\n                if (xx >= 0x10000000000000000) {\\r\\n                    xx >>= 64;\\r\\n                    r <<= 32;\\r\\n                }\\r\\n                if (xx >= 0x100000000) {\\r\\n                    xx >>= 32;\\r\\n                    r <<= 16;\\r\\n                }\\r\\n                if (xx >= 0x10000) {\\r\\n                    xx >>= 16;\\r\\n                    r <<= 8;\\r\\n                }\\r\\n                if (xx >= 0x100) {\\r\\n                    xx >>= 8;\\r\\n                    r <<= 4;\\r\\n                }\\r\\n                if (xx >= 0x10) {\\r\\n                    xx >>= 4;\\r\\n                    r <<= 2;\\r\\n                }\\r\\n                if (xx >= 0x4) {\\r\\n                    r <<= 1;\\r\\n                }\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1; // Seven iterations should be enough\\r\\n                uint256 r1 = x / r;\\r\\n                return uint128(r < r1 ? r : r1);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x3a722c73c6536731b71f7f0379eb2002c774ca66e82a084af4ed03e7ed4ee77d\",\"license\":\"BSD-4-Clause\"},\"contracts/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\n/// @title Contains 512-bit math functions\\r\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\r\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\r\\nlibrary FullMath {\\r\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n    function mulDiv(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        // 512-bit multiply [prod1 prod0] = a * b\\r\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n        // then use the Chinese Remainder Theorem to reconstruct\\r\\n        // the 512 bit result. The result is stored in two 256\\r\\n        // variables such that product = prod1 * 2**256 + prod0\\r\\n        uint256 prod0; // Least significant 256 bits of the product\\r\\n        uint256 prod1; // Most significant 256 bits of the product\\r\\n        assembly {\\r\\n            let mm := mulmod(a, b, not(0))\\r\\n            prod0 := mul(a, b)\\r\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n        }\\r\\n\\r\\n        // Handle non-overflow cases, 256 by 256 division\\r\\n        if (prod1 == 0) {\\r\\n            require(denominator > 0);\\r\\n            assembly {\\r\\n                result := div(prod0, denominator)\\r\\n            }\\r\\n            return result;\\r\\n        }\\r\\n\\r\\n        // Make sure the result is less than 2**256.\\r\\n        // Also prevents denominator == 0\\r\\n        require(denominator > prod1);\\r\\n\\r\\n        ///////////////////////////////////////////////\\r\\n        // 512 by 256 division.\\r\\n        ///////////////////////////////////////////////\\r\\n\\r\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n        // Compute remainder using mulmod\\r\\n        uint256 remainder;\\r\\n        assembly {\\r\\n            remainder := mulmod(a, b, denominator)\\r\\n        }\\r\\n        // Subtract 256 bit number from 512 bit number\\r\\n        assembly {\\r\\n            prod1 := sub(prod1, gt(remainder, prod0))\\r\\n            prod0 := sub(prod0, remainder)\\r\\n        }\\r\\n\\r\\n        // Factor powers of two out of denominator\\r\\n        // Compute largest power of two divisor of denominator.\\r\\n        // Always >= 1.\\r\\n        uint256 twos = denominator & (~denominator + 1);\\r\\n        // Divide denominator by power of two\\r\\n        assembly {\\r\\n            denominator := div(denominator, twos)\\r\\n        }\\r\\n\\r\\n        // Divide [prod1 prod0] by the factors of two\\r\\n        assembly {\\r\\n            prod0 := div(prod0, twos)\\r\\n        }\\r\\n        // Shift in bits from prod1 into prod0. For this we need\\r\\n        // to flip `twos` such that it is 2**256 / twos.\\r\\n        // If twos is zero, then it becomes one\\r\\n        assembly {\\r\\n            twos := add(div(sub(0, twos), twos), 1)\\r\\n        }\\r\\n        prod0 |= prod1 * twos;\\r\\n\\r\\n        // Invert denominator mod 2**256\\r\\n        // Now that denominator is an odd number, it has an inverse\\r\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n        // Compute the inverse by starting with a seed that is correct\\r\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n        uint256 inv = (3 * denominator) ^ 2;\\r\\n        // Now use Newton-Raphson iteration to improve the precision.\\r\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\r\\n        // arithmetic, doubling the correct bits in each step.\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\r\\n\\r\\n        // Because the division is now exact we can divide by multiplying\\r\\n        // with the modular inverse of denominator. This will give us the\\r\\n        // correct result modulo 2**256. Since the precoditions guarantee\\r\\n        // that the outcome is less than 2**256, this is the final result.\\r\\n        // We don't need to compute the high bits of the result and prod1\\r\\n        // is no longer required.\\r\\n        result = prod0 * inv;\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    function mulDivRoundingUp(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        result = mulDiv(a, b, denominator);\\r\\n        if (mulmod(a, b, denominator) > 0) {\\r\\n            require(result < type(uint256).max);\\r\\n            result++;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x496a56124b1e42d517a63edad9aff6a960b3b99094848b367eaae21e616a42fd\",\"license\":\"MIT\"},\"contracts/conditionalTokens/CTHelpers.sol\":{\"content\":\"/** \\r\\n    SPDX-License-Identifier: LGPL-3.0\\r\\n    Copied from Gnosis\\r\\n    Updated for Solidity 0.8.0\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nlibrary CTHelpers {\\r\\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function getConditionId(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) internal pure returns (bytes32) {\\r\\n        return\\r\\n            keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\\r\\n    }\\r\\n\\r\\n    uint256 constant P =\\r\\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\\r\\n    uint256 constant B = 3;\\r\\n\\r\\n    function sqrt(uint256 x) private pure returns (uint256 y) {\\r\\n        uint256 p = P;\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly {\\r\\n            // add chain generated via https://crypto.stackexchange.com/q/27179/71252\\r\\n            // and transformed to the following program:\\r\\n\\r\\n            // x=1; y=x+x; z=y+y; z=z+z; y=y+z; x=x+y; y=y+x; z=y+y; t=z+z; t=z+t; t=t+t;\\r\\n            // t=t+t; z=z+t; x=x+z; z=x+x; z=z+z; y=y+z; z=y+y; z=z+z; z=z+z; z=y+z; x=x+z;\\r\\n            // z=x+x; z=z+z; z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; z=y+y; t=z+z;\\r\\n            // t=t+t; t=t+t; z=z+t; x=x+z; y=y+x; z=y+y; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\\r\\n            // z=x+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; t=z+z; t=t+t; t=z+t; t=y+t; t=t+t;\\r\\n            // t=t+t; t=t+t; t=t+t; z=z+t; x=x+z; z=x+x; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z;\\r\\n            // t=z+z; t=z+t; w=t+t; w=w+w; w=w+w; w=w+w; w=w+w; t=t+w; z=z+t; x=x+z; y=y+x;\\r\\n            // z=y+y; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; z=z+z; y=y+z; z=y+y;\\r\\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; x=x+z; y=y+x; x=x+y; y=y+x; z=y+y; z=z+z;\\r\\n            // z=y+z; x=x+z; z=x+x; z=x+z; y=y+z; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; z=y+z;\\r\\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x; t=z+z; t=t+t; t=z+t;\\r\\n            // t=x+t; t=t+t; t=t+t; t=t+t; t=t+t; z=z+t; y=y+z; x=x+y; y=y+x; x=x+y; z=x+x;\\r\\n            // z=x+z; z=z+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x;\\r\\n            // z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; x=x+y; z=x+x; y=y+z; x=x+y; y=y+x;\\r\\n            // z=y+y; z=y+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\\r\\n            // z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; t=x+z; t=t+t; t=t+t; z=z+t; y=y+z; z=y+y;\\r\\n            // x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; t=y+z; z=y+t; z=z+z; z=z+z;\\r\\n            // z=t+z; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; y=y+z; x=x+y; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\r\\n            // x=x+x; x=x+x; x=x+x; x=x+x; res=y+x\\r\\n            // res == (P + 1) // 4\\r\\n\\r\\n            y := mulmod(x, x, p)\\r\\n            {\\r\\n                let z := mulmod(y, y, p)\\r\\n                z := mulmod(z, z, p)\\r\\n                y := mulmod(y, z, p)\\r\\n                x := mulmod(x, y, p)\\r\\n                y := mulmod(y, x, p)\\r\\n                z := mulmod(y, y, p)\\r\\n                {\\r\\n                    let t := mulmod(z, z, p)\\r\\n                    t := mulmod(z, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    t := mulmod(z, z, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    t := mulmod(z, z, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(z, t, p)\\r\\n                    t := mulmod(y, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    t := mulmod(z, z, p)\\r\\n                    t := mulmod(z, t, p)\\r\\n                    {\\r\\n                        let w := mulmod(t, t, p)\\r\\n                        w := mulmod(w, w, p)\\r\\n                        w := mulmod(w, w, p)\\r\\n                        w := mulmod(w, w, p)\\r\\n                        w := mulmod(w, w, p)\\r\\n                        t := mulmod(t, w, p)\\r\\n                    }\\r\\n                    z := mulmod(z, t, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    t := mulmod(z, z, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(z, t, p)\\r\\n                    t := mulmod(x, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    z := mulmod(y, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(x, z, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    z := mulmod(x, x, p)\\r\\n                    t := mulmod(x, z, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    t := mulmod(t, t, p)\\r\\n                    z := mulmod(z, t, p)\\r\\n                    y := mulmod(y, z, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    x := mulmod(x, z, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    x := mulmod(x, y, p)\\r\\n                    y := mulmod(y, x, p)\\r\\n                    z := mulmod(y, y, p)\\r\\n                    t := mulmod(y, z, p)\\r\\n                    z := mulmod(y, t, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(z, z, p)\\r\\n                    z := mulmod(t, z, p)\\r\\n                }\\r\\n                x := mulmod(x, z, p)\\r\\n                y := mulmod(y, x, p)\\r\\n                x := mulmod(x, y, p)\\r\\n                y := mulmod(y, x, p)\\r\\n                x := mulmod(x, y, p)\\r\\n                z := mulmod(x, x, p)\\r\\n                z := mulmod(x, z, p)\\r\\n                y := mulmod(y, z, p)\\r\\n            }\\r\\n            x := mulmod(x, y, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            x := mulmod(x, x, p)\\r\\n            y := mulmod(y, x, p)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\\r\\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\\r\\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\\r\\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\\r\\n    function getCollectionId(\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256 indexSet\\r\\n    ) internal view returns (bytes32) {\\r\\n        uint256 x1 = uint256(\\r\\n            keccak256(abi.encodePacked(conditionId, indexSet))\\r\\n        );\\r\\n        bool odd = x1 >> 255 != 0;\\r\\n        uint256 y1;\\r\\n        uint256 yy;\\r\\n        do {\\r\\n            x1 = addmod(x1, 1, P);\\r\\n            yy = addmod(mulmod(x1, mulmod(x1, x1, P), P), B, P);\\r\\n            y1 = sqrt(yy);\\r\\n        } while (mulmod(y1, y1, P) != yy);\\r\\n        if ((odd && y1 % 2 == 0) || (!odd && y1 % 2 == 1)) y1 = P - y1;\\r\\n\\r\\n        uint256 x2 = uint256(parentCollectionId);\\r\\n        if (x2 != 0) {\\r\\n            odd = x2 >> 254 != 0;\\r\\n            x2 = (x2 << 2) >> 2;\\r\\n            yy = addmod(mulmod(x2, mulmod(x2, x2, P), P), B, P);\\r\\n            uint256 y2 = sqrt(yy);\\r\\n            if ((odd && y2 % 2 == 0) || (!odd && y2 % 2 == 1)) y2 = P - y2;\\r\\n            require(mulmod(y2, y2, P) == yy, \\\"invalid parentID\\\");\\r\\n\\r\\n            (bool success, bytes memory ret) = address(6).staticcall(\\r\\n                abi.encode(x1, y1, x2, y2)\\r\\n            );\\r\\n            require(success, \\\"ecadd failed\\\");\\r\\n            (x1, y1) = abi.decode(ret, (uint256, uint256));\\r\\n        }\\r\\n\\r\\n        if (y1 % 2 == 1) x1 ^= 1 << 254;\\r\\n\\r\\n        return bytes32(x1);\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\\r\\n    /// @param collateralToken Collateral token which backs the position.\\r\\n    /// @param collectionId ID of the outcome collection associated with this position.\\r\\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(keccak256(abi.encodePacked(collateralToken, collectionId)));\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xe1f65df52607601f45e8a4954ea747c8322d9951ccd8a5d6b292d8f82fd859d4\",\"license\":\"LGPL-3.0\"},\"contracts/conditionalTokens/ConditionalTokens.sol\":{\"content\":\"/** \\r\\n    SPDX-License-Identifier: LGPL-3.0\\r\\n    Copied from Gnosis\\r\\n    Updated for Solidity 0.8.0\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport {ERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\r\\n\\r\\nimport {CTHelpers} from \\\"./CTHelpers.sol\\\";\\r\\n\\r\\n// Mainnet (ID: 1) canonical address: 0xC59b0e4De5F1248C1140964E0fF287B192407E0C\\r\\n// Rinkeby (ID: 4) canonical address: 0x36bede640D19981A82090519bC1626249984c908\\r\\n\\r\\ncontract ConditionalTokens is ERC1155 {\\r\\n    /// @dev Emitted upon the successful preparation of a condition.\\r\\n    /// @param conditionId The condition's ID. This ID may be derived from the other three parameters via ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    event ConditionPreparation(\\r\\n        bytes32 indexed conditionId,\\r\\n        address indexed oracle,\\r\\n        bytes32 indexed questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    );\\r\\n\\r\\n    event ConditionResolution(\\r\\n        bytes32 indexed conditionId,\\r\\n        address indexed oracle,\\r\\n        bytes32 indexed questionId,\\r\\n        uint256 outcomeSlotCount,\\r\\n        uint256[] payoutNumerators\\r\\n    );\\r\\n\\r\\n    /// @dev Emitted when a position is successfully split.\\r\\n    event PositionSplit(\\r\\n        address indexed stakeholder,\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 indexed parentCollectionId,\\r\\n        bytes32 indexed conditionId,\\r\\n        uint256[] partition,\\r\\n        uint256 amount\\r\\n    );\\r\\n    /// @dev Emitted when positions are successfully merged.\\r\\n    event PositionsMerge(\\r\\n        address indexed stakeholder,\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 indexed parentCollectionId,\\r\\n        bytes32 indexed conditionId,\\r\\n        uint256[] partition,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event PayoutRedemption(\\r\\n        address indexed redeemer,\\r\\n        IERC20 indexed collateralToken,\\r\\n        bytes32 indexed parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] indexSets,\\r\\n        uint256 payout\\r\\n    );\\r\\n\\r\\n    /// Mapping key is an condition ID. Value represents numerators of the payout vector associated with the condition. This array is initialized with a length equal to the outcome slot count. E.g. Condition with 3 outcomes [A, B, C] and two of those correct [0.5, 0.5, 0]. In Ethereum there are no decimal values, so here, 0.5 is represented by fractions like 1/2 == 0.5. That's why we need numerator and denominator values. Payout numerators are also used as a check of initialization. If the numerators array is empty (has length zero), the condition was not created/prepared. See getOutcomeSlotCount.\\r\\n    mapping(bytes32 => uint256[]) public payoutNumerators;\\r\\n    /// Denominator is also used for checking if the condition has been resolved. If the denominator is non-zero, then the condition has been resolved.\\r\\n    mapping(bytes32 => uint256) public payoutDenominator;\\r\\n\\r\\n    constructor() ERC1155(\\\"\\\") {}\\r\\n\\r\\n    /// @dev This function prepares a condition by initializing a payout vector associated with the condition.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function prepareCondition(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) external {\\r\\n        // Limit of 256 because we use a partition array that is a number of 256 bits.\\r\\n        require(outcomeSlotCount <= 256, \\\"too many outcome slots\\\");\\r\\n        require(\\r\\n            outcomeSlotCount > 1,\\r\\n            \\\"there should be more than one outcome slot\\\"\\r\\n        );\\r\\n        bytes32 conditionId = CTHelpers.getConditionId(\\r\\n            oracle,\\r\\n            questionId,\\r\\n            outcomeSlotCount\\r\\n        );\\r\\n        require(\\r\\n            payoutNumerators[conditionId].length == 0,\\r\\n            \\\"condition already prepared\\\"\\r\\n        );\\r\\n        payoutNumerators[conditionId] = new uint256[](outcomeSlotCount);\\r\\n        emit ConditionPreparation(\\r\\n            conditionId,\\r\\n            oracle,\\r\\n            questionId,\\r\\n            outcomeSlotCount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``, where oracle is the message sender, questionId is one of the parameters of this function, and outcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.\\r\\n    /// @param questionId The question ID the oracle is answering for\\r\\n    /// @param payouts The oracle's answer\\r\\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts)\\r\\n        external\\r\\n    {\\r\\n        uint256 outcomeSlotCount = payouts.length;\\r\\n        require(\\r\\n            outcomeSlotCount > 1,\\r\\n            \\\"there should be more than one outcome slot\\\"\\r\\n        );\\r\\n        // IMPORTANT, the oracle is enforced to be the sender because it's part of the hash.\\r\\n        bytes32 conditionId = CTHelpers.getConditionId(\\r\\n            msg.sender,\\r\\n            questionId,\\r\\n            outcomeSlotCount\\r\\n        );\\r\\n        require(\\r\\n            payoutNumerators[conditionId].length == outcomeSlotCount,\\r\\n            \\\"condition not prepared or found\\\"\\r\\n        );\\r\\n        require(\\r\\n            payoutDenominator[conditionId] == 0,\\r\\n            \\\"payout denominator already set\\\"\\r\\n        );\\r\\n\\r\\n        uint256 den = 0;\\r\\n        for (uint256 i = 0; i < outcomeSlotCount; i++) {\\r\\n            uint256 num = payouts[i];\\r\\n            den = den + num;\\r\\n\\r\\n            require(\\r\\n                payoutNumerators[conditionId][i] == 0,\\r\\n                \\\"payout numerator already set\\\"\\r\\n            );\\r\\n            payoutNumerators[conditionId][i] = num;\\r\\n        }\\r\\n        require(den > 0, \\\"payout is all zeroes\\\");\\r\\n        payoutDenominator[conditionId] = den;\\r\\n        emit ConditionResolution(\\r\\n            conditionId,\\r\\n            msg.sender,\\r\\n            questionId,\\r\\n            outcomeSlotCount,\\r\\n            payoutNumerators[conditionId]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev This function splits a position. If splitting from the collateral, this contract will attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this contract will burn `amount` stake held by the message sender in the position being split worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the split target positions. If any of the transfers, mints, or burns fail, the transaction will revert. The transaction will also revert if the given partition is trivial, invalid, or refers to more slots than the condition is prepared with.\\r\\n    /// @param collateralToken The address of the positions' backing collateral token.\\r\\n    /// @param parentCollectionId The ID of the outcome collections common to the position being split and the split target positions. May be null, in which only the collateral is shared.\\r\\n    /// @param conditionId The ID of the condition to split on.\\r\\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint). Each element's a number which, together with the condition, represents the outcome collection. E.g. 0b110 is A|B, 0b010 is B, etc.\\r\\n    /// @param amount The amount of collateral or stake to split.\\r\\n    function splitPosition(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata partition,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(partition.length > 1, \\\"got empty or singleton partition\\\");\\r\\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\\r\\n        require(outcomeSlotCount > 0, \\\"condition not prepared yet\\\");\\r\\n\\r\\n        // For a condition with 4 outcomes fullIndexSet's 0b1111; for 5 it's 0b11111...\\r\\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\\r\\n        // freeIndexSet starts as the full collection\\r\\n        uint256 freeIndexSet = fullIndexSet;\\r\\n        // This loop checks that all condition sets are disjoint (the same outcome is not part of more than 1 set)\\r\\n        uint256[] memory positionIds = new uint256[](partition.length);\\r\\n        uint256[] memory amounts = new uint256[](partition.length);\\r\\n        for (uint256 i = 0; i < partition.length; i++) {\\r\\n            uint256 indexSet = partition[i];\\r\\n            require(\\r\\n                indexSet > 0 && indexSet < fullIndexSet,\\r\\n                \\\"got invalid index set\\\"\\r\\n            );\\r\\n            require(\\r\\n                (indexSet & freeIndexSet) == indexSet,\\r\\n                \\\"partition not disjoint\\\"\\r\\n            );\\r\\n            freeIndexSet ^= indexSet;\\r\\n            positionIds[i] = CTHelpers.getPositionId(\\r\\n                collateralToken,\\r\\n                CTHelpers.getCollectionId(\\r\\n                    parentCollectionId,\\r\\n                    conditionId,\\r\\n                    indexSet\\r\\n                )\\r\\n            );\\r\\n            amounts[i] = amount;\\r\\n        }\\r\\n\\r\\n        if (freeIndexSet == 0) {\\r\\n            // Partitioning the full set of outcomes for the condition in this branch\\r\\n            if (parentCollectionId == bytes32(0)) {\\r\\n                require(\\r\\n                    collateralToken.transferFrom(\\r\\n                        msg.sender,\\r\\n                        address(this),\\r\\n                        amount\\r\\n                    ),\\r\\n                    \\\"could not receive collateral tokens\\\"\\r\\n                );\\r\\n            } else {\\r\\n                _burn(\\r\\n                    msg.sender,\\r\\n                    CTHelpers.getPositionId(\\r\\n                        collateralToken,\\r\\n                        parentCollectionId\\r\\n                    ),\\r\\n                    amount\\r\\n                );\\r\\n            }\\r\\n        } else {\\r\\n            // Partitioning a subset of outcomes for the condition in this branch.\\r\\n            // For example, for a condition with three outcomes A, B, and C, this branch\\r\\n            // allows the splitting of a position $:(A|C) to positions $:(A) and $:(C).\\r\\n            _burn(\\r\\n                msg.sender,\\r\\n                CTHelpers.getPositionId(\\r\\n                    collateralToken,\\r\\n                    CTHelpers.getCollectionId(\\r\\n                        parentCollectionId,\\r\\n                        conditionId,\\r\\n                        fullIndexSet ^ freeIndexSet\\r\\n                    )\\r\\n                ),\\r\\n                amount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        _mintBatch(\\r\\n            msg.sender,\\r\\n            // position ID is the ERC 1155 token ID\\r\\n            positionIds,\\r\\n            amounts,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n        emit PositionSplit(\\r\\n            msg.sender,\\r\\n            collateralToken,\\r\\n            parentCollectionId,\\r\\n            conditionId,\\r\\n            partition,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function mergePositions(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata partition,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(partition.length > 1, \\\"got empty or singleton partition\\\");\\r\\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\\r\\n        require(outcomeSlotCount > 0, \\\"condition not prepared yet\\\");\\r\\n\\r\\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\\r\\n        uint256 freeIndexSet = fullIndexSet;\\r\\n        uint256[] memory positionIds = new uint256[](partition.length);\\r\\n        uint256[] memory amounts = new uint256[](partition.length);\\r\\n        for (uint256 i = 0; i < partition.length; i++) {\\r\\n            uint256 indexSet = partition[i];\\r\\n            require(\\r\\n                indexSet > 0 && indexSet < fullIndexSet,\\r\\n                \\\"got invalid index set\\\"\\r\\n            );\\r\\n            require(\\r\\n                (indexSet & freeIndexSet) == indexSet,\\r\\n                \\\"partition not disjoint\\\"\\r\\n            );\\r\\n            freeIndexSet ^= indexSet;\\r\\n            positionIds[i] = CTHelpers.getPositionId(\\r\\n                collateralToken,\\r\\n                CTHelpers.getCollectionId(\\r\\n                    parentCollectionId,\\r\\n                    conditionId,\\r\\n                    indexSet\\r\\n                )\\r\\n            );\\r\\n            amounts[i] = amount;\\r\\n        }\\r\\n        _burnBatch(msg.sender, positionIds, amounts);\\r\\n\\r\\n        if (freeIndexSet == 0) {\\r\\n            if (parentCollectionId == bytes32(0)) {\\r\\n                require(\\r\\n                    collateralToken.transfer(msg.sender, amount),\\r\\n                    \\\"could not send collateral tokens\\\"\\r\\n                );\\r\\n            } else {\\r\\n                _mint(\\r\\n                    msg.sender,\\r\\n                    CTHelpers.getPositionId(\\r\\n                        collateralToken,\\r\\n                        parentCollectionId\\r\\n                    ),\\r\\n                    amount,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n            }\\r\\n        } else {\\r\\n            _mint(\\r\\n                msg.sender,\\r\\n                CTHelpers.getPositionId(\\r\\n                    collateralToken,\\r\\n                    CTHelpers.getCollectionId(\\r\\n                        parentCollectionId,\\r\\n                        conditionId,\\r\\n                        fullIndexSet ^ freeIndexSet\\r\\n                    )\\r\\n                ),\\r\\n                amount,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit PositionsMerge(\\r\\n            msg.sender,\\r\\n            collateralToken,\\r\\n            parentCollectionId,\\r\\n            conditionId,\\r\\n            partition,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function redeemPositions(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata indexSets\\r\\n    ) external {\\r\\n        uint256 den = payoutDenominator[conditionId];\\r\\n        require(den > 0, \\\"result for condition not received yet\\\");\\r\\n        uint256 outcomeSlotCount = payoutNumerators[conditionId].length;\\r\\n        require(outcomeSlotCount > 0, \\\"condition not prepared yet\\\");\\r\\n\\r\\n        uint256 totalPayout = 0;\\r\\n\\r\\n        uint256 fullIndexSet = (1 << outcomeSlotCount) - 1;\\r\\n        for (uint256 i = 0; i < indexSets.length; i++) {\\r\\n            uint256 indexSet = indexSets[i];\\r\\n            require(\\r\\n                indexSet > 0 && indexSet < fullIndexSet,\\r\\n                \\\"got invalid index set\\\"\\r\\n            );\\r\\n            uint256 positionId = CTHelpers.getPositionId(\\r\\n                collateralToken,\\r\\n                CTHelpers.getCollectionId(\\r\\n                    parentCollectionId,\\r\\n                    conditionId,\\r\\n                    indexSet\\r\\n                )\\r\\n            );\\r\\n\\r\\n            uint256 payoutNumerator = 0;\\r\\n            for (uint256 j = 0; j < outcomeSlotCount; j++) {\\r\\n                if (indexSet & (1 << j) != 0) {\\r\\n                    payoutNumerator =\\r\\n                        payoutNumerator +\\r\\n                        payoutNumerators[conditionId][j];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            uint256 payoutStake = balanceOf(msg.sender, positionId);\\r\\n\\r\\n            if (payoutStake > 0) {\\r\\n                totalPayout =\\r\\n                    totalPayout +\\r\\n                    ((payoutStake * payoutNumerator) / den);\\r\\n                _burn(msg.sender, positionId, payoutStake);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (totalPayout > 0) {\\r\\n            if (parentCollectionId == bytes32(0)) {\\r\\n                require(\\r\\n                    collateralToken.transfer(msg.sender, totalPayout),\\r\\n                    \\\"could not transfer payout to message sender\\\"\\r\\n                );\\r\\n            } else {\\r\\n                _mint(\\r\\n                    msg.sender,\\r\\n                    CTHelpers.getPositionId(\\r\\n                        collateralToken,\\r\\n                        parentCollectionId\\r\\n                    ),\\r\\n                    totalPayout,\\r\\n                    \\\"\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        emit PayoutRedemption(\\r\\n            msg.sender,\\r\\n            collateralToken,\\r\\n            parentCollectionId,\\r\\n            conditionId,\\r\\n            indexSets,\\r\\n            totalPayout\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Gets the outcome slot count of a condition.\\r\\n    /// @param conditionId ID of the condition.\\r\\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not been prepared yet.\\r\\n    function getOutcomeSlotCount(bytes32 conditionId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return payoutNumerators[conditionId].length;\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function getConditionId(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) external pure returns (bytes32) {\\r\\n        return CTHelpers.getConditionId(oracle, questionId, outcomeSlotCount);\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\\r\\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\\r\\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\\r\\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\\r\\n    function getCollectionId(\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256 indexSet\\r\\n    ) external view returns (bytes32) {\\r\\n        return\\r\\n            CTHelpers.getCollectionId(\\r\\n                parentCollectionId,\\r\\n                conditionId,\\r\\n                indexSet\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\\r\\n    /// @param collateralToken Collateral token which backs the position.\\r\\n    /// @param collectionId ID of the outcome collection associated with this position.\\r\\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\\r\\n        external\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return CTHelpers.getPositionId(collateralToken, collectionId);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x602a95358d3bb6cac016ffd588dd4e6f22aa4837fde2cdbf2e4e7e4aacee5c3c\",\"license\":\"LGPL-3.0\"},\"contracts/hubs/IPFSSolutionsHub.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../interfaces/ISolverFactory.sol\\\";\\r\\nimport \\\"../interfaces/IProposalsHub.sol\\\";\\r\\nimport \\\"../solvers/Solver.sol\\\";\\r\\nimport \\\"../solvers/SolverLib.sol\\\";\\r\\n\\r\\ncontract IPFSSolutionsHub {\\r\\n    mapping(bytes32 => uint256) public nonces;\\r\\n\\r\\n    ISolverFactory immutable solverFactory;\\r\\n    IProposalsHub immutable proposalsHub;\\r\\n\\r\\n    struct Base {\\r\\n        IERC20 collateralToken;\\r\\n        bytes32 id;\\r\\n        bytes32 solverConfigsHash;\\r\\n        string solverConfigsURI;\\r\\n    }\\r\\n\\r\\n    struct Instance {\\r\\n        bool executed;\\r\\n        bytes32 id;\\r\\n        bytes32 baseId;\\r\\n        address[] solverAddresses;\\r\\n    }\\r\\n\\r\\n    struct Solution {\\r\\n        bool executed;\\r\\n        IERC20 collateralToken;\\r\\n        address proposalsHub;\\r\\n        bytes32 proposalId;\\r\\n        bytes32 id;\\r\\n        bytes32 solverConfigsHash;\\r\\n        string solverConfigsURI;\\r\\n        address[] solverAddresses;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32 => Base) public bases;\\r\\n    mapping(bytes32 => Instance) public instances;\\r\\n\\r\\n    mapping(bytes32 => bytes32) public instanceId_to_ProposalId;\\r\\n\\r\\n    event CreateBase(bytes32 id);\\r\\n    event CreateSolution(bytes32 id);\\r\\n    event ExecuteSolution(bytes32 id);\\r\\n    event ErrorNotHandled(bytes reason);\\r\\n\\r\\n    constructor(\\r\\n        ISolverFactory factoryAddress,\\r\\n        IProposalsHub proposalsHubAddress\\r\\n    ) {\\r\\n        solverFactory = factoryAddress;\\r\\n        proposalsHub = proposalsHubAddress;\\r\\n    }\\r\\n\\r\\n    function linkToProposal(\\r\\n        bytes32 proposalId,\\r\\n        bytes32 solutionId,\\r\\n        IERC20 collateralToken\\r\\n    ) external {\\r\\n        require(\\r\\n            proposalsHub.isProposal(proposalId),\\r\\n            \\\"Proposal is not valid at proposalsHub\\\"\\r\\n        );\\r\\n        require(\\r\\n            bases[instances[solutionId].baseId].collateralToken ==\\r\\n                collateralToken,\\r\\n            \\\"Wrong collateral token\\\"\\r\\n        );\\r\\n\\r\\n        instanceId_to_ProposalId[solutionId] = proposalId;\\r\\n    }\\r\\n\\r\\n    function deploySolverChain(\\r\\n        bytes32 _solutionId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) private {\\r\\n        address _solverAddress;\\r\\n\\r\\n        for (uint256 i; i < solverConfigs.length; i++) {\\r\\n            if (i == 0) {\\r\\n                _solverAddress = solverFactory.createSolver(\\r\\n                    address(0),\\r\\n                    i,\\r\\n                    solverConfigs[i]\\r\\n                );\\r\\n\\r\\n                require(\\r\\n                    _solverAddress != address(0),\\r\\n                    \\\"Invalid address for Solver\\\"\\r\\n                );\\r\\n            } else {\\r\\n                _solverAddress = Solver(_solverAddress).deployChild(\\r\\n                    solverConfigs[i]\\r\\n                );\\r\\n            }\\r\\n            instances[_solutionId].solverAddresses.push(_solverAddress);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Ceramic Interop: baseId == keccak256(abi.encode(templateCommitID, proposalCommitID))\\r\\n    function createBase(\\r\\n        bytes32 baseId,\\r\\n        IERC20 collateralToken,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        string calldata solverConfigsURI\\r\\n    ) public returns (bytes32 safeBaseId) {\\r\\n        nonces[baseId]++;\\r\\n        safeBaseId = keccak256(abi.encode(baseId, nonces[baseId]));\\r\\n\\r\\n        require(bases[safeBaseId].id != safeBaseId, \\\"Base ID already exists\\\");\\r\\n\\r\\n        Base storage base = bases[safeBaseId];\\r\\n        base.id = safeBaseId;\\r\\n        base.collateralToken = collateralToken;\\r\\n        base.solverConfigsHash = keccak256(abi.encode(solverConfigs));\\r\\n        base.solverConfigsURI = solverConfigsURI;\\r\\n        emit CreateBase(safeBaseId);\\r\\n    }\\r\\n\\r\\n    function createInstance(bytes32 baseId)\\r\\n        public\\r\\n        returns (bytes32 solutionId)\\r\\n    {\\r\\n        nonces[baseId]++;\\r\\n\\r\\n        bytes32 instanceId = keccak256(\\r\\n            abi.encode(baseId, nonces[baseId], blockhash(block.number - 1))\\r\\n        );\\r\\n        require(\\r\\n            instances[instanceId].id != instanceId,\\r\\n            \\\"Instance ID already exists\\\"\\r\\n        );\\r\\n        require(bases[baseId].id != bytes32(\\\"\\\"), \\\"Base not found\\\");\\r\\n\\r\\n        Instance storage instance = instances[instanceId];\\r\\n        instance.id = instanceId;\\r\\n        instance.baseId = baseId;\\r\\n\\r\\n        emit CreateSolution(instanceId);\\r\\n        return instanceId;\\r\\n    }\\r\\n\\r\\n    function createSolution(\\r\\n        bytes32 baseId,\\r\\n        IERC20 collateralToken,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        string calldata solverConfigsURI\\r\\n    ) public returns (bytes32 instanceId) {\\r\\n        require(\\r\\n            instances[instanceId].id != instanceId,\\r\\n            \\\"SolutionsHub::Instance ID already exists\\\"\\r\\n        );\\r\\n        createBase(baseId, collateralToken, solverConfigs, solverConfigsURI);\\r\\n        instanceId = createInstance(baseId);\\r\\n\\r\\n        emit CreateSolution(instanceId);\\r\\n    }\\r\\n\\r\\n    function executeSolution(\\r\\n        bytes32 proposalId,\\r\\n        bytes32 solutionId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) external {\\r\\n        require(\\r\\n            verifyHash(instances[solutionId].baseId, solverConfigs),\\r\\n            \\\"Incorrect SolverConfig content\\\"\\r\\n        );\\r\\n        require(\\r\\n            msg.sender == address(proposalsHub),\\r\\n            \\\"Not correct proposalsHub\\\"\\r\\n        );\\r\\n        require(\\r\\n            instanceId_to_ProposalId[solutionId] == proposalId,\\r\\n            \\\"Wrong proposalId\\\"\\r\\n        );\\r\\n        require(\\r\\n            instances[solutionId].executed == false,\\r\\n            \\\"Solution already executed\\\"\\r\\n        );\\r\\n\\r\\n        instances[solutionId].executed = true;\\r\\n\\r\\n        deploySolverChain(solutionId, solverConfigs);\\r\\n\\r\\n        IProposalsHub(msg.sender).transferERC20(\\r\\n            proposalId,\\r\\n            instances[solutionId].solverAddresses[0]\\r\\n        );\\r\\n\\r\\n        for (uint256 i; i < instances[solutionId].solverAddresses.length; i++) {\\r\\n            ISolver _solver = ISolver(instances[solutionId].solverAddresses[i]);\\r\\n            _solver.setTrackingId(instanceId_to_ProposalId[solutionId]);\\r\\n        }\\r\\n        // Prepare first Solver\\r\\n        ISolver(instances[solutionId].solverAddresses[0]).prepareSolve(0);\\r\\n\\r\\n        if (\\r\\n            ISolver(instances[solutionId].solverAddresses[0]).ingestsValid() &&\\r\\n            ISolver(instances[solutionId].solverAddresses[0]).allocationsValid(\\r\\n                0\\r\\n            )\\r\\n        ) {\\r\\n            ISolver(instances[solutionId].solverAddresses[0]).executeSolve(0);\\r\\n        }\\r\\n\\r\\n        emit ExecuteSolution(solutionId);\\r\\n    }\\r\\n\\r\\n    function verifyHash(bytes32 baseId, SolverLib.Config[] memory solverConfigs)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return\\r\\n            bases[baseId].solverConfigsHash ==\\r\\n            keccak256(abi.encode(solverConfigs));\\r\\n    }\\r\\n\\r\\n    function solverFromIndex(bytes32 solutionId, uint256 index)\\r\\n        public\\r\\n        view\\r\\n        returns (address solverAddress)\\r\\n    {\\r\\n        if (instances[solutionId].solverAddresses.length > 0) {\\r\\n            return instances[solutionId].solverAddresses[index];\\r\\n        } else {\\r\\n            return address(0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getSolvers(bytes32 solutionId)\\r\\n        public\\r\\n        view\\r\\n        returns (address[] memory solvers)\\r\\n    {\\r\\n        solvers = instances[solutionId].solverAddresses;\\r\\n    }\\r\\n\\r\\n    function getSolution(bytes32 instanceId)\\r\\n        public\\r\\n        view\\r\\n        returns (Solution memory solution)\\r\\n    {\\r\\n        Instance memory instance = instances[instanceId];\\r\\n        Base memory base = bases[instance.baseId];\\r\\n\\r\\n        solution.id = instance.id;\\r\\n        solution.executed = instance.executed;\\r\\n        solution.collateralToken = base.collateralToken;\\r\\n        solution.proposalId = instanceId_to_ProposalId[instanceId];\\r\\n        solution.solverConfigsHash = base.solverConfigsHash;\\r\\n        solution.solverConfigsURI = base.solverConfigsURI;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x82a501a5485b56e789ea1053cfb73960d678cb4aace20310c339fbc7264adbd2\",\"license\":\"GPL-3.0\"},\"contracts/hubs/ProposalsHub.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\\\";\\r\\n\\r\\nimport \\\"../interfaces/IIPFSSolutionsHub.sol\\\";\\r\\nimport \\\"../interfaces/IConditionalTokens.sol\\\";\\r\\n\\r\\nimport \\\"../solvers/SolverLib.sol\\\";\\r\\n\\r\\nimport \\\"../ABDKMath64x64.sol\\\";\\r\\n\\r\\ncontract ProposalsHub is ERC1155Receiver {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    // Used to allow funders to reclaim conditional tokens sent to this address\\r\\n    IConditionalTokens public immutable conditionalTokens;\\r\\n\\r\\n    // Increment for unique proposal IDs\\r\\n    mapping(bytes32 => uint256) public nonces;\\r\\n\\r\\n    struct Proposal {\\r\\n        bool isExecuted;\\r\\n        IERC20 collateralToken;\\r\\n        address proposer;\\r\\n        address solutionsHub;\\r\\n        bytes32 id;\\r\\n        bytes32 solutionId;\\r\\n        uint256 funding;\\r\\n        uint256 fundingGoal;\\r\\n        string metadataURI;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32 => Proposal) public proposals;\\r\\n    mapping(bytes32 => mapping(address => uint256)) public funderAmountMap;\\r\\n\\r\\n    // Used to allow funders to reclaim conditional tokens sent to this address\\r\\n    mapping(bytes32 => mapping(uint256 => uint256)) public reclaimableTokens;\\r\\n    mapping(uint256 => mapping(address => uint256)) public reclaimedTokens;\\r\\n\\r\\n    event CreateProposal(bytes32 indexed id);\\r\\n    event ExecuteProposal(bytes32 indexed id);\\r\\n    event FundProposal(bytes32 indexed id, uint256 amount, address from);\\r\\n    event DefundProposal(bytes32 indexed id, uint256 amount, address to);\\r\\n\\r\\n    constructor(address _ctfAddress) {\\r\\n        conditionalTokens = IConditionalTokens(_ctfAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Executes a proposal for Solutions where on the *hash* of solver configs is stored on-chain\\r\\n        @param proposalId ID of proposal\\r\\n        @param solverConfigs Configurations of Solvers to be run for the proposed solution\\r\\n     */\\r\\n    function executeIPFSProposal(\\r\\n        bytes32 proposalId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) external {\\r\\n        require(\\r\\n            proposals[proposalId].funding >= proposals[proposalId].fundingGoal,\\r\\n            \\\"Proposal not fully funded\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[proposalId].isExecuted == false,\\r\\n            \\\"ProposalsHub::Proposal already executed\\\"\\r\\n        );\\r\\n\\r\\n        proposals[proposalId].isExecuted = true;\\r\\n\\r\\n        IIPFSSolutionsHub(proposals[proposalId].solutionsHub).executeSolution(\\r\\n            proposalId,\\r\\n            proposals[proposalId].solutionId,\\r\\n            solverConfigs\\r\\n        );\\r\\n\\r\\n        emit ExecuteProposal(proposalId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called by SolutionsHub after deploying Solvers\\r\\n        @param proposalId Proposal that collateral is being transferred from\\r\\n        @param solver Solver receiving collateral\\r\\n     */\\r\\n    function transferERC20(bytes32 proposalId, address solver) external {\\r\\n        require(\\r\\n            msg.sender == proposals[proposalId].solutionsHub,\\r\\n            \\\"msg.sender not solutionsHub\\\"\\r\\n        );\\r\\n        require(solver != address(0), \\\"Invalid address\\\");\\r\\n        require(\\r\\n            IIPFSSolutionsHub(proposals[proposalId].solutionsHub)\\r\\n                .solverFromIndex(proposals[proposalId].solutionId, 0) == solver,\\r\\n            \\\"Incorrect solver address\\\"\\r\\n        );\\r\\n\\r\\n        IERC20 _token = IERC20(proposals[proposalId].collateralToken);\\r\\n        uint256 beforeBalance = _token.balanceOf(address(this));\\r\\n        _token.safeTransfer(solver, proposals[proposalId].funding);\\r\\n        require(\\r\\n            beforeBalance - _token.balanceOf(address(this)) ==\\r\\n                proposals[proposalId].fundingGoal,\\r\\n            \\\"Incorrect balance after transfer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Creates a Proposal from an existing Solution.Base\\r\\n        @param collateralToken ERC20 token being used as collateral for conditional tokens\\r\\n        @param solutionsHub Address of the SolutionsHub contract managing the Solution\\r\\n        @param fundingGoal Amount of ERC20 collateral requested for the Proposal\\r\\n        @param safeBaseId ID of the Solution.Base for which a new instance and proposal is created\\r\\n        @notice Ceramic Interop: safeBaseId == keccak256(abi.encode(keccak256(abi.encode(templateCommitID, proposalCommitID)), nonce))\\r\\n    */\\r\\n    function createProposal(\\r\\n        IERC20 collateralToken,\\r\\n        address solutionsHub,\\r\\n        uint256 fundingGoal,\\r\\n        bytes32 safeBaseId,\\r\\n        SolverLib.Config[] memory solverConfigs,\\r\\n        string calldata metadataURI\\r\\n    ) public returns (bytes32 solutionId, bytes32 proposalId) {\\r\\n        require(\\r\\n            IIPFSSolutionsHub(solutionsHub).verifyHash(\\r\\n                safeBaseId,\\r\\n                solverConfigs\\r\\n            ),\\r\\n            \\\"Incorrect Solver Configs\\\"\\r\\n        );\\r\\n\\r\\n        nonces[safeBaseId]++; // Prevents DOS by frontrunning safeBaseId\\r\\n\\r\\n        proposalId = keccak256(\\r\\n            abi.encode(safeBaseId, metadataURI, nonces[safeBaseId])\\r\\n        );\\r\\n\\r\\n        solutionId = IIPFSSolutionsHub(solutionsHub).createInstance(safeBaseId);\\r\\n\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        proposal.id = proposalId;\\r\\n\\r\\n        IIPFSSolutionsHub(solutionsHub).linkToProposal(\\r\\n            proposalId,\\r\\n            solutionId,\\r\\n            collateralToken\\r\\n        );\\r\\n\\r\\n        proposal.collateralToken = collateralToken;\\r\\n        proposal.proposer = msg.sender;\\r\\n        proposal.solutionsHub = solutionsHub;\\r\\n        proposal.solutionId = solutionId;\\r\\n        proposal.fundingGoal = fundingGoal;\\r\\n        proposal.metadataURI = metadataURI;\\r\\n\\r\\n        emit CreateProposal(proposalId);\\r\\n\\r\\n        return (solutionId, proposalId);\\r\\n    }\\r\\n\\r\\n    function createIPFSSolutionAndProposal(\\r\\n        bytes32 baseId,\\r\\n        IERC20 collateralToken,\\r\\n        IIPFSSolutionsHub ipfsSolutionsHub,\\r\\n        uint256 fundingGoal,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        string calldata solverConfigsURI,\\r\\n        string calldata metadataURI\\r\\n    ) external returns (bytes32 solutionId, bytes32 proposalId) {\\r\\n        bytes32 safeBaseId = ipfsSolutionsHub.createBase(\\r\\n            baseId,\\r\\n            collateralToken,\\r\\n            solverConfigs,\\r\\n            solverConfigsURI\\r\\n        );\\r\\n\\r\\n        (solutionId, proposalId) = createProposal(\\r\\n            collateralToken,\\r\\n            address(ipfsSolutionsHub),\\r\\n            fundingGoal,\\r\\n            safeBaseId,\\r\\n            solverConfigs,\\r\\n            metadataURI\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called by user to add funding to a Proposal\\r\\n        @param proposalId ID of Proposal being funded\\r\\n        @param token ERC20 token to be funded with\\r\\n        @param amount Amount to be funded\\r\\n    */\\r\\n    function fundProposal(\\r\\n        bytes32 proposalId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(proposals[proposalId].id != 0, \\\"Proposal does not exist\\\");\\r\\n        require(\\r\\n            proposals[proposalId].isExecuted == false,\\r\\n            \\\"ProposalsHub::Proposal already executed\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[proposalId].collateralToken == token,\\r\\n            \\\"Proposal does not include this token to be funded\\\"\\r\\n        );\\r\\n        require(amount > 0, \\\"Amount cannot be zero\\\");\\r\\n        require(\\r\\n            amount + proposals[proposalId].funding <=\\r\\n                proposals[proposalId].fundingGoal,\\r\\n            \\\"Can't fund more than goal\\\"\\r\\n        );\\r\\n\\r\\n        uint256 beforeBalance = token.balanceOf(address(this));\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        require(\\r\\n            token.balanceOf(address(this)) - beforeBalance == amount,\\r\\n            \\\"Incorrect balance after transfer\\\"\\r\\n        );\\r\\n\\r\\n        proposals[proposalId].funding += amount;\\r\\n        funderAmountMap[proposalId][msg.sender] += amount;\\r\\n\\r\\n        emit FundProposal(proposalId, amount, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called by user to remove their funding from a Proposal\\r\\n        @param proposalId ID of Proposal being defunded\\r\\n        @param token ERC20 token to be defunded\\r\\n        @param amount Amount to be defunded\\r\\n    */\\r\\n    function defundProposal(\\r\\n        bytes32 proposalId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(proposals[proposalId].id != 0, \\\"Proposal does not exist\\\");\\r\\n        require(\\r\\n            proposals[proposalId].isExecuted == false,\\r\\n            \\\"ProposalsHub::Proposal already executed\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[proposalId].collateralToken == token,\\r\\n            \\\"Proposal does not include this token to be funded\\\"\\r\\n        );\\r\\n        require(amount > 0, \\\"Amount cannot be zero\\\");\\r\\n        require(\\r\\n            amount <= funderAmountMap[proposalId][msg.sender],\\r\\n            \\\"Committed funds is lower than amount.\\\"\\r\\n        );\\r\\n        uint256 beforeBalance = token.balanceOf(address(this));\\r\\n\\r\\n        proposals[proposalId].funding -= amount;\\r\\n        funderAmountMap[proposalId][msg.sender] -= amount;\\r\\n\\r\\n        token.safeTransfer(msg.sender, amount);\\r\\n\\r\\n        require(\\r\\n            beforeBalance - token.balanceOf(address(this)) == amount,\\r\\n            \\\"Before and after balance wrong\\\"\\r\\n        );\\r\\n\\r\\n        emit DefundProposal(proposalId, amount, msg.sender);\\r\\n    }\\r\\n\\r\\n    function getProposal(bytes32 id)\\r\\n        external\\r\\n        view\\r\\n        returns (Proposal memory proposal)\\r\\n    {\\r\\n        return proposals[id];\\r\\n    }\\r\\n\\r\\n    function getMetadataCID(bytes32 id) external view returns (string memory) {\\r\\n        return proposals[id].metadataURI;\\r\\n    }\\r\\n\\r\\n    function isProposal(bytes32 id) external view returns (bool) {\\r\\n        return proposals[id].id != bytes32(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Called when contract receives ERC1155 with data referring to a proposalId\\r\\n        @param proposalId ID of proposal being referred to by tx\\r\\n        @param tokenId ID of ERC1155 token that was received\\r\\n        @param amount Amount of token received\\r\\n     */\\r\\n    function postReclaimableTokens(\\r\\n        bytes32 proposalId,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        reclaimableTokens[proposalId][tokenId] += amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Transfers reclaimable CTs to a claimer and lowers their reclaimable balance for that token\\r\\n        @param proposalId ID of proposal being reclaimed from\\r\\n        @param tokenId ERC1155 token being reclaimed\\r\\n     */\\r\\n    function reclaimTokens(bytes32 proposalId, uint256 tokenId) external {\\r\\n        require(\\r\\n            funderAmountMap[proposalId][msg.sender] > 0,\\r\\n            \\\"ProposalsHub::msg.sender has no claim\\\"\\r\\n        );\\r\\n\\r\\n        int128 _coefficient = ABDKMath64x64.divu(\\r\\n            funderAmountMap[proposalId][msg.sender],\\r\\n            proposals[proposalId].funding\\r\\n        );\\r\\n\\r\\n        uint256 _claimAmount = ABDKMath64x64.mulu(\\r\\n            _coefficient,\\r\\n            reclaimableTokens[proposalId][tokenId]\\r\\n        ) - reclaimedTokens[tokenId][msg.sender];\\r\\n\\r\\n        require(_claimAmount > 0, \\\"ProposalsHub::Claim is 0\\\");\\r\\n        require(\\r\\n            _claimAmount <= reclaimableTokens[proposalId][tokenId],\\r\\n            \\\"ProposalsHub::Claim is too large\\\"\\r\\n        );\\r\\n        reclaimedTokens[tokenId][msg.sender] += _claimAmount;\\r\\n\\r\\n        conditionalTokens.safeTransferFrom(\\r\\n            address(this),\\r\\n            msg.sender,\\r\\n            tokenId,\\r\\n            _claimAmount,\\r\\n            abi.encode(proposalId)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        IMPORTANT!\\r\\n        Any CTs sent to this contract are reclaimable by the funders in proportion to their funding.\\r\\n        If a user reclaims CTs and sends them back again to this contract, they will only be able to \\r\\n        regain from them a fraction of their original funding.\\r\\n    */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external virtual override returns (bytes4) {\\r\\n        bytes32 _proposalId = abi.decode(data, (bytes32));\\r\\n        require(\\r\\n            proposals[_proposalId].id == _proposalId,\\r\\n            \\\"ProposalsHub::Data is not valid proposalId\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[_proposalId].isExecuted,\\r\\n            \\\"ProposalsHub::Proposal has not been executed\\\"\\r\\n        );\\r\\n        postReclaimableTokens(_proposalId, id, value);\\r\\n\\r\\n        return this.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external virtual override returns (bytes4) {\\r\\n        bytes32 _proposalId = abi.decode(data, (bytes32));\\r\\n        require(\\r\\n            proposals[_proposalId].id == _proposalId,\\r\\n            \\\"ProposalsHub::Data is not valid proposalId\\\"\\r\\n        );\\r\\n        require(\\r\\n            proposals[_proposalId].isExecuted,\\r\\n            \\\"ProposalsHub::Proposal has not been executed\\\"\\r\\n        );\\r\\n        for (uint256 i; i < ids.length; i++) {\\r\\n            postReclaimableTokens(_proposalId, ids[i], values[i]);\\r\\n        }\\r\\n        return this.onERC1155BatchReceived.selector;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xb9fa519aa40e8a2b9173e057c0b0b8121380e660e43b76ba1090976af37cd30e\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IConditionalTokens.sol\":{\"content\":\"/** \\r\\n    SPDX-License-Identifier: LGPL-3.0\\r\\n*/\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\n\\r\\n// Mainnet (ID: 1) canonical address: 0xC59b0e4De5F1248C1140964E0fF287B192407E0C\\r\\n// Rinkeby (ID: 4) canonical address: 0x36bede640D19981A82090519bC1626249984c908\\r\\n\\r\\ninterface IConditionalTokens is IERC1155 {\\r\\n    /// @dev This function prepares a condition by initializing a payout vector associated with the condition.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function prepareCondition(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) external;\\r\\n\\r\\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``, where oracle is the message sender, questionId is one of the parameters of this function, and outcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.\\r\\n    /// @param questionId The question ID the oracle is answering for\\r\\n    /// @param payouts The oracle's answer\\r\\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts)\\r\\n        external;\\r\\n\\r\\n    /// @dev This function splits a position. If splitting from the collateral, this contract will attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this contract will burn `amount` stake held by the message sender in the position being split worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the split target positions. If any of the transfers, mints, or burns fail, the transaction will revert. The transaction will also revert if the given partition is trivial, invalid, or refers to more slots than the condition is prepared with.\\r\\n    /// @param collateralToken The address of the positions' backing collateral token.\\r\\n    /// @param parentCollectionId The ID of the outcome collections common to the position being split and the split target positions. May be null, in which only the collateral is shared.\\r\\n    /// @param conditionId The ID of the condition to split on.\\r\\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint). Each element's a number which, together with the condition, represents the outcome collection. E.g. 0b110 is A|B, 0b010 is B, etc.\\r\\n    /// @param amount The amount of collateral or stake to split.\\r\\n    function splitPosition(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata partition,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function mergePositions(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata partition,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function redeemPositions(\\r\\n        IERC20 collateralToken,\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256[] calldata indexSets\\r\\n    ) external;\\r\\n\\r\\n    /// @dev Gets the outcome slot count of a condition.\\r\\n    /// @param conditionId ID of the condition.\\r\\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not been prepared yet.\\r\\n    function getOutcomeSlotCount(bytes32 conditionId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\\r\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\r\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\r\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\\r\\n    function getConditionId(\\r\\n        address oracle,\\r\\n        bytes32 questionId,\\r\\n        uint256 outcomeSlotCount\\r\\n    ) external pure returns (bytes32);\\r\\n\\r\\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\\r\\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\\r\\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\\r\\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\\r\\n    function getCollectionId(\\r\\n        bytes32 parentCollectionId,\\r\\n        bytes32 conditionId,\\r\\n        uint256 indexSet\\r\\n    ) external view returns (bytes32);\\r\\n\\r\\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\\r\\n    /// @param collateralToken Collateral token which backs the position.\\r\\n    /// @param collectionId ID of the outcome collection associated with this position.\\r\\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId)\\r\\n        external\\r\\n        pure\\r\\n        returns (uint256);\\r\\n}\\r\\n\",\"keccak256\":\"0x72f8f9f2bd693fc5e2086cf13c3bfcf581142f82cf91bb1638fd3c90d17bd8dc\",\"license\":\"LGPL-3.0\"},\"contracts/interfaces/IIPFSSolutionsHub.sol\":{\"content\":\"pragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../hubs/IPFSSolutionsHub.sol\\\";\\r\\nimport \\\"../solvers/SolverLib.sol\\\";\\r\\n\\r\\ninterface IIPFSSolutionsHub {\\r\\n    function createBase(\\r\\n        bytes32 baseId,\\r\\n        IERC20 collateralToken,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        string calldata solverConfigsURI\\r\\n    ) external returns (bytes32 safeBaseId);\\r\\n\\r\\n    function createInstance(bytes32 baseId)\\r\\n        external\\r\\n        returns (bytes32 solutionId);\\r\\n\\r\\n    function createSolution(\\r\\n        bytes32 _id,\\r\\n        IERC20 _collateralToken,\\r\\n        SolverLib.Config[] calldata _solverConfigs,\\r\\n        string calldata _solverConfigsURI\\r\\n    ) external returns (bytes32 _solutionId);\\r\\n\\r\\n    function linkToProposal(\\r\\n        bytes32 proposalId,\\r\\n        bytes32 solutionId,\\r\\n        IERC20 collateralToken\\r\\n    ) external;\\r\\n\\r\\n    function executeSolution(\\r\\n        bytes32 _proposalId,\\r\\n        bytes32 _solutionId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) external;\\r\\n\\r\\n    function solverFromIndex(bytes32 _solutionId, uint256 _solverIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (address solver);\\r\\n\\r\\n    function getSolvers(bytes32 _solutionId)\\r\\n        external\\r\\n        view\\r\\n        returns (address[] memory solvers);\\r\\n\\r\\n    function verifyHash(\\r\\n        bytes32 solutionId,\\r\\n        SolverLib.Config[] memory solverConfigs\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function getSolution(bytes32 id)\\r\\n        external\\r\\n        view\\r\\n        returns (IPFSSolutionsHub.Solution memory);\\r\\n}\\r\\n\",\"keccak256\":\"0x643fa96d0c0c337bd0e90cf7d4b386567776d45d177f4f350a55c583bb8afe35\"},\"contracts/interfaces/IModule.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\ninterface IModule is IERC165 {\\r\\n    function load(bytes calldata data) external;\\r\\n\\r\\n    function fetchPermits() external view returns (bytes4[] memory);\\r\\n\\r\\n    function isPermitted(bytes4 selector) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x7c626cbaf96748eb728ac403c10f5618e9cb1a178ff363abdafb7de503252c06\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IProposalsHub.sol\":{\"content\":\"pragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../solvers/SolverLib.sol\\\";\\r\\nimport \\\"../hubs/ProposalsHub.sol\\\";\\r\\nimport \\\"./IIPFSSolutionsHub.sol\\\";\\r\\n\\r\\ninterface IProposalsHub {\\r\\n    function executeProposal(bytes32 proposalId) external;\\r\\n\\r\\n    function executeIPFSProposal(\\r\\n        bytes32 proposalId,\\r\\n        SolverLib.Config[] calldata solverConfigs\\r\\n    ) external;\\r\\n\\r\\n    function approveERC20Transfer(bytes32 proposalId, address solver) external;\\r\\n\\r\\n    function createProposal(\\r\\n        IERC20 collateralToken,\\r\\n        address solutionsHub,\\r\\n        uint256 fundingGoal,\\r\\n        bytes32 safeBaseId,\\r\\n        SolverLib.Config[] memory solverConfigs,\\r\\n        string calldata metadataURI\\r\\n    ) external;\\r\\n\\r\\n    function createIPFSSolutionAndProposal(\\r\\n        bytes32 solutionId,\\r\\n        IERC20 collateralToken,\\r\\n        IIPFSSolutionsHub ipfsSolutionsHub,\\r\\n        uint256 fundingGoal,\\r\\n        SolverLib.Config[] calldata solverConfigs,\\r\\n        string calldata solverConfigsURI,\\r\\n        string calldata metadataURI\\r\\n    ) external returns (bytes32 solutionID, bytes32 proposalID);\\r\\n\\r\\n    function fundProposal(\\r\\n        bytes32 proposalId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function defundProposal(\\r\\n        bytes32 proposalId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function getMetadataCID(bytes32 id) external view returns (string memory);\\r\\n\\r\\n    function isProposal(bytes32 id) external view returns (bool);\\r\\n\\r\\n    function getProposal(bytes32 id)\\r\\n        external\\r\\n        view\\r\\n        returns (ProposalsHub.Proposal memory proposal);\\r\\n\\r\\n    function transferERC20(bytes32 proposalId, address solver) external;\\r\\n\\r\\n    function reclaimTokens(bytes32 proposalId, uint256 tokenId) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xf19e679721868cfc86c0cc8abeea7e043c2eca156b59805d764faa47d5a7b19e\"},\"contracts/interfaces/ISolver.sol\":{\"content\":\"pragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../conditionalTokens/ConditionalTokens.sol\\\";\\r\\nimport \\\"../solvers/Solver.sol\\\";\\r\\nimport \\\"../solvers/SolverLib.sol\\\";\\r\\n\\r\\ninterface ISolver {\\r\\n    /**\\r\\n        @notice Called by SolverFactory when contract is created. Nothing else should ever need to call this\\r\\n        @dev initializer\\r\\n        @param _chainParent The address of the Solver above this one in the chain. address(0) if this Solver is first.\\r\\n        @param _chainIndex The index of this Solver in the chain\\r\\n        @param _solverConfig The configuration of this Solver\\r\\n    */\\r\\n    function init(\\r\\n        address _deployer,\\r\\n        address _ctfAddress,\\r\\n        address _chainParent,\\r\\n        uint256 _chainIndex,\\r\\n        SolverLib.Config calldata _solverConfig\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n        @notice Creates a new condition, associated timelock, and executes ingests for this Solver and any child Solvers\\r\\n        @param _index Index of the new condition to be created.\\r\\n    */\\r\\n    function prepareSolve(uint256 _index) external;\\r\\n\\r\\n    /**\\r\\n        @notice Deploys a new Solver as a child\\r\\n        @param _config Configuration of the child Solver\\r\\n        @return address\\r\\n    */\\r\\n    function deployChild(SolverLib.Config calldata _config)\\r\\n        external\\r\\n        returns (address);\\r\\n\\r\\n    /**\\r\\n        @notice Mints conditional tokens, allocates them to recipients specified by ingested data, runs arbitrary `postroll()` function and tries to do the same for child Solver\\r\\n        @dev require(ingestsValid())\\r\\n        @param _index Index of condition to execute on\\r\\n     */\\r\\n    function executeSolve(uint256 _index) external;\\r\\n\\r\\n    /**\\r\\n        @notice Verifies that all ingests have been performed for a condition\\r\\n        @return bool\\r\\n     */\\r\\n    function ingestsValid() external view returns (bool);\\r\\n\\r\\n    /**\\r\\n        @notice Verifies that all slots corresponding to recipients have been filled before CT allocation\\r\\n        @param _index Condition index\\r\\n        @return bool\\r\\n     */\\r\\n    function allocationsValid(uint256 _index) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n        @notice Allows keeper to manually add data to IngestType.Manual slots after executeIngests\\r\\n        @dev Only Keeper, only manual slots\\r\\n        @param _slot Destination slot\\r\\n        @param _data Data to be added\\r\\n     */\\r\\n    function addData(bytes32 _slot, bytes memory _data) external;\\r\\n\\r\\n    /**\\r\\n        @notice Get most recent data of a slot\\r\\n        @param _slot slotId\\r\\n        @return data\\r\\n     */\\r\\n    function getData(bytes32 _slot) external view returns (bytes memory data);\\r\\n\\r\\n    /**\\r\\n        @notice Get data for each condition from a slot\\r\\n        @param _slot slotId\\r\\n        @return data\\r\\n     */\\r\\n    function getAllData(bytes32 _slot)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes[] memory data);\\r\\n\\r\\n    /**\\r\\n        @notice Register callback expected by a downstream Solver for some data\\r\\n        @dev only downstream Solver\\r\\n        @param _slot Slot being waited on by downstream Solver\\r\\n        @param _chainIndex Index of the Solver requesting this callback\\r\\n     */\\r\\n    function registerOutgoingCallback(bytes32 _slot, uint256 _chainIndex)\\r\\n        external;\\r\\n\\r\\n    /**\\r\\n        @notice Handle upstream Solver making callback and ingest the data\\r\\n        @dev only upstream Solver\\r\\n        @param _slot Destination slot for the data being sent\\r\\n     */\\r\\n    function handleCallback(bytes32 _slot) external;\\r\\n\\r\\n    /**\\r\\n        @notice A simple getter that requires upstream slot ver. == our condition ver.\\r\\n        @param _slot Slot containing data\\r\\n        @return data\\r\\n     */\\r\\n    function getCallbackOutput(bytes32 _slot)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes memory data);\\r\\n\\r\\n    /**\\r\\n        @notice Propose payouts (AKA outcomes) for a condition\\r\\n        @param _index Index of condition\\r\\n        @param _payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\\r\\n     */\\r\\n    function proposePayouts(uint256 _index, uint256[] calldata _payouts)\\r\\n        external;\\r\\n\\r\\n    /**\\r\\n        @notice Confirm payouts for condition (reportPayouts to ConditionalTokens contract)\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function confirmPayouts(uint256 _index) external;\\r\\n\\r\\n    /**\\r\\n        @notice Sets condition.status to ArbitrationRequested.\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function requestArbitration(uint256 _index) external;\\r\\n\\r\\n    /**\\r\\n        @notice Allows arbitrator to unilaterally make a payout report.\\r\\n        @param _index Index of condition\\r\\n        @param payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\\r\\n     */\\r\\n    function arbitrate(uint256 _index, uint256[] memory payouts) external;\\r\\n\\r\\n    /**\\r\\n        @notice Returns condition.status to OutcomeProposed without a ruling.\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function arbitrateNull(uint256 _index) external;\\r\\n\\r\\n    /**\\r\\n        @notice Get address for a Solver by its index in the chain\\r\\n        @param _index Index of Solver\\r\\n        @return _address\\r\\n     */\\r\\n    function addressFromChainIndex(uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (address _address);\\r\\n\\r\\n    /**\\r\\n        @notice Get condition\\r\\n        @param index Index of condition\\r\\n     */\\r\\n    function condition(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (SolverLib.Condition memory);\\r\\n\\r\\n    function getConditions()\\r\\n        external\\r\\n        view\\r\\n        returns (SolverLib.Condition[] memory);\\r\\n\\r\\n    /**\\r\\n        @notice Get Solver config\\r\\n     */\\r\\n    function getConfig() external view returns (SolverLib.Config memory);\\r\\n\\r\\n    /**\\r\\n        @notice Get Keeper address \\r\\n    */\\r\\n    function keeper() external view returns (address);\\r\\n\\r\\n    /**\\r\\n        @notice Get Arbitrator address \\r\\n    */\\r\\n    function arbitrator() external view returns (address);\\r\\n\\r\\n    /**\\r\\n        @notice set ID that will be passed as data for conditional token transfers\\r\\n        @param _trackingId bytes32\\r\\n    */\\r\\n    function setTrackingId(bytes32 _trackingId) external;\\r\\n\\r\\n    function trackingId() external returns (bytes32 trackingId);\\r\\n\\r\\n    /**\\r\\n        @notice Get balance of collateral token on Solver\\r\\n        @return balance\\r\\n    */\\r\\n    function collateralBalance() external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n        @notice Basic getter\\r\\n     */\\r\\n    function timelocks(uint256 conditionIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 timelock);\\r\\n\\r\\n    /**\\r\\n        @notice Returns recipient addresses for a condition\\r\\n        @param account address to check\\r\\n        @param conditionIndex condition to check\\r\\n        @return bool\\r\\n     */\\r\\n    function isRecipient(address account, uint256 conditionIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n        @notice Get status of a condition\\r\\n        @param conditionIndex index of condition\\r\\n        @return status\\r\\n     */\\r\\n    function getStatus(uint256 conditionIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (SolverLib.Status status);\\r\\n\\r\\n    function setTimelock(uint256 _index, uint256 _date) external;\\r\\n\\r\\n    /**\\r\\n        @notice Redeems CTs held by this Solver. See ConditionalTokens contract for more info.\\r\\n        @dev only Keeper\\r\\n     */\\r\\n    function redeemPosition(\\r\\n        IERC20 _collateralToken,\\r\\n        bytes32 _parentCollectionId,\\r\\n        bytes32 _conditionId,\\r\\n        uint256[] calldata _indexSets\\r\\n    ) external;\\r\\n\\r\\n    function hasRole(bytes32 role, address account)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function setState(bytes32 key, bytes calldata data) external;\\r\\n\\r\\n    function getState(bytes32 key) external view returns (bytes memory data);\\r\\n\\r\\n    function ctfAddress() external view returns (address);\\r\\n}\\r\\n\",\"keccak256\":\"0xc06dc71d73cc32ae0541124993715c8b1625c4072e4a5d655b55d57a6a2c7e0a\"},\"contracts/interfaces/ISolverFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"../solvers/SolverLib.sol\\\";\\r\\n\\r\\ninterface ISolverFactory {\\r\\n    function createSolver(\\r\\n        address chainParent,\\r\\n        uint256 chainIndex,\\r\\n        SolverLib.Config calldata solverConfig\\r\\n    ) external returns (address);\\r\\n\\r\\n    function ctf() external view returns (address);\\r\\n\\r\\n    function erc1155Rescue() external view returns (address);\\r\\n}\\r\\n\",\"keccak256\":\"0x33e6d483f1c960d73592e8525a4a508a085e72b8f5e4f1142861f62016604594\",\"license\":\"GPL-3.0\"},\"contracts/modules/Modulated.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\nimport \\\"../interfaces/IModule.sol\\\";\\r\\nimport \\\"../interfaces/ISolver.sol\\\";\\r\\n\\r\\nabstract contract Modulated {\\r\\n    address private _context;\\r\\n\\r\\n    struct Loader {\\r\\n        IModule module;\\r\\n        bytes data;\\r\\n    }\\r\\n\\r\\n    mapping(address => bool) private modules; // module => true/false\\r\\n\\r\\n    mapping(bytes32 => bytes) private state;\\r\\n\\r\\n    function loadModules(Loader[] calldata loaders) internal virtual {\\r\\n        for (uint256 i; i < loaders.length; i++) {\\r\\n            modules[address(loaders[i].module)] = true;\\r\\n            loaders[i].module.load(loaders[i].data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setState(bytes32 key, bytes memory data) external virtual {\\r\\n        require(isPermittedModule(this.setState.selector), \\\"Not permitted\\\");\\r\\n        state[key] = data;\\r\\n    }\\r\\n\\r\\n    function getState(bytes32 key) public view returns (bytes memory data) {\\r\\n        data = state[key];\\r\\n    }\\r\\n\\r\\n    function isPermittedModule(bytes4 selector) public view returns (bool) {\\r\\n        if (modules[msg.sender]) {\\r\\n            bool res = IModule(msg.sender).isPermitted(selector);\\r\\n            return res;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x3c67475b0ee9f05812d69702808f5837a69c4c1e167e8c1e17c5f333b3817160\",\"license\":\"GPL-3.0\"},\"contracts/solvers/Solver.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\nimport \\\"../interfaces/IConditionalTokens.sol\\\";\\r\\nimport \\\"../interfaces/ISolverFactory.sol\\\";\\r\\nimport \\\"../interfaces/ISolver.sol\\\";\\r\\nimport \\\"../interfaces/IModule.sol\\\";\\r\\n\\r\\nimport \\\"./SolverLib.sol\\\";\\r\\n\\r\\nimport \\\"../modules/Modulated.sol\\\";\\r\\n\\r\\nabstract contract Solver is Modulated, Initializable, ERC1155Receiver {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    ISolverFactory public solverFactory; // Factory which creates Solver proxies\\r\\n    address public deployerAddress; // Address which called SolverFactory to deploy this Solver\\r\\n\\r\\n    SolverLib.Config public config; // Primary config of the Solver\\r\\n    SolverLib.Condition[] public conditions; // Array of conditions\\r\\n\\r\\n    address public chainParent; // Parent solver\\r\\n    address public chainChild; // Child solver\\r\\n    uint256 public chainIndex; // This Solver's index in chain\\r\\n\\r\\n    uint256[] public timelocks; // Current timelock, indexed by condition\\r\\n    bytes32 public trackingId; // Settable for adding some higher-level trackingId (eg. id of a proposal this solver belongs to)\\r\\n\\r\\n    SolverLib.Callbacks callbacks;\\r\\n    SolverLib.Datas datas;\\r\\n\\r\\n    event ChangedStatus(bytes32 conditionId);\\r\\n\\r\\n    event DeployedChild(address child);\\r\\n\\r\\n    event DeliveredNullArbitration(bytes32 conditionId);\\r\\n\\r\\n    event IngestedData(); // Emited on executeIngests(), handleCallback(), addData()\\r\\n\\r\\n    event PreparedSolve(address solver, uint256 solveIndex);\\r\\n\\r\\n    // Recommended disabling of initializer for the implementation. Not called by clones\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Called by SolverFactory when contract is created. Nothing else should ever need to call this\\r\\n        @dev initializer\\r\\n        @param _chainParent The address of the Solver above this one in the chain. address(0) if this Solver is first.\\r\\n        @param _chainIndex The index of this Solver in the chain\\r\\n        @param _solverConfig The configuration of this Solver\\r\\n    */\\r\\n    function init(\\r\\n        address _deployer,\\r\\n        address _chainParent,\\r\\n        uint256 _chainIndex,\\r\\n        SolverLib.Config calldata _solverConfig\\r\\n    ) external initializer {\\r\\n        require(_solverConfig.keeper != address(0), \\\"Keeper invalid\\\");\\r\\n        deployerAddress = _deployer;\\r\\n        solverFactory = ISolverFactory(msg.sender);\\r\\n        chainParent = _chainParent;\\r\\n        chainIndex = _chainIndex;\\r\\n        config = _solverConfig;\\r\\n\\r\\n        for (uint256 i = 0; i < _solverConfig.ingests.length; i++) {\\r\\n            datas.slotIngestIdx[_solverConfig.ingests[i].slot] = i;\\r\\n        }\\r\\n\\r\\n        loadModules(_solverConfig.moduleLoaders);\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ********************************** SETUP ***************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @notice Creates a new condition, associated timelock, and executes ingests for this Solver and any child Solvers\\r\\n        @param _index Index of the new condition to be created.\\r\\n    */\\r\\n    function prepareSolve(uint256 _index) external {\\r\\n        if (conditions.length > 0) {\\r\\n            require(\\r\\n                msg.sender == config.keeper ||\\r\\n                    msg.sender == chainParent ||\\r\\n                    isPermittedModule(this.prepareSolve.selector),\\r\\n                \\\"Not permitted\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        require(_index == conditions.length, \\\"Invalid index\\\");\\r\\n        require(callbacks.numOutgoing == 0, \\\"outgoing cbs\\\");\\r\\n        require(callbacks.numIncoming == 0, \\\"incoming cbs\\\");\\r\\n\\r\\n        conditions.push(\\r\\n            SolverLib.createCondition(\\r\\n                solverFactory.ctf(),\\r\\n                config.conditionBase,\\r\\n                chainParent,\\r\\n                conditions.length\\r\\n            )\\r\\n        );\\r\\n        timelocks.push(0);\\r\\n\\r\\n        executeIngests();\\r\\n\\r\\n        emit PreparedSolve(address(this), _index);\\r\\n\\r\\n        if (chainChild != address(0)) {\\r\\n            ISolver(chainChild).prepareSolve(_index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Deploys a new Solver as a child\\r\\n        @param _config Configuration of the child Solver\\r\\n        @return address\\r\\n    */\\r\\n    function deployChild(SolverLib.Config calldata _config)\\r\\n        public\\r\\n        returns (address)\\r\\n    {\\r\\n        require(\\r\\n            msg.sender == config.keeper ||\\r\\n                isPermittedModule(this.deployChild.selector),\\r\\n            \\\"Only keeper\\\"\\r\\n        );\\r\\n        require(chainChild == address(0), \\\"Has child\\\");\\r\\n\\r\\n        chainChild = SolverLib.deployChild(\\r\\n            solverFactory,\\r\\n            _config,\\r\\n            chainIndex,\\r\\n            trackingId\\r\\n        );\\r\\n\\r\\n        return chainChild;\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ****************************** EXECUTION ***************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @notice Mints conditional tokens, allocates them to recipients specified by ingested data and tries to do the same for child Solver\\r\\n        @dev require(ingestsValid())\\r\\n        @param _index Index of condition to execute on\\r\\n     */\\r\\n    function executeSolve(uint256 _index) public {\\r\\n        require(ingestsValid() == true, \\\"ingests invalid\\\");\\r\\n\\r\\n        SolverLib.executeSolve(\\r\\n            _index,\\r\\n            solverFactory.ctf(),\\r\\n            solverFactory.erc1155Rescue(),\\r\\n            conditions[_index],\\r\\n            config.conditionBase,\\r\\n            datas,\\r\\n            trackingId,\\r\\n            chainParent,\\r\\n            abi.decode(\\r\\n                datas.slots[config.conditionBase.amountSlot][_index],\\r\\n                (uint256)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        cascade(_index);\\r\\n    }\\r\\n\\r\\n    function cascade(uint256 _index) internal {\\r\\n        if (\\r\\n            chainChild != address(0) &&\\r\\n            ISolver(chainChild).ingestsValid() &&\\r\\n            ISolver(chainChild).allocationsValid(_index)\\r\\n        ) {\\r\\n            ISolver(chainChild).executeSolve(_index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ********************************** DATA ****************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Adds data to slot (if valid ver.) and executes any callbacks for this slot\\r\\n        @param _slot Destination slot\\r\\n        @param _data Data added to slot\\r\\n     */\\r\\n    function router(bytes32 _slot, bytes memory _data) private {\\r\\n        require(\\r\\n            datas.slots[_slot].length == (conditions.length - 1),\\r\\n            \\\"Slot version invalid\\\"\\r\\n        );\\r\\n        datas.slots[_slot].push(_data);\\r\\n\\r\\n        callback(_slot);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Executes ingests from config. Registers callbacks for ingests which wait for upstream solver data\\r\\n     */\\r\\n    function executeIngests() private {\\r\\n        for (uint256 i; i < config.ingests.length; i++) {\\r\\n            if (config.ingests[i].ingestType != SolverLib.IngestType.Callback) {\\r\\n                ingest(config.ingests[i]);\\r\\n            } else {\\r\\n                address _cbSolver = ISolver(address(this))\\r\\n                    .addressFromChainIndex(config.ingests[i].solverIndex);\\r\\n                registerIncomingCallback(_cbSolver, i);\\r\\n                ISolver(_cbSolver).registerOutgoingCallback(\\r\\n                    abi.decode(config.ingests[i].data, (bytes32)),\\r\\n                    chainIndex\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        emit IngestedData();\\r\\n    }\\r\\n\\r\\n    function ingest(SolverLib.Ingest storage _ingest) private {\\r\\n        require(uint256(_ingest.ingestType) <= 3, \\\"Invalid ingestType\\\");\\r\\n        _ingest.executions++;\\r\\n\\r\\n        if (_ingest.ingestType != SolverLib.IngestType.Manual) {\\r\\n            router(_ingest.slot, SolverLib.ingest(_ingest));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Verifies that all ingests have been performed for a condition\\r\\n        @return bool\\r\\n     */\\r\\n    function ingestsValid() public view returns (bool) {\\r\\n        return SolverLib.ingestsValid(config.ingests, conditions.length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Verifies that all slots corresponding to recipients have been filled before CT allocation\\r\\n        @param _index Condition index\\r\\n        @return bool\\r\\n     */\\r\\n    function allocationsValid(uint256 _index) public view returns (bool) {\\r\\n        return SolverLib.allocationsValid(_index, datas, config.conditionBase);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Allows keeper to manually add data to IngestType.Manual slots after executeIngests\\r\\n        @dev Only Keeper, only manual slots\\r\\n        @param _slot Destination slot\\r\\n        @param _data Data to be added\\r\\n     */\\r\\n    function addData(bytes32 _slot, bytes memory _data) external {\\r\\n        require(\\r\\n            msg.sender == config.keeper ||\\r\\n                isPermittedModule(this.addData.selector),\\r\\n            \\\"Only Keeper\\\"\\r\\n        );\\r\\n        require(\\r\\n            config.ingests[datas.slotIngestIdx[_slot]].ingestType ==\\r\\n                SolverLib.IngestType.Manual,\\r\\n            \\\"only IngestType.Manual\\\"\\r\\n        );\\r\\n\\r\\n        router(_slot, _data);\\r\\n        emit IngestedData();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get most recent data of a slot\\r\\n        @param _slot slotId\\r\\n        @return data\\r\\n     */\\r\\n    function getData(bytes32 _slot) public view returns (bytes memory data) {\\r\\n        data = datas.slots[_slot][datas.slots[_slot].length - 1];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get data for each condition from a slot\\r\\n        @param _slot slotId\\r\\n        @return data\\r\\n     */\\r\\n    function getAllData(bytes32 _slot)\\r\\n        public\\r\\n        view\\r\\n        returns (bytes[] memory data)\\r\\n    {\\r\\n        data = datas.slots[_slot];\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ****************************** CALLBACKS ***************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @dev Register callback that an upstream Solver will call when some data is added\\r\\n        @param _cbSolver Address of the Solver making the callback\\r\\n        @param _ingestIndex Index of the ingest registering this callback\\r\\n     */\\r\\n    function registerIncomingCallback(address _cbSolver, uint256 _ingestIndex)\\r\\n        private\\r\\n    {\\r\\n        callbacks.incoming[\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    _cbSolver,\\r\\n                    abi.decode(config.ingests[_ingestIndex].data, (bytes32))\\r\\n                )\\r\\n            )\\r\\n        ] = _ingestIndex;\\r\\n        callbacks.numIncoming++;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Register callback expected by a downstream Solver for some data\\r\\n        @dev only downstream Solver\\r\\n        @param _slot Slot being waited on by downstream Solver\\r\\n        @param _chainIndex Index of the Solver requesting this callback\\r\\n     */\\r\\n    function registerOutgoingCallback(bytes32 _slot, uint256 _chainIndex)\\r\\n        external\\r\\n    {\\r\\n        require(_chainIndex > chainIndex, \\\"solver not downstream\\\");\\r\\n        require(\\r\\n            msg.sender == addressFromChainIndex(_chainIndex),\\r\\n            \\\"msg.sender not solver\\\"\\r\\n        );\\r\\n\\r\\n        if (\\r\\n            datas.slots[_slot].length > 0 &&\\r\\n            datas.slots[_slot].length == conditions.length\\r\\n        ) {\\r\\n            // Downchain Solver is preparing a new condition before us and is happy with the existing data\\r\\n            ISolver(msg.sender).handleCallback(_slot);\\r\\n        } else {\\r\\n            callbacks.outgoing[_slot].push(msg.sender);\\r\\n            callbacks.numOutgoing++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Handle upstream Solver making callback and ingest the data\\r\\n        @dev only upstream Solver\\r\\n        @param _slot Destination slot for the data being sent\\r\\n     */\\r\\n    function handleCallback(bytes32 _slot) external {\\r\\n        bytes32 _cb = keccak256(abi.encodePacked(msg.sender, _slot));\\r\\n        require(\\r\\n            msg.sender ==\\r\\n                addressFromChainIndex(\\r\\n                    config.ingests[callbacks.incoming[_cb]].solverIndex\\r\\n                ),\\r\\n            \\\"msg.sender not solver\\\"\\r\\n        );\\r\\n        require(\\r\\n            config.ingests[callbacks.incoming[_cb]].ingestType ==\\r\\n                SolverLib.IngestType.Callback,\\r\\n            \\\"not Cb\\\"\\r\\n        );\\r\\n\\r\\n        config.ingests[callbacks.incoming[_cb]].executions++;\\r\\n\\r\\n        router(\\r\\n            config.ingests[callbacks.incoming[_cb]].slot,\\r\\n            ISolver(msg.sender).getCallbackOutput(\\r\\n                abi.decode(\\r\\n                    config.ingests[callbacks.incoming[_cb]].data,\\r\\n                    (bytes32)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        delete callbacks.incoming[_cb];\\r\\n        callbacks.numIncoming--;\\r\\n\\r\\n        emit IngestedData();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @dev Make any callbacks that were waiting on _slot\\r\\n        @param _slot Slot being waited on by downstream Solvers\\r\\n     */\\r\\n    function callback(bytes32 _slot) private {\\r\\n        for (uint256 i; i < callbacks.outgoing[_slot].length; i++) {\\r\\n            if (address(callbacks.outgoing[_slot][i]) != address(0)) {\\r\\n                ISolver(address(callbacks.outgoing[_slot][i])).handleCallback(\\r\\n                    _slot\\r\\n                );\\r\\n                delete callbacks.outgoing[_slot][i];\\r\\n                callbacks.numOutgoing--;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice A simple getter that requires upstream slot ver. == our condition ver.\\r\\n        @param _slot Slot containing data\\r\\n        @return data\\r\\n     */\\r\\n    function getCallbackOutput(bytes32 _slot)\\r\\n        public\\r\\n        view\\r\\n        returns (bytes memory data)\\r\\n    {\\r\\n        require(\\r\\n            datas.slots[_slot].length == conditions.length,\\r\\n            \\\"Slot invalid ver.\\\"\\r\\n        );\\r\\n\\r\\n        data = datas.slots[_slot][datas.slots[_slot].length - 1];\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ****************************** REPORTING ***************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @notice Propose payouts (AKA outcomes) for a condition\\r\\n        @param _index Index of condition\\r\\n        @param _payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\\r\\n     */\\r\\n    function proposePayouts(uint256 _index, uint256[] calldata _payouts)\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            msg.sender == config.keeper ||\\r\\n                isPermittedModule(this.proposePayouts.selector),\\r\\n            \\\"Only Keeper\\\"\\r\\n        );\\r\\n        require(\\r\\n            _payouts.length == config.conditionBase.outcomeSlots,\\r\\n            \\\"length must match outcomeSlots\\\"\\r\\n        );\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.Executed,\\r\\n            \\\"Not Executed\\\"\\r\\n        );\\r\\n\\r\\n        SolverLib.proposePayouts(conditions[_index], _payouts);\\r\\n        updateTimelock(_index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Confirm payouts for condition (reportPayouts to ConditionalTokens contract)\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function confirmPayouts(uint256 _index) external {\\r\\n        require(block.timestamp > timelocks[_index], \\\"Timelocked\\\");\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.OutcomeProposed,\\r\\n            \\\"Not proposed\\\"\\r\\n        );\\r\\n        SolverLib.confirmPayouts(solverFactory.ctf(), conditions[_index]);\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ***************************** ARBITRATION **************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @notice Sets condition.status to ArbitrationRequested.\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function requestArbitration(uint256 _index) external {\\r\\n        require(\\r\\n            msg.sender == config.arbitrator ||\\r\\n                isPermittedModule(this.requestArbitration.selector),\\r\\n            \\\"Only arbitrator\\\"\\r\\n        );\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.OutcomeProposed ||\\r\\n                conditions[_index].status ==\\r\\n                SolverLib.Status.ArbitrationRequested,\\r\\n            \\\"Cannot request\\\"\\r\\n        );\\r\\n\\r\\n        SolverLib.requestArbitration(conditions[_index]);\\r\\n        updateTimelock(_index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Allows arbitrator to unilaterally make a payout report.\\r\\n        @param _index Index of condition\\r\\n        @param payouts Array of uint256 values representing the ratio of the collateral that each outcome can claim. The length of this array must be equal to the outcomeSlotCount\\r\\n     */\\r\\n    function arbitrate(uint256 _index, uint256[] memory payouts) external {\\r\\n        require(\\r\\n            msg.sender == config.arbitrator ||\\r\\n                isPermittedModule(this.arbitrate.selector),\\r\\n            \\\"Only arbitrator\\\"\\r\\n        );\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.ArbitrationRequested,\\r\\n            \\\"Not ArbitrationRequested\\\"\\r\\n        );\\r\\n        require(block.timestamp > timelocks[_index], \\\"Timelocked\\\");\\r\\n        require(\\r\\n            payouts.length == config.conditionBase.outcomeSlots,\\r\\n            \\\"length must match outcomeSlots\\\"\\r\\n        );\\r\\n        SolverLib.arbitrate(solverFactory.ctf(), conditions[_index], payouts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Returns condition.status to OutcomeProposed without a ruling.\\r\\n        @param _index Index of condition\\r\\n     */\\r\\n    function arbitrateNull(uint256 _index) external {\\r\\n        require(\\r\\n            msg.sender == config.arbitrator ||\\r\\n                isPermittedModule(this.arbitrateNull.selector),\\r\\n            \\\"Only arbitrator\\\"\\r\\n        );\\r\\n        require(\\r\\n            conditions[_index].status == SolverLib.Status.ArbitrationRequested,\\r\\n            \\\"Not ArbitrationRequested\\\"\\r\\n        );\\r\\n        SolverLib.arbitrateNull(conditions[_index]);\\r\\n        updateTimelock(_index);\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ******************************** UTILIY ****************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @notice Get address for a Solver by its index in the chain\\r\\n        @dev Returns address(0) if no child or parent\\r\\n        @param _index Index of Solver\\r\\n        @return _address\\r\\n     */\\r\\n    function addressFromChainIndex(uint256 _index)\\r\\n        public\\r\\n        view\\r\\n        returns (address _address)\\r\\n    {\\r\\n        if (_index == chainIndex) {\\r\\n            _address = address(this);\\r\\n        } else if (_index < chainIndex) {\\r\\n            if (chainParent == address(0)) {\\r\\n                _address = address(0);\\r\\n            } else {\\r\\n                _address = ISolver(chainParent).addressFromChainIndex(_index);\\r\\n            }\\r\\n        } else if (_index > chainIndex) {\\r\\n            if (chainChild == address(0)) {\\r\\n                _address = address(0);\\r\\n            } else {\\r\\n                _address = ISolver(chainChild).addressFromChainIndex(_index);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get one condition\\r\\n        @param index Index of condition\\r\\n     */\\r\\n    function condition(uint256 index)\\r\\n        public\\r\\n        view\\r\\n        returns (SolverLib.Condition memory)\\r\\n    {\\r\\n        return conditions[index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get all conditions\\r\\n     */\\r\\n    function getConditions()\\r\\n        public\\r\\n        view\\r\\n        returns (SolverLib.Condition[] memory)\\r\\n    {\\r\\n        return conditions;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get Solver config\\r\\n     */\\r\\n    function getConfig() public view returns (SolverLib.Config memory) {\\r\\n        return config;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get Keeper address \\r\\n    */\\r\\n    function keeper() public view returns (address) {\\r\\n        return config.keeper;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get Arbitrator address \\r\\n    */\\r\\n    function arbitrator() public view returns (address) {\\r\\n        return config.arbitrator;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice set ID that will be passed as data for conditional token transfers\\r\\n        @param _trackingId bytes32\\r\\n    */\\r\\n    function setTrackingId(bytes32 _trackingId) public {\\r\\n        require(trackingId == bytes32(0), \\\"TrackingId set\\\");\\r\\n        require(msg.sender == deployerAddress);\\r\\n        trackingId = _trackingId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Update timelock for a condition\\r\\n        @param _index Timelock/Condition index to be updated\\r\\n    */\\r\\n    function updateTimelock(uint256 _index) internal {\\r\\n        timelocks[_index] =\\r\\n            block.timestamp +\\r\\n            (config.timelockSeconds * 1 seconds);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Set new timelock for a condition\\r\\n        @param _index Timelock/Condition index to be updated\\r\\n    */\\r\\n    function setTimelock(uint256 _index, uint256 _date) external {\\r\\n        require(isPermittedModule(this.setTimelock.selector), \\\"Not permitted\\\");\\r\\n        timelocks[_index] = _date * 1 seconds;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get balance of collateral token on Solver\\r\\n        @return balance\\r\\n    */\\r\\n    function collateralBalance() public view returns (uint256 balance) {\\r\\n        balance = IERC20(config.conditionBase.collateralToken).balanceOf(\\r\\n            address(this)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Returns recipient addresses for a condition\\r\\n        @param account address to check\\r\\n        @param conditionIndex condition to check\\r\\n        @return bool\\r\\n     */\\r\\n    function isRecipient(address account, uint256 conditionIndex)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        for (uint256 i; i < config.conditionBase.allocations.length; i++) {\\r\\n            address recipient = abi.decode(\\r\\n                datas.slots[\\r\\n                    config.conditionBase.allocations[i].recipientAddressSlot\\r\\n                ][conditionIndex],\\r\\n                (address)\\r\\n            );\\r\\n\\r\\n            if (account == recipient) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Get status of a condition\\r\\n        @param conditionIndex index of condition\\r\\n        @return status\\r\\n     */\\r\\n    function getStatus(uint256 conditionIndex)\\r\\n        public\\r\\n        view\\r\\n        returns (SolverLib.Status status)\\r\\n    {\\r\\n        status = conditions[conditionIndex].status;\\r\\n    }\\r\\n\\r\\n    // ********************************************************************************** //\\r\\n    // ******************************** TOKENS ****************************************** //\\r\\n    // ********************************************************************************** //\\r\\n\\r\\n    /**\\r\\n        @notice Redeems CTs held by this Solver. See ConditionalTokens contract for more info.\\r\\n        @dev only Keeper or module\\r\\n     */\\r\\n    function redeemPosition(\\r\\n        IERC20 _collateralToken,\\r\\n        bytes32 _parentCollectionId,\\r\\n        bytes32 _conditionId,\\r\\n        uint256[] calldata _indexSets\\r\\n    ) external {\\r\\n        require(\\r\\n            msg.sender == config.keeper ||\\r\\n                isPermittedModule(this.redeemPosition.selector),\\r\\n            \\\"Only Keeper\\\"\\r\\n        );\\r\\n        IConditionalTokens(solverFactory.ctf()).redeemPositions(\\r\\n            _collateralToken,\\r\\n            _parentCollectionId,\\r\\n            _conditionId,\\r\\n            _indexSets\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function transferERC20(\\r\\n        IERC20 token,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public {\\r\\n        require(isPermittedModule(this.transferERC20.selector), \\\"Only module\\\");\\r\\n        IERC20(token).safeTransfer(recipient, amount);\\r\\n    }\\r\\n\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external virtual override returns (bytes4) {\\r\\n        return this.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external virtual override returns (bytes4) {\\r\\n        return this.onERC1155BatchReceived.selector;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x74f9bc3508d59fa3c7eb12c20b1f13a0d5d60d20818dc26447fea0f2ad3c25a9\",\"license\":\"GPL-3.0\"},\"contracts/solvers/SolverLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./Solver.sol\\\";\\r\\nimport \\\"../interfaces/ISolver.sol\\\";\\r\\nimport \\\"../interfaces/IConditionalTokens.sol\\\";\\r\\nimport \\\"../interfaces/ISolverFactory.sol\\\";\\r\\nimport \\\"../interfaces/IModule.sol\\\";\\r\\nimport \\\"../modules/Modulated.sol\\\";\\r\\nimport \\\"../FullMath.sol\\\";\\r\\n\\r\\nlibrary SolverLib {\\r\\n    // Ingest Types\\r\\n    enum IngestType {\\r\\n        Callback,\\r\\n        Constant,\\r\\n        Function,\\r\\n        Manual\\r\\n    }\\r\\n\\r\\n    // Status state for Conditions\\r\\n    enum Status {\\r\\n        Initiated, // Default state\\r\\n        Executed, // Solver has executed according to configuration\\r\\n        OutcomeProposed, // Outcome has been proposed for reporting\\r\\n        ArbitrationRequested, // Arbitration has been requested for this condition\\r\\n        ArbitrationDelivered, // Arbitration (except 'null' arbitration) has been delivered for this condition\\r\\n        OutcomeReported // Outcome has been reported to the CTF via reportPayouts()\\r\\n    }\\r\\n\\r\\n    // Expected sources of data being ingested into the Solver\\r\\n    struct Ingest {\\r\\n        uint256 executions; // Number of times this Ingest has been executed\\r\\n        IngestType ingestType;\\r\\n        bytes32 slot; // Destination slot for data\\r\\n        uint256 solverIndex; // Index of the Solver in the chain to make function call to or register callback\\r\\n        bytes data; // Raw when isConstant=true, slot index of upstream solver data when callback, else an encoded function call\\r\\n    }\\r\\n\\r\\n    // Condition object created by addCondition() from ConditionBase\\r\\n    struct Condition {\\r\\n        IERC20 collateralToken;\\r\\n        bytes32 questionId; // // keccak256(abi.encodePacked(config.conditionBase.metadata, address(this), conditions.length))\\r\\n        bytes32 parentCollectionId; // ID of the parent collection above this Solver in the CTF\\r\\n        bytes32 conditionId; // ID of this condition in the CTF\\r\\n        uint256[] payouts; // Currently proposed payouts. Final if reported == true\\r\\n        Status status; // Status of this condition\\r\\n    }\\r\\n\\r\\n    // Configuration of this Solver\\r\\n    struct Config {\\r\\n        Solver implementation; // The implementation address for this Solver\\r\\n        address keeper; // Keeper address\\r\\n        address arbitrator; // Arbitrator address\\r\\n        uint256 timelockSeconds; // Number of seconds to increment timelock for during critical activities\\r\\n        Modulated.Loader[] moduleLoaders;\\r\\n        Ingest[] ingests; // Data ingests to be performed to bring data in from other Solver\\r\\n        ConditionBase conditionBase; // Base to create conditions from\\r\\n    }\\r\\n\\r\\n    struct Datas {\\r\\n        mapping(bytes32 => bytes[]) slots;\\r\\n        mapping(bytes32 => uint256) slotIngestIdx;\\r\\n    }\\r\\n\\r\\n    struct Callbacks {\\r\\n        uint256 numIncoming;\\r\\n        uint256 numOutgoing;\\r\\n        mapping(bytes32 => address[]) outgoing; // This Slot => Solver expecting callback\\r\\n        mapping(bytes32 => uint256) incoming; // keccack256(Address, CallerSlot) => Receiving Ingest\\r\\n    }\\r\\n\\r\\n    // Immutable data regarding conditions which may be created\\r\\n    struct ConditionBase {\\r\\n        IERC20 collateralToken;\\r\\n        uint256 outcomeSlots; // Num outcome slots\\r\\n        uint256 parentCollectionIndexSet; // IndexSet to get parentCollectionId from parent Solver\\r\\n        bytes32 amountSlot; // Slot for amount of collateral being used        // TODO maybe make this dynamic also\\r\\n        uint256[] partition; // Partition of positions for payouts\\r\\n        Allocation[] allocations; // Allocations for each partition\\r\\n        string[] outcomeURIs; // Resource containing human-friendly descriptions of the conditions for this Solver\\r\\n    }\\r\\n\\r\\n    struct Allocation {\\r\\n        bytes32 recipientAddressSlot; // Slot containing address of recipient\\r\\n        bytes32[] recipientAmountSlots; // recipientAmountSlots[i] => amount for partition[i]\\r\\n    }\\r\\n\\r\\n    event DeployedChild(address child);\\r\\n    event ChangedStatus(bytes32 conditionId);\\r\\n    event DeliveredNullArbitration(bytes32 conditionId);\\r\\n\\r\\n    function executeSolve(\\r\\n        uint256 index,\\r\\n        address ctfAddress,\\r\\n        address erc1155Rescue,\\r\\n        Condition storage condition,\\r\\n        ConditionBase storage base,\\r\\n        Datas storage datas,\\r\\n        bytes32 trackingId,\\r\\n        address chainParent,\\r\\n        uint256 amount\\r\\n    ) public {\\r\\n        require(\\r\\n            condition.status == SolverLib.Status.Initiated,\\r\\n            \\\"not Initiated\\\"\\r\\n        );\\r\\n        require(\\r\\n            allocationsValid(index, datas, base),\\r\\n            \\\"Recipient slot requires updating\\\"\\r\\n        );\\r\\n\\r\\n        condition.status = SolverLib.Status.Executed;\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n\\r\\n        splitPosition(ctfAddress, chainParent, base, condition, amount);\\r\\n        allocatePartition(\\r\\n            index,\\r\\n            ctfAddress,\\r\\n            erc1155Rescue,\\r\\n            condition,\\r\\n            base,\\r\\n            datas,\\r\\n            trackingId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function createCondition(\\r\\n        address ctfAddress,\\r\\n        ConditionBase calldata base,\\r\\n        address chainParent,\\r\\n        uint256 conditionIdx\\r\\n    ) public returns (Condition memory condition) {\\r\\n        condition.questionId = keccak256(\\r\\n            abi.encode(base.outcomeURIs, address(this), conditionIdx)\\r\\n        );\\r\\n\\r\\n        if (chainParent == address(0)) {\\r\\n            condition.parentCollectionId = bytes32(\\\"\\\"); // top level collection\\r\\n        } else {\\r\\n            Condition[] memory _chainParentConditions = ISolver(chainParent)\\r\\n                .getConditions();\\r\\n\\r\\n            require(\\r\\n                _chainParentConditions.length > 0,\\r\\n                \\\"Parent has no conditions\\\"\\r\\n            );\\r\\n\\r\\n            condition.parentCollectionId = getCollectionId(\\r\\n                ctfAddress,\\r\\n                _chainParentConditions[_chainParentConditions.length - 1],\\r\\n                base.parentCollectionIndexSet\\r\\n            );\\r\\n        }\\r\\n\\r\\n        condition.conditionId = IConditionalTokens(ctfAddress).getConditionId(\\r\\n            address(this), // Solver is Oracle\\r\\n            condition.questionId,\\r\\n            base.outcomeSlots\\r\\n        );\\r\\n\\r\\n        condition.collateralToken = base.collateralToken;\\r\\n\\r\\n        IConditionalTokens(ctfAddress).prepareCondition(\\r\\n            address(this),\\r\\n            condition.questionId,\\r\\n            base.outcomeSlots\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployChild(\\r\\n        ISolverFactory factory,\\r\\n        Config calldata config,\\r\\n        uint256 solverIndex,\\r\\n        bytes32 trackingId\\r\\n    ) public returns (address child) {\\r\\n        child = factory.createSolver(address(this), solverIndex + 1, config);\\r\\n\\r\\n        if (trackingId != bytes32(\\\"\\\")) {\\r\\n            ISolver(child).setTrackingId(trackingId);\\r\\n        }\\r\\n\\r\\n        emit DeployedChild(child);\\r\\n\\r\\n        return child;\\r\\n    }\\r\\n\\r\\n    function getPositionId(\\r\\n        address ctfAddress,\\r\\n        Condition memory condition,\\r\\n        IERC20 collateralToken,\\r\\n        uint256 partition\\r\\n    ) public view returns (uint256 positionId) {\\r\\n        IConditionalTokens ct = IConditionalTokens(ctfAddress);\\r\\n        positionId = ct.getPositionId(\\r\\n            collateralToken,\\r\\n            ct.getCollectionId(\\r\\n                condition.parentCollectionId,\\r\\n                condition.conditionId,\\r\\n                partition\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function splitPosition(\\r\\n        address ctfAddress,\\r\\n        address chainParent,\\r\\n        ConditionBase storage base,\\r\\n        Condition storage condition,\\r\\n        uint256 amount\\r\\n    ) public {\\r\\n        uint256 _balance;\\r\\n\\r\\n        IConditionalTokens ICT = IConditionalTokens(ctfAddress);\\r\\n\\r\\n        if (chainParent == address(0)) {\\r\\n            _balance = IERC20(base.collateralToken).balanceOf(address(this));\\r\\n            base.collateralToken.approve(ctfAddress, bpToNum(amount, _balance));\\r\\n        } else {\\r\\n            _balance = ICT.balanceOf(\\r\\n                address(this),\\r\\n                ICT.getPositionId(\\r\\n                    base.collateralToken,\\r\\n                    condition.parentCollectionId\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n\\r\\n        ICT.splitPosition(\\r\\n            base.collateralToken,\\r\\n            condition.parentCollectionId,\\r\\n            condition.conditionId,\\r\\n            base.partition,\\r\\n            bpToNum(amount, _balance)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function reportPayouts(address ctfAddress, Condition storage condition)\\r\\n        public\\r\\n    {\\r\\n        IConditionalTokens(ctfAddress).reportPayouts(\\r\\n            condition.questionId,\\r\\n            condition.payouts\\r\\n        );\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function reportPayouts(\\r\\n        address ctfAddress,\\r\\n        Condition storage condition,\\r\\n        uint256[] memory payouts\\r\\n    ) public {\\r\\n        IConditionalTokens(ctfAddress).reportPayouts(\\r\\n            condition.questionId,\\r\\n            payouts\\r\\n        );\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function proposePayouts(\\r\\n        Condition storage condition,\\r\\n        uint256[] calldata _payouts\\r\\n    ) public {\\r\\n        condition.status = Status.OutcomeProposed;\\r\\n        condition.payouts = _payouts;\\r\\n\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function confirmPayouts(address ctfAddress, Condition storage condition)\\r\\n        public\\r\\n    {\\r\\n        condition.status = Status.OutcomeReported;\\r\\n        reportPayouts(ctfAddress, condition);\\r\\n    }\\r\\n\\r\\n    function requestArbitration(Condition storage condition) public {\\r\\n        condition.status = Status.ArbitrationRequested;\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function arbitrateNull(Condition storage condition) public {\\r\\n        condition.status = Status.OutcomeProposed;\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n        emit DeliveredNullArbitration(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function arbitrate(\\r\\n        address ctfAddress,\\r\\n        Condition storage condition,\\r\\n        uint256[] memory payouts\\r\\n    ) public {\\r\\n        condition.status = Status.ArbitrationDelivered;\\r\\n        reportPayouts(ctfAddress, condition, payouts);\\r\\n        emit ChangedStatus(condition.conditionId);\\r\\n    }\\r\\n\\r\\n    function allocationsValid(\\r\\n        uint256 conditionVer,\\r\\n        Datas storage datas,\\r\\n        ConditionBase storage conditionBase\\r\\n    ) public view returns (bool valid) {\\r\\n        valid = true;\\r\\n\\r\\n        for (uint256 i = 0; i < conditionBase.allocations.length; i++) {\\r\\n            if (\\r\\n                datas\\r\\n                    .slots[conditionBase.allocations[i].recipientAddressSlot]\\r\\n                    .length != (conditionVer + 1)\\r\\n            ) {\\r\\n                valid = false;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function allocatePartition(\\r\\n        uint256 conditionVer,\\r\\n        address ctfAddress,\\r\\n        address erc1155Rescue,\\r\\n        Condition storage condition,\\r\\n        ConditionBase storage base,\\r\\n        Datas storage data,\\r\\n        bytes32 trackingId\\r\\n    ) public {\\r\\n        uint256[] memory _tokens = new uint256[](base.partition.length);\\r\\n        uint256[] memory _balances = new uint256[](base.partition.length);\\r\\n        address[] memory _addressThis = new address[](base.partition.length);\\r\\n\\r\\n        for (uint256 i; i < base.partition.length; i++) {\\r\\n            _tokens[i] = getPositionId(\\r\\n                ctfAddress,\\r\\n                condition,\\r\\n                base.collateralToken,\\r\\n                base.partition[i]\\r\\n            );\\r\\n            _addressThis[i] = address(this); // For more efficient balanceOfBatch call\\r\\n        }\\r\\n\\r\\n        _balances = IConditionalTokens(ctfAddress).balanceOfBatch(\\r\\n            _addressThis,\\r\\n            _tokens\\r\\n        );\\r\\n\\r\\n        for (uint256 i; i < base.allocations.length; i++) {\\r\\n            uint256[] memory _amounts = new uint256[](base.partition.length);\\r\\n\\r\\n            for (\\r\\n                uint256 j;\\r\\n                j < base.allocations[i].recipientAmountSlots.length;\\r\\n                j++\\r\\n            ) {\\r\\n                uint256 _pctValue = abi.decode(\\r\\n                    data.slots[base.allocations[i].recipientAmountSlots[j]][\\r\\n                        conditionVer\\r\\n                    ],\\r\\n                    (uint256)\\r\\n                );\\r\\n                if (_pctValue == 0) {\\r\\n                    _amounts[j] = 0;\\r\\n                } else {\\r\\n                    _amounts[j] = bpToNum(_pctValue, _balances[j]);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            address recipient = abi.decode(\\r\\n                data.slots[base.allocations[i].recipientAddressSlot][\\r\\n                    conditionVer\\r\\n                ],\\r\\n                (address)\\r\\n            );\\r\\n\\r\\n            try\\r\\n                IConditionalTokens(ctfAddress).safeBatchTransferFrom(\\r\\n                    address(this),\\r\\n                    recipient,\\r\\n                    _tokens,\\r\\n                    _amounts,\\r\\n                    abi.encode(trackingId)\\r\\n                )\\r\\n            {} catch {\\r\\n                IConditionalTokens(ctfAddress).safeBatchTransferFrom(\\r\\n                    address(this),\\r\\n                    erc1155Rescue,\\r\\n                    _tokens,\\r\\n                    _amounts,\\r\\n                    abi.encode(recipient, trackingId)\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function bpToNum(uint256 bp, uint256 num) public pure returns (uint256) {\\r\\n        return FullMath.mulDiv(bp, num, 10000);\\r\\n    }\\r\\n\\r\\n    function ingest(Ingest storage _ingest)\\r\\n        public\\r\\n        view\\r\\n        returns (bytes memory data)\\r\\n    {\\r\\n        require(\\r\\n            _ingest.ingestType != IngestType.Manual,\\r\\n            \\\"Manual ingests should not get here\\\"\\r\\n        );\\r\\n\\r\\n        if (_ingest.ingestType == IngestType.Constant) {\\r\\n            data = _ingest.data;\\r\\n        } else {\\r\\n            address _solver = ISolver(address(this)).addressFromChainIndex(\\r\\n                _ingest.solverIndex\\r\\n            );\\r\\n            (bool success, bytes memory retData) = _solver.staticcall(\\r\\n                _ingest.data\\r\\n            );\\r\\n            require(success, \\\"Ingest staticcall failed\\\");\\r\\n            data = retData;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function ingestsValid(Ingest[] calldata ingests, uint256 conditionVer)\\r\\n        public\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        for (uint256 i; i < ingests.length; i++) {\\r\\n            if (ingests[i].executions != conditionVer) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getCollectionId(\\r\\n        address ctfAddress,\\r\\n        Condition memory condition,\\r\\n        uint256 partition\\r\\n    ) public view returns (bytes32 collectionId) {\\r\\n        collectionId = IConditionalTokens(ctfAddress).getCollectionId(\\r\\n            condition.parentCollectionId,\\r\\n            condition.conditionId,\\r\\n            partition\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x4a25697703c04d798304a985c5c091c74cfa8a84eed8c5fc4bafc34ce83b2593\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b506040516200381238038062003812833981016040819052620000349162000046565b6001600160a01b031660805262000078565b6000602082840312156200005957600080fd5b81516001600160a01b03811681146200007157600080fd5b9392505050565b6080516137776200009b60003960008181610232015261106401526137776000f3fe608060405234801561001057600080fd5b50600436106100f15760003560e01c806301ffc9a7146100f65780631918063f1461011e5780632183bbe41461013357806332ed5b121461015b57806333c15c3414610183578063430694cf146101bc57806343d0c81d146101dc57806353ba3f57146101ef57806354dd99271461021a5780635bd9e2991461022d57806383460ba8146102615780639e317f121461028c578063aaa4f332146102ac578063b70c764c146102cc578063bc197c81146102df578063c12639f71461030b578063d1c9ee021461031e578063d3f79a0514610331578063f23a6e6114610356575b600080fd5b610109610104366004611db8565b610369565b60405190151581526020015b60405180910390f35b61013161012c366004611e0a565b6103a0565b005b610146610141366004611ec6565b610691565b60408051928352602083019190915201610115565b61016e610169366004611f9a565b61073d565b60405161011599989796959493929190612018565b6101ae610191366004611e0a565b600460209081526000928352604080842090915290825290205481565b604051908152602001610115565b6101cf6101ca366004611f9a565b61081e565b604051610115919061207d565b6101316101ea366004612114565b610985565b6101ae6101fd36600461215f565b600360209081526000928352604080842090915290825290205481565b610131610228366004612181565b610ad0565b6102547f000000000000000000000000000000000000000000000000000000000000000081565b60405161011591906121b9565b6101ae61026f366004611e0a565b600260209081526000928352604080842090915290825290205481565b6101ae61029a366004611f9a565b60006020819052908152604090205481565b6102bf6102ba366004611f9a565b610dea565b60405161011591906121cd565b6101316102da36600461215f565b610e8f565b6102f26102ed3660046121e0565b61110f565b6040516001600160e01b03199091168152602001610115565b610131610319366004612181565b6111ee565b61014661032c3660046129c2565b6114bd565b61010961033f366004611f9a565b600090815260016020526040902060030154151590565b6102f2610364366004612a7b565b611763565b60006001600160e01b03198216630271189760e51b148061039a57506301ffc9a760e01b6001600160e01b03198316145b92915050565b6000828152600160205260409020600201546001600160a01b0316331461040c5760405162461bcd60e51b815260206004820152601b60248201527a36b9b39739b2b73232b9103737ba1039b7b63aba34b7b739a43ab160291b60448201526064015b60405180910390fd5b6001600160a01b0381166104545760405162461bcd60e51b815260206004820152600f60248201526e496e76616c6964206164647265737360881b6044820152606401610403565b6000828152600160205260408082206002810154600491820154925162c8a40d60e51b81526001600160a01b038087169592169363191481a0936104a393919201918252602082015260400190565b602060405180830381865afa1580156104c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e49190612af6565b6001600160a01b0316146105355760405162461bcd60e51b8152602060048201526018602482015277496e636f727265637420736f6c766572206164647265737360401b6044820152606401610403565b6000828152600160205260408082205490516370a0823160e01b81526101009091046001600160a01b0316919082906370a08231906105789030906004016121b9565b602060405180830381865afa158015610595573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105b99190612b13565b6000858152600160205260409020600501549091506105e4906001600160a01b0384169085906117f2565b600084815260016020526040908190206006015490516370a0823160e01b81526001600160a01b038416906370a08231906106239030906004016121b9565b602060405180830381865afa158015610640573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106649190612b13565b61066e9083612b42565b1461068b5760405162461bcd60e51b815260040161040390612b59565b50505050565b60008060008a6001600160a01b0316639193e9cc8e8e8c8c8c8c6040518763ffffffff1660e01b81526004016106cc96959493929190613077565b6020604051808303816000875af11580156106eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070f9190612b13565b90506107298c8c8c846107228d8f6130c2565b8a8a6114bd565b909e909d509b505050505050505050505050565b60016020819052600091825260409091208054918101546002820154600383015460048401546005850154600686015460078701805460ff8a16996001600160a01b0361010090910481169998811698971696919061079b906130cf565b80601f01602080910402602001604051908101604052809291908181526020018280546107c7906130cf565b80156108145780601f106107e957610100808354040283529160200191610814565b820191906000526020600020905b8154815290600101906020018083116107f757829003601f168201915b5050505050905089565b604080516101208101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820192909252610100810191909152600082815260016020818152604092839020835161012081018552815460ff8116151582526001600160a01b0361010091829004811694830194909452938201548316948101949094526002810154909116606084015260038101546080840152600481015460a0840152600581015460c0840152600681015460e084015260078101805491928401916108fc906130cf565b80601f0160208091040260200160405190810160405280929190818152602001828054610928906130cf565b80156109755780601f1061094a57610100808354040283529160200191610975565b820191906000526020600020905b81548152906001019060200180831161095857829003601f168201915b5050505050815250509050919050565b6000838152600160205260409020600681015460059091015410156109e85760405162461bcd60e51b8152602060048201526019602482015278141c9bdc1bdcd85b081b9bdd08199d5b1b1e48199d5b991959603a1b6044820152606401610403565b60008381526001602052604090205460ff1615610a175760405162461bcd60e51b815260040161040390613109565b600083815260016020819052604091829020805460ff191690911781556002810154600491820154925163b199186160e01b81526001600160a01b039091169263b199186192610a6e928892918891889101613150565b600060405180830381600087803b158015610a8857600080fd5b505af1158015610a9c573d6000803e3d6000fd5b50506040518592507f3a5a0357f01e19a1531e65bfe13d63c64c9ae8f03d8c26ae74b1e2929a4f39669150600090a2505050565b6000838152600160205260408120600301549003610b005760405162461bcd60e51b81526004016104039061317a565b60008381526001602052604090205460ff1615610b2f5760405162461bcd60e51b815260040161040390613109565b6000838152600160205260409020546001600160a01b038381166101009092041614610b6d5760405162461bcd60e51b8152600401610403906131ab565b60008111610b8d5760405162461bcd60e51b8152600401610403906131fc565b6000838152600260209081526040808320338452909152902054811115610c045760405162461bcd60e51b815260206004820152602560248201527f436f6d6d69747465642066756e6473206973206c6f776572207468616e20616d60448201526437bab73a1760d91b6064820152608401610403565b6040516370a0823160e01b81526000906001600160a01b038416906370a0823190610c339030906004016121b9565b602060405180830381865afa158015610c50573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c749190612b13565b905081600160008681526020019081526020016000206005016000828254610c9c9190612b42565b9091555050600084815260026020908152604080832033845290915281208054849290610cca908490612b42565b90915550610ce490506001600160a01b03841633846117f2565b6040516370a0823160e01b815282906001600160a01b038516906370a0823190610d129030906004016121b9565b602060405180830381865afa158015610d2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d539190612b13565b610d5d9083612b42565b14610daa5760405162461bcd60e51b815260206004820152601e60248201527f4265666f726520616e642061667465722062616c616e63652077726f6e6700006044820152606401610403565b837fe2ab43d60bbb163b7fad7413086cd6c1ee0e0a59a9625e4945a10f1b6a167ff98333604051610ddc92919061322b565b60405180910390a250505050565b6000818152600160205260409020600701805460609190610e0a906130cf565b80601f0160208091040260200160405190810160405280929190818152602001828054610e36906130cf565b8015610e835780601f10610e5857610100808354040283529160200191610e83565b820191906000526020600020905b815481529060010190602001808311610e6657829003601f168201915b50505050509050919050565b6000828152600260209081526040808320338452909152902054610f035760405162461bcd60e51b815260206004820152602560248201527f50726f706f73616c734875623a3a6d73672e73656e64657220686173206e6f20604482015264636c61696d60d81b6064820152608401610403565b60008281526002602090815260408083203384528252808320548584526001909252822060050154610f35919061185a565b6000838152600460209081526040808320338452825280832054878452600383528184208785529092528220549293509091610f7290849061189b565b610f7c9190612b42565b905060008111610fc95760405162461bcd60e51b8152602060048201526018602482015277050726f706f73616c734875623a3a436c61696d20697320360441b6044820152606401610403565b60008481526003602090815260408083208684529091529020548111156110325760405162461bcd60e51b815260206004820181905260248201527f50726f706f73616c734875623a3a436c61696d20697320746f6f206c617267656044820152606401610403565b60008381526004602090815260408083203384529091528120805483929061105b908490613242565b925050819055507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f242432a30338685896040516020016110a891815260200190565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016110d795949392919061325a565b600060405180830381600087803b1580156110f157600080fd5b505af1158015611105573d6000803e3d6000fd5b5050505050505050565b60008061111e83850185611f9a565b60008181526001602052604090206003015490915081146111515760405162461bcd60e51b815260040161040390613294565b60008181526001602052604090205460ff1661117f5760405162461bcd60e51b8152600401610403906132de565b60005b878110156111d7576111c5828a8a848181106111a0576111a061332a565b905060200201358989858181106111b9576111b961332a565b90506020020135611906565b806111cf81613340565b915050611182565b5063bc197c8160e01b9a9950505050505050505050565b600083815260016020526040812060030154900361121e5760405162461bcd60e51b81526004016104039061317a565b60008381526001602052604090205460ff161561124d5760405162461bcd60e51b815260040161040390613109565b6000838152600160205260409020546001600160a01b03838116610100909204161461128b5760405162461bcd60e51b8152600401610403906131ab565b600081116112ab5760405162461bcd60e51b8152600401610403906131fc565b600083815260016020526040902060068101546005909101546112ce9083613242565b11156113185760405162461bcd60e51b815260206004820152601960248201527810d85b89dd08199d5b99081b5bdc99481d1a185b8819dbd85b603a1b6044820152606401610403565b6040516370a0823160e01b81526000906001600160a01b038416906370a08231906113479030906004016121b9565b602060405180830381865afa158015611364573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113889190612b13565b905061139f6001600160a01b038416333085611939565b8181846001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016113cd91906121b9565b602060405180830381865afa1580156113ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061140e9190612b13565b6114189190612b42565b146114355760405162461bcd60e51b815260040161040390612b59565b60008481526001602052604081206005018054849290611456908490613242565b9091555050600084815260026020908152604080832033845290915281208054849290611484908490613242565b92505081905550837f82999597cf961179ae8200cb30fa0dcf5559a734cfd867ccd187c5dd6946c4138333604051610ddc92919061322b565b600080876001600160a01b0316634f730b9f87876040518363ffffffff1660e01b81526004016114ee9291906135c3565b602060405180830381865afa15801561150b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061152f91906136ac565b6115765760405162461bcd60e51b8152602060048201526018602482015277496e636f727265637420536f6c76657220436f6e6669677360401b6044820152606401610403565b600086815260208190526040812080549161159083613340565b9091555050600086815260208181526040918290205491516115b99289928892889291016136ce565b60408051808303601f19018152908290528051602090910120632631481560e21b82526004820188905291506001600160a01b038916906398c52054906024016020604051808303816000875af1158015611618573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061163c9190612b13565b6000828152600160205260409081902060038101849055905163a2440b9d60e01b815260048101849052602481018390526001600160a01b038c8116604483015292945090918a169063a2440b9d90606401600060405180830381600087803b1580156116a857600080fd5b505af11580156116bc573d6000803e3d6000fd5b505082546001600160a01b03808e1661010002610100600160a81b03199092169190911784556001840180546001600160a01b03199081163317909155600285018054928e16929091169190911790555050600481018390556006810188905561172a600782018686611d1f565b5060405182907f2d231481d8c1af3958a30a257e93e0df6b089bc07ebedc0a86e7355d1aaf133890600090a25097509795505050505050565b60008061177283850185611f9a565b60008181526001602052604090206003015490915081146117a55760405162461bcd60e51b815260040161040390613294565b60008181526001602052604090205460ff166117d35760405162461bcd60e51b8152600401610403906132de565b6117de818787611906565b5063f23a6e6160e01b979650505050505050565b6040516001600160a01b03831660248201526044810182905261185590849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611971565b505050565b60008160000361186957600080fd5b60006118758484611a43565b905060016001607f1b036001600160801b038216111561189457600080fd5b9392505050565b6000816000036118ad5750600061039a565b600083600f0b12156118be57600080fd5b600f83900b6001600160801b038316810260401c90608084901c026001600160c01b038111156118ed57600080fd5b60401b81198111156118fe57600080fd5b019392505050565b60008381526003602090815260408083208584529091528120805483929061192f908490613242565b9091555050505050565b6040516001600160a01b038085166024830152831660448201526064810182905261068b9085906323b872dd60e01b9060840161181e565b60006119c6826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611ba79092919063ffffffff16565b80519091501561185557808060200190518101906119e491906136ac565b6118555760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610403565b600081600003611a5257600080fd5b60006001600160c01b038411611a7d5782604085901b81611a7557611a756136f9565b049050611b93565b60c084811c600160201b8110611a95576020918201911c5b620100008110611aa7576010918201911c5b6101008110611ab8576008918201911c5b60108110611ac8576004918201911c5b60048110611ad8576002918201911c5b60028110611ae7576001820191505b60bf820360018603901c6001018260ff0387901b81611b0857611b086136f9565b0492506001600160801b03831115611b1f57600080fd5b608085901c83026001600160801b038616840260c088901c604089901b82811015611b4b576001820391505b608084901b92900382811015611b62576001820391505b829003608084901c8214611b7857611b7861370f565b888181611b8757611b876136f9565b04870196505050505050505b6001600160801b0381111561189457600080fd5b6060611bb68484600085611bbe565b949350505050565b606082471015611c1f5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610403565b843b611c6d5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610403565b600080866001600160a01b03168587604051611c899190613725565b60006040518083038185875af1925050503d8060008114611cc6576040519150601f19603f3d011682016040523d82523d6000602084013e611ccb565b606091505b5091509150611cdb828286611ce6565b979650505050505050565b60608315611cf5575081611894565b825115611d055782518084602001fd5b8160405162461bcd60e51b815260040161040391906121cd565b828054611d2b906130cf565b90600052602060002090601f016020900481019282611d4d5760008555611d93565b82601f10611d665782800160ff19823516178555611d93565b82800160010185558215611d93579182015b82811115611d93578235825591602001919060010190611d78565b50611d9f929150611da3565b5090565b5b80821115611d9f5760008155600101611da4565b600060208284031215611dca57600080fd5b81356001600160e01b03198116811461189457600080fd5b6001600160a01b0381168114611df757600080fd5b50565b8035611e0581611de2565b919050565b60008060408385031215611e1d57600080fd5b823591506020830135611e2f81611de2565b809150509250929050565b60008083601f840112611e4c57600080fd5b5081356001600160401b03811115611e6357600080fd5b6020830191508360208260051b8501011115611e7e57600080fd5b9250929050565b60008083601f840112611e9757600080fd5b5081356001600160401b03811115611eae57600080fd5b602083019150836020828501011115611e7e57600080fd5b60008060008060008060008060008060e08b8d031215611ee557600080fd5b8a35995060208b0135611ef781611de2565b985060408b0135611f0781611de2565b975060608b0135965060808b01356001600160401b0380821115611f2a57600080fd5b611f368e838f01611e3a565b909850965060a08d0135915080821115611f4f57600080fd5b611f5b8e838f01611e85565b909650945060c08d0135915080821115611f7457600080fd5b50611f818d828e01611e85565b915080935050809150509295989b9194979a5092959850565b600060208284031215611fac57600080fd5b5035919050565b6001600160a01b03169052565b60005b83811015611fdb578181015183820152602001611fc3565b8381111561068b5750506000910152565b60008151808452612004816020860160208601611fc0565b601f01601f19169290920160200192915050565b60006101208b1515835260018060a01b03808c166020850152808b166040850152808a166060850152508760808401528660a08401528560c08401528460e08401528061010084015261206d81840185611fec565b9c9b505050505050505050505050565b6020815261209060208201835115159052565b600060208301516120a46040840182611fb3565b5060408301516120b76060840182611fb3565b5060608301516120ca6080840182611fb3565b50608083015160a083015260a083015160c083015260c083015160e083015260e0830151610100818185015280850151915050610120808185015250611bb6610140840182611fec565b60008060006040848603121561212957600080fd5b8335925060208401356001600160401b0381111561214657600080fd5b61215286828701611e3a565b9497909650939450505050565b6000806040838503121561217257600080fd5b50508035926020909101359150565b60008060006060848603121561219657600080fd5b8335925060208401356121a881611de2565b929592945050506040919091013590565b6001600160a01b0391909116815260200190565b6020815260006118946020830184611fec565b60008060008060008060008060a0898b0312156121fc57600080fd5b883561220781611de2565b9750602089013561221781611de2565b965060408901356001600160401b038082111561223357600080fd5b61223f8c838d01611e3a565b909850965060608b013591508082111561225857600080fd5b6122648c838d01611e3a565b909650945060808b013591508082111561227d57600080fd5b5061228a8b828c01611e85565b999c989b5096995094979396929594505050565b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b03811182821017156122d6576122d661229e565b60405290565b60405160a081016001600160401b03811182821017156122d6576122d661229e565b60405160e081016001600160401b03811182821017156122d6576122d661229e565b604051601f8201601f191681016001600160401b03811182821017156123485761234861229e565b604052919050565b60006001600160401b038211156123695761236961229e565b5060051b60200190565b60006001600160401b0383111561238c5761238c61229e565b61239f601f8401601f1916602001612320565b90508281528383830111156123b357600080fd5b828260208301376000602084830101529392505050565b600082601f8301126123db57600080fd5b61189483833560208501612373565b600082601f8301126123fb57600080fd5b8135602061241061240b83612350565b612320565b82815260059290921b8401810191818101908684111561242f57600080fd5b8286015b848110156124b95780356001600160401b03808211156124535760008081fd5b908801906040828b03601f190181131561246d5760008081fd5b6124756122b4565b8784013561248281611de2565b81529083013590828211156124975760008081fd5b6124a58c89848701016123ca565b818901528652505050918301918301612433565b509695505050505050565b803560048110611e0557600080fd5b600082601f8301126124e457600080fd5b813560206124f461240b83612350565b82815260059290921b8401810191818101908684111561251357600080fd5b8286015b848110156124b95780356001600160401b03808211156125375760008081fd5b9088019060a0828b03601f19018113156125515760008081fd5b6125596122dc565b878401358152604061256c8186016124c4565b8983015260608086013582840152608091508186013581840152508285013592508383111561259b5760008081fd5b6125a98d8a858801016123ca565b908201528652505050918301918301612517565b600082601f8301126125ce57600080fd5b813560206125de61240b83612350565b82815260059290921b840181019181810190868411156125fd57600080fd5b8286015b848110156124b95780358352918301918301612601565b600082601f83011261262957600080fd5b8135602061263961240b83612350565b828152600592831b850182019282820191908785111561265857600080fd5b8387015b858110156127305780356001600160401b038082111561267c5760008081fd5b908901906040828c03601f19018113156126965760008081fd5b61269e6122b4565b88840135815281840135838111156126b65760008081fd5b8085019450508c603f8501126126ce57600092508283fd5b8884013592506126e061240b84612350565b83815292861b8401820192898101908e8511156126fd5760008081fd5b948301945b8486101561271b5785358252948a0194908a0190612702565b828b015250875250505092840192840161265c565b5090979650505050505050565b600082601f83011261274e57600080fd5b8135602061275e61240b83612350565b82815260059290921b8401810191818101908684111561277d57600080fd5b8286015b848110156124b95780356001600160401b038111156127a05760008081fd5b8701603f810189136127b25760008081fd5b6127c3898683013560408401612373565b845250918301918301612781565b600060e082840312156127e357600080fd5b6127eb6122fe565b90506127f682611dfa565b815260208281013590820152604080830135908201526060808301359082015260808201356001600160401b038082111561283057600080fd5b61283c858386016125bd565b608084015260a084013591508082111561285557600080fd5b61286185838601612618565b60a084015260c084013591508082111561287a57600080fd5b506128878482850161273d565b60c08301525092915050565b60006128a161240b84612350565b8381529050602080820190600585901b8401868111156128c057600080fd5b845b818110156129b75780356001600160401b03808211156128e25760008081fd5b9087019060e0828b0312156128f75760008081fd5b6128ff6122fe565b61290883611dfa565b8152612915868401611dfa565b868201526040612926818501611dfa565b9082015260608381013590820152608080840135838111156129485760008081fd5b6129548d8287016123ea565b82840152505060a0808401358381111561296e5760008081fd5b61297a8d8287016124d3565b82840152505060c080840135838111156129945760008081fd5b6129a08d8287016127d1565b9183019190915250865250509282019282016128c2565b505050509392505050565b600080600080600080600060c0888a0312156129dd57600080fd5b87356129e881611de2565b965060208801356129f881611de2565b9550604088013594506060880135935060808801356001600160401b0380821115612a2257600080fd5b818a0191508a601f830112612a3657600080fd5b612a458b833560208501612893565b945060a08a0135915080821115612a5b57600080fd5b50612a688a828b01611e85565b989b979a50959850939692959293505050565b60008060008060008060a08789031215612a9457600080fd5b8635612a9f81611de2565b95506020870135612aaf81611de2565b9450604087013593506060870135925060808701356001600160401b03811115612ad857600080fd5b612ae489828a01611e85565b979a9699509497509295939492505050565b600060208284031215612b0857600080fd5b815161189481611de2565b600060208284031215612b2557600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b600082821015612b5457612b54612b2c565b500390565b6020808252818101527f496e636f72726563742062616c616e6365206166746572207472616e73666572604082015260600190565b6000808335601e19843603018112612ba557600080fd5b83016020810192503590506001600160401b03811115612bc457600080fd5b8060051b3603821315611e7e57600080fd5b6000808335601e19843603018112612bed57600080fd5b83016020810192503590506001600160401b03811115612c0c57600080fd5b803603821315611e7e57600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60008235603e19833603018112612c5a57600080fd5b90910192915050565b60008383855260208086019550808560051b8301018460005b8781101561273057848303601f19018952612c978288612c44565b60408135612ca481611de2565b6001600160a01b03168552612cbb82870183612bd6565b92508187870152612ccf8287018483612c1b565b9b87019b955050509184019150600101612c7c565b60048110612d0257634e487b7160e01b600052602160045260246000fd5b9052565b81835260006020808501808196508560051b81019150846000805b88811015612dad578385038a528235609e19893603018112612d41578283fd5b88018035865260a0612d548883016124c4565b612d6089890182612ce4565b5060408281013590880152606080830135908801526080612d8381840184612bd6565b935082828a0152612d97838a018583612c1b565b9d8a019d98505050938701935050600101612d21565b509298975050505050505050565b6000823560de19833603018112612c5a57600080fd5b81835260006001600160fb1b03831115612dea57600080fd5b8260051b8083602087013760009401602001938452509192915050565b60008383855260208086019550808560051b8301018460005b8781101561273057848303601f19018952612e3b8288612bd6565b612e46858284612c1b565b9a86019a9450505090830190600101612e20565b60008135612e6781611de2565b6001600160a01b03168352602082810135818501526040808401358186015260608085013590860152612e9d6080850185612b8e565b60e06080880152612eb260e088018284612dd1565b915050612ec260a0860186612b8e565b87830360a0890152808352848301600582901b840186018360005b84811015612f3057868303601f19018452612ef88287612c44565b80358452612f088a820182612b8e565b9150898b860152612f1c8a86018383612dd1565b958b01959450505090880190600101612edd565b5050612f3f60c08a018a612b8e565b9750955089810360c08b0152612f56818888612e07565b9a9950505050505050505050565b81835260006020808501808196508560051b810191508460005b8781101561306a578284038952612f958288612dbb565b60e08135612fa281611de2565b6001600160a01b03168652612fb8828801611dfa565b612fc488880182611fb3565b506040612fd2818401611dfa565b612fde82890182611fb3565b5050606082810135908701526080612ff881840184612b8e565b83838a015261300a848a018284612c63565b935050505060a061301d81840184612b8e565b888403838a015261302f848284612d06565b935050505060c061304281840184612dbb565b925086820381880152506130568183612e5a565b9a87019a9550505090840190600101612f7e565b5091979650505050505050565b8681526001600160a01b03861660208201526080604082018190526000906130a29083018688612f64565b82810360608401526130b5818587612c1b565b9998505050505050505050565b6000611894368484612893565b600181811c908216806130e357607f821691505b60208210810361310357634e487b7160e01b600052602260045260246000fd5b50919050565b60208082526027908201527f50726f706f73616c734875623a3a50726f706f73616c20616c726561647920656040820152661e1958dd5d195960ca1b606082015260800190565b848152836020820152606060408201526000613170606083018486612f64565b9695505050505050565b602080825260179082015276141c9bdc1bdcd85b08191bd95cc81b9bdd08195e1a5cdd604a1b604082015260600190565b60208082526031908201527f50726f706f73616c20646f6573206e6f7420696e636c756465207468697320746040820152701bdad95b881d1bc8189948199d5b991959607a1b606082015260800190565b602080825260159082015274416d6f756e742063616e6e6f74206265207a65726f60581b604082015260600190565b9182526001600160a01b0316602082015260400190565b6000821982111561325557613255612b2c565b500190565b6001600160a01b03868116825285166020820152604081018490526060810183905260a060808201819052600090611cdb90830184611fec565b6020808252602a908201527f50726f706f73616c734875623a3a44617461206973206e6f742076616c6964206040820152691c1c9bdc1bdcd85b125960b21b606082015260800190565b6020808252602c908201527f50726f706f73616c734875623a3a50726f706f73616c20686173206e6f74206260408201526b19595b88195e1958dd5d195960a21b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b60006001820161335257613352612b2c565b5060010190565b600081518084526020808501808196508360051b8101915082860160005b8581101561306a578284038952815180516001600160a01b0316855285015160408686018190526133aa81870183611fec565b9a87019a9550505090840190600101613377565b600081518084526020808501808196508360051b8101915082860160005b8581101561306a578284038952815160a0815186528682015161340188880182612ce4565b50604082810151908701526060808301519087015260809182015191860181905261342e81870183611fec565b9a87019a95505050908401906001016133dc565b600081518084526020808501808196508360051b810191508286016000805b86811015612dad578385038a528251805186528601516040878701819052815190870181905290870190606087019084905b808210156134b35783518352928901929189019160019190910190613493565b50509a87019a95505091850191600101613461565b600082825180855260208086019550808260051b84010181860160005b8481101561273057601f19868403018952613501838351611fec565b988401989250908301906001016134e5565b80516001600160a01b0316825260208082015181840152604080830151908401526060808301519084015260808083015160e091850182905280519185018290526000929081019183906101008701905b808310156135845784518252938301936001929092019190830190613564565b5060a0860151935086810360a088015261359e8185613442565b935050505060c083015184820360c08601526135ba82826134c8565b95945050505050565b6000604080830185845260208281860152818651808452606093508387019150838160051b88010183890160005b8381101561369c57898303605f19018552815180516001600160a01b0390811685528782015116878501528881015160e09061362f8b870182611fb3565b508882015189860152608080830151828288015261364f83880182613359565b9250505060a0808301518683038288015261366a83826133be565b9250505060c080830151925085820381870152506136888183613513565b9688019694505050908501906001016135f1565b50909a9950505050505050505050565b6000602082840312156136be57600080fd5b8151801515811461189457600080fd5b8481526060602082015260006136e8606083018587612c1b565b905082604083015295945050505050565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052600160045260246000fd5b60008251613737818460208701611fc0565b919091019291505056fea2646970667358221220b7cb93258e5758ffb200d36a221557b6b701d62f8c75788a0695079004c212cc64736f6c634300080e0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100f15760003560e01c806301ffc9a7146100f65780631918063f1461011e5780632183bbe41461013357806332ed5b121461015b57806333c15c3414610183578063430694cf146101bc57806343d0c81d146101dc57806353ba3f57146101ef57806354dd99271461021a5780635bd9e2991461022d57806383460ba8146102615780639e317f121461028c578063aaa4f332146102ac578063b70c764c146102cc578063bc197c81146102df578063c12639f71461030b578063d1c9ee021461031e578063d3f79a0514610331578063f23a6e6114610356575b600080fd5b610109610104366004611db8565b610369565b60405190151581526020015b60405180910390f35b61013161012c366004611e0a565b6103a0565b005b610146610141366004611ec6565b610691565b60408051928352602083019190915201610115565b61016e610169366004611f9a565b61073d565b60405161011599989796959493929190612018565b6101ae610191366004611e0a565b600460209081526000928352604080842090915290825290205481565b604051908152602001610115565b6101cf6101ca366004611f9a565b61081e565b604051610115919061207d565b6101316101ea366004612114565b610985565b6101ae6101fd36600461215f565b600360209081526000928352604080842090915290825290205481565b610131610228366004612181565b610ad0565b6102547f000000000000000000000000000000000000000000000000000000000000000081565b60405161011591906121b9565b6101ae61026f366004611e0a565b600260209081526000928352604080842090915290825290205481565b6101ae61029a366004611f9a565b60006020819052908152604090205481565b6102bf6102ba366004611f9a565b610dea565b60405161011591906121cd565b6101316102da36600461215f565b610e8f565b6102f26102ed3660046121e0565b61110f565b6040516001600160e01b03199091168152602001610115565b610131610319366004612181565b6111ee565b61014661032c3660046129c2565b6114bd565b61010961033f366004611f9a565b600090815260016020526040902060030154151590565b6102f2610364366004612a7b565b611763565b60006001600160e01b03198216630271189760e51b148061039a57506301ffc9a760e01b6001600160e01b03198316145b92915050565b6000828152600160205260409020600201546001600160a01b0316331461040c5760405162461bcd60e51b815260206004820152601b60248201527a36b9b39739b2b73232b9103737ba1039b7b63aba34b7b739a43ab160291b60448201526064015b60405180910390fd5b6001600160a01b0381166104545760405162461bcd60e51b815260206004820152600f60248201526e496e76616c6964206164647265737360881b6044820152606401610403565b6000828152600160205260408082206002810154600491820154925162c8a40d60e51b81526001600160a01b038087169592169363191481a0936104a393919201918252602082015260400190565b602060405180830381865afa1580156104c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e49190612af6565b6001600160a01b0316146105355760405162461bcd60e51b8152602060048201526018602482015277496e636f727265637420736f6c766572206164647265737360401b6044820152606401610403565b6000828152600160205260408082205490516370a0823160e01b81526101009091046001600160a01b0316919082906370a08231906105789030906004016121b9565b602060405180830381865afa158015610595573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105b99190612b13565b6000858152600160205260409020600501549091506105e4906001600160a01b0384169085906117f2565b600084815260016020526040908190206006015490516370a0823160e01b81526001600160a01b038416906370a08231906106239030906004016121b9565b602060405180830381865afa158015610640573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106649190612b13565b61066e9083612b42565b1461068b5760405162461bcd60e51b815260040161040390612b59565b50505050565b60008060008a6001600160a01b0316639193e9cc8e8e8c8c8c8c6040518763ffffffff1660e01b81526004016106cc96959493929190613077565b6020604051808303816000875af11580156106eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070f9190612b13565b90506107298c8c8c846107228d8f6130c2565b8a8a6114bd565b909e909d509b505050505050505050505050565b60016020819052600091825260409091208054918101546002820154600383015460048401546005850154600686015460078701805460ff8a16996001600160a01b0361010090910481169998811698971696919061079b906130cf565b80601f01602080910402602001604051908101604052809291908181526020018280546107c7906130cf565b80156108145780601f106107e957610100808354040283529160200191610814565b820191906000526020600020905b8154815290600101906020018083116107f757829003601f168201915b5050505050905089565b604080516101208101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820192909252610100810191909152600082815260016020818152604092839020835161012081018552815460ff8116151582526001600160a01b0361010091829004811694830194909452938201548316948101949094526002810154909116606084015260038101546080840152600481015460a0840152600581015460c0840152600681015460e084015260078101805491928401916108fc906130cf565b80601f0160208091040260200160405190810160405280929190818152602001828054610928906130cf565b80156109755780601f1061094a57610100808354040283529160200191610975565b820191906000526020600020905b81548152906001019060200180831161095857829003601f168201915b5050505050815250509050919050565b6000838152600160205260409020600681015460059091015410156109e85760405162461bcd60e51b8152602060048201526019602482015278141c9bdc1bdcd85b081b9bdd08199d5b1b1e48199d5b991959603a1b6044820152606401610403565b60008381526001602052604090205460ff1615610a175760405162461bcd60e51b815260040161040390613109565b600083815260016020819052604091829020805460ff191690911781556002810154600491820154925163b199186160e01b81526001600160a01b039091169263b199186192610a6e928892918891889101613150565b600060405180830381600087803b158015610a8857600080fd5b505af1158015610a9c573d6000803e3d6000fd5b50506040518592507f3a5a0357f01e19a1531e65bfe13d63c64c9ae8f03d8c26ae74b1e2929a4f39669150600090a2505050565b6000838152600160205260408120600301549003610b005760405162461bcd60e51b81526004016104039061317a565b60008381526001602052604090205460ff1615610b2f5760405162461bcd60e51b815260040161040390613109565b6000838152600160205260409020546001600160a01b038381166101009092041614610b6d5760405162461bcd60e51b8152600401610403906131ab565b60008111610b8d5760405162461bcd60e51b8152600401610403906131fc565b6000838152600260209081526040808320338452909152902054811115610c045760405162461bcd60e51b815260206004820152602560248201527f436f6d6d69747465642066756e6473206973206c6f776572207468616e20616d60448201526437bab73a1760d91b6064820152608401610403565b6040516370a0823160e01b81526000906001600160a01b038416906370a0823190610c339030906004016121b9565b602060405180830381865afa158015610c50573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c749190612b13565b905081600160008681526020019081526020016000206005016000828254610c9c9190612b42565b9091555050600084815260026020908152604080832033845290915281208054849290610cca908490612b42565b90915550610ce490506001600160a01b03841633846117f2565b6040516370a0823160e01b815282906001600160a01b038516906370a0823190610d129030906004016121b9565b602060405180830381865afa158015610d2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d539190612b13565b610d5d9083612b42565b14610daa5760405162461bcd60e51b815260206004820152601e60248201527f4265666f726520616e642061667465722062616c616e63652077726f6e6700006044820152606401610403565b837fe2ab43d60bbb163b7fad7413086cd6c1ee0e0a59a9625e4945a10f1b6a167ff98333604051610ddc92919061322b565b60405180910390a250505050565b6000818152600160205260409020600701805460609190610e0a906130cf565b80601f0160208091040260200160405190810160405280929190818152602001828054610e36906130cf565b8015610e835780601f10610e5857610100808354040283529160200191610e83565b820191906000526020600020905b815481529060010190602001808311610e6657829003601f168201915b50505050509050919050565b6000828152600260209081526040808320338452909152902054610f035760405162461bcd60e51b815260206004820152602560248201527f50726f706f73616c734875623a3a6d73672e73656e64657220686173206e6f20604482015264636c61696d60d81b6064820152608401610403565b60008281526002602090815260408083203384528252808320548584526001909252822060050154610f35919061185a565b6000838152600460209081526040808320338452825280832054878452600383528184208785529092528220549293509091610f7290849061189b565b610f7c9190612b42565b905060008111610fc95760405162461bcd60e51b8152602060048201526018602482015277050726f706f73616c734875623a3a436c61696d20697320360441b6044820152606401610403565b60008481526003602090815260408083208684529091529020548111156110325760405162461bcd60e51b815260206004820181905260248201527f50726f706f73616c734875623a3a436c61696d20697320746f6f206c617267656044820152606401610403565b60008381526004602090815260408083203384529091528120805483929061105b908490613242565b925050819055507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f242432a30338685896040516020016110a891815260200190565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016110d795949392919061325a565b600060405180830381600087803b1580156110f157600080fd5b505af1158015611105573d6000803e3d6000fd5b5050505050505050565b60008061111e83850185611f9a565b60008181526001602052604090206003015490915081146111515760405162461bcd60e51b815260040161040390613294565b60008181526001602052604090205460ff1661117f5760405162461bcd60e51b8152600401610403906132de565b60005b878110156111d7576111c5828a8a848181106111a0576111a061332a565b905060200201358989858181106111b9576111b961332a565b90506020020135611906565b806111cf81613340565b915050611182565b5063bc197c8160e01b9a9950505050505050505050565b600083815260016020526040812060030154900361121e5760405162461bcd60e51b81526004016104039061317a565b60008381526001602052604090205460ff161561124d5760405162461bcd60e51b815260040161040390613109565b6000838152600160205260409020546001600160a01b03838116610100909204161461128b5760405162461bcd60e51b8152600401610403906131ab565b600081116112ab5760405162461bcd60e51b8152600401610403906131fc565b600083815260016020526040902060068101546005909101546112ce9083613242565b11156113185760405162461bcd60e51b815260206004820152601960248201527810d85b89dd08199d5b99081b5bdc99481d1a185b8819dbd85b603a1b6044820152606401610403565b6040516370a0823160e01b81526000906001600160a01b038416906370a08231906113479030906004016121b9565b602060405180830381865afa158015611364573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113889190612b13565b905061139f6001600160a01b038416333085611939565b8181846001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016113cd91906121b9565b602060405180830381865afa1580156113ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061140e9190612b13565b6114189190612b42565b146114355760405162461bcd60e51b815260040161040390612b59565b60008481526001602052604081206005018054849290611456908490613242565b9091555050600084815260026020908152604080832033845290915281208054849290611484908490613242565b92505081905550837f82999597cf961179ae8200cb30fa0dcf5559a734cfd867ccd187c5dd6946c4138333604051610ddc92919061322b565b600080876001600160a01b0316634f730b9f87876040518363ffffffff1660e01b81526004016114ee9291906135c3565b602060405180830381865afa15801561150b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061152f91906136ac565b6115765760405162461bcd60e51b8152602060048201526018602482015277496e636f727265637420536f6c76657220436f6e6669677360401b6044820152606401610403565b600086815260208190526040812080549161159083613340565b9091555050600086815260208181526040918290205491516115b99289928892889291016136ce565b60408051808303601f19018152908290528051602090910120632631481560e21b82526004820188905291506001600160a01b038916906398c52054906024016020604051808303816000875af1158015611618573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061163c9190612b13565b6000828152600160205260409081902060038101849055905163a2440b9d60e01b815260048101849052602481018390526001600160a01b038c8116604483015292945090918a169063a2440b9d90606401600060405180830381600087803b1580156116a857600080fd5b505af11580156116bc573d6000803e3d6000fd5b505082546001600160a01b03808e1661010002610100600160a81b03199092169190911784556001840180546001600160a01b03199081163317909155600285018054928e16929091169190911790555050600481018390556006810188905561172a600782018686611d1f565b5060405182907f2d231481d8c1af3958a30a257e93e0df6b089bc07ebedc0a86e7355d1aaf133890600090a25097509795505050505050565b60008061177283850185611f9a565b60008181526001602052604090206003015490915081146117a55760405162461bcd60e51b815260040161040390613294565b60008181526001602052604090205460ff166117d35760405162461bcd60e51b8152600401610403906132de565b6117de818787611906565b5063f23a6e6160e01b979650505050505050565b6040516001600160a01b03831660248201526044810182905261185590849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611971565b505050565b60008160000361186957600080fd5b60006118758484611a43565b905060016001607f1b036001600160801b038216111561189457600080fd5b9392505050565b6000816000036118ad5750600061039a565b600083600f0b12156118be57600080fd5b600f83900b6001600160801b038316810260401c90608084901c026001600160c01b038111156118ed57600080fd5b60401b81198111156118fe57600080fd5b019392505050565b60008381526003602090815260408083208584529091528120805483929061192f908490613242565b9091555050505050565b6040516001600160a01b038085166024830152831660448201526064810182905261068b9085906323b872dd60e01b9060840161181e565b60006119c6826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611ba79092919063ffffffff16565b80519091501561185557808060200190518101906119e491906136ac565b6118555760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610403565b600081600003611a5257600080fd5b60006001600160c01b038411611a7d5782604085901b81611a7557611a756136f9565b049050611b93565b60c084811c600160201b8110611a95576020918201911c5b620100008110611aa7576010918201911c5b6101008110611ab8576008918201911c5b60108110611ac8576004918201911c5b60048110611ad8576002918201911c5b60028110611ae7576001820191505b60bf820360018603901c6001018260ff0387901b81611b0857611b086136f9565b0492506001600160801b03831115611b1f57600080fd5b608085901c83026001600160801b038616840260c088901c604089901b82811015611b4b576001820391505b608084901b92900382811015611b62576001820391505b829003608084901c8214611b7857611b7861370f565b888181611b8757611b876136f9565b04870196505050505050505b6001600160801b0381111561189457600080fd5b6060611bb68484600085611bbe565b949350505050565b606082471015611c1f5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610403565b843b611c6d5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610403565b600080866001600160a01b03168587604051611c899190613725565b60006040518083038185875af1925050503d8060008114611cc6576040519150601f19603f3d011682016040523d82523d6000602084013e611ccb565b606091505b5091509150611cdb828286611ce6565b979650505050505050565b60608315611cf5575081611894565b825115611d055782518084602001fd5b8160405162461bcd60e51b815260040161040391906121cd565b828054611d2b906130cf565b90600052602060002090601f016020900481019282611d4d5760008555611d93565b82601f10611d665782800160ff19823516178555611d93565b82800160010185558215611d93579182015b82811115611d93578235825591602001919060010190611d78565b50611d9f929150611da3565b5090565b5b80821115611d9f5760008155600101611da4565b600060208284031215611dca57600080fd5b81356001600160e01b03198116811461189457600080fd5b6001600160a01b0381168114611df757600080fd5b50565b8035611e0581611de2565b919050565b60008060408385031215611e1d57600080fd5b823591506020830135611e2f81611de2565b809150509250929050565b60008083601f840112611e4c57600080fd5b5081356001600160401b03811115611e6357600080fd5b6020830191508360208260051b8501011115611e7e57600080fd5b9250929050565b60008083601f840112611e9757600080fd5b5081356001600160401b03811115611eae57600080fd5b602083019150836020828501011115611e7e57600080fd5b60008060008060008060008060008060e08b8d031215611ee557600080fd5b8a35995060208b0135611ef781611de2565b985060408b0135611f0781611de2565b975060608b0135965060808b01356001600160401b0380821115611f2a57600080fd5b611f368e838f01611e3a565b909850965060a08d0135915080821115611f4f57600080fd5b611f5b8e838f01611e85565b909650945060c08d0135915080821115611f7457600080fd5b50611f818d828e01611e85565b915080935050809150509295989b9194979a5092959850565b600060208284031215611fac57600080fd5b5035919050565b6001600160a01b03169052565b60005b83811015611fdb578181015183820152602001611fc3565b8381111561068b5750506000910152565b60008151808452612004816020860160208601611fc0565b601f01601f19169290920160200192915050565b60006101208b1515835260018060a01b03808c166020850152808b166040850152808a166060850152508760808401528660a08401528560c08401528460e08401528061010084015261206d81840185611fec565b9c9b505050505050505050505050565b6020815261209060208201835115159052565b600060208301516120a46040840182611fb3565b5060408301516120b76060840182611fb3565b5060608301516120ca6080840182611fb3565b50608083015160a083015260a083015160c083015260c083015160e083015260e0830151610100818185015280850151915050610120808185015250611bb6610140840182611fec565b60008060006040848603121561212957600080fd5b8335925060208401356001600160401b0381111561214657600080fd5b61215286828701611e3a565b9497909650939450505050565b6000806040838503121561217257600080fd5b50508035926020909101359150565b60008060006060848603121561219657600080fd5b8335925060208401356121a881611de2565b929592945050506040919091013590565b6001600160a01b0391909116815260200190565b6020815260006118946020830184611fec565b60008060008060008060008060a0898b0312156121fc57600080fd5b883561220781611de2565b9750602089013561221781611de2565b965060408901356001600160401b038082111561223357600080fd5b61223f8c838d01611e3a565b909850965060608b013591508082111561225857600080fd5b6122648c838d01611e3a565b909650945060808b013591508082111561227d57600080fd5b5061228a8b828c01611e85565b999c989b5096995094979396929594505050565b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b03811182821017156122d6576122d661229e565b60405290565b60405160a081016001600160401b03811182821017156122d6576122d661229e565b60405160e081016001600160401b03811182821017156122d6576122d661229e565b604051601f8201601f191681016001600160401b03811182821017156123485761234861229e565b604052919050565b60006001600160401b038211156123695761236961229e565b5060051b60200190565b60006001600160401b0383111561238c5761238c61229e565b61239f601f8401601f1916602001612320565b90508281528383830111156123b357600080fd5b828260208301376000602084830101529392505050565b600082601f8301126123db57600080fd5b61189483833560208501612373565b600082601f8301126123fb57600080fd5b8135602061241061240b83612350565b612320565b82815260059290921b8401810191818101908684111561242f57600080fd5b8286015b848110156124b95780356001600160401b03808211156124535760008081fd5b908801906040828b03601f190181131561246d5760008081fd5b6124756122b4565b8784013561248281611de2565b81529083013590828211156124975760008081fd5b6124a58c89848701016123ca565b818901528652505050918301918301612433565b509695505050505050565b803560048110611e0557600080fd5b600082601f8301126124e457600080fd5b813560206124f461240b83612350565b82815260059290921b8401810191818101908684111561251357600080fd5b8286015b848110156124b95780356001600160401b03808211156125375760008081fd5b9088019060a0828b03601f19018113156125515760008081fd5b6125596122dc565b878401358152604061256c8186016124c4565b8983015260608086013582840152608091508186013581840152508285013592508383111561259b5760008081fd5b6125a98d8a858801016123ca565b908201528652505050918301918301612517565b600082601f8301126125ce57600080fd5b813560206125de61240b83612350565b82815260059290921b840181019181810190868411156125fd57600080fd5b8286015b848110156124b95780358352918301918301612601565b600082601f83011261262957600080fd5b8135602061263961240b83612350565b828152600592831b850182019282820191908785111561265857600080fd5b8387015b858110156127305780356001600160401b038082111561267c5760008081fd5b908901906040828c03601f19018113156126965760008081fd5b61269e6122b4565b88840135815281840135838111156126b65760008081fd5b8085019450508c603f8501126126ce57600092508283fd5b8884013592506126e061240b84612350565b83815292861b8401820192898101908e8511156126fd5760008081fd5b948301945b8486101561271b5785358252948a0194908a0190612702565b828b015250875250505092840192840161265c565b5090979650505050505050565b600082601f83011261274e57600080fd5b8135602061275e61240b83612350565b82815260059290921b8401810191818101908684111561277d57600080fd5b8286015b848110156124b95780356001600160401b038111156127a05760008081fd5b8701603f810189136127b25760008081fd5b6127c3898683013560408401612373565b845250918301918301612781565b600060e082840312156127e357600080fd5b6127eb6122fe565b90506127f682611dfa565b815260208281013590820152604080830135908201526060808301359082015260808201356001600160401b038082111561283057600080fd5b61283c858386016125bd565b608084015260a084013591508082111561285557600080fd5b61286185838601612618565b60a084015260c084013591508082111561287a57600080fd5b506128878482850161273d565b60c08301525092915050565b60006128a161240b84612350565b8381529050602080820190600585901b8401868111156128c057600080fd5b845b818110156129b75780356001600160401b03808211156128e25760008081fd5b9087019060e0828b0312156128f75760008081fd5b6128ff6122fe565b61290883611dfa565b8152612915868401611dfa565b868201526040612926818501611dfa565b9082015260608381013590820152608080840135838111156129485760008081fd5b6129548d8287016123ea565b82840152505060a0808401358381111561296e5760008081fd5b61297a8d8287016124d3565b82840152505060c080840135838111156129945760008081fd5b6129a08d8287016127d1565b9183019190915250865250509282019282016128c2565b505050509392505050565b600080600080600080600060c0888a0312156129dd57600080fd5b87356129e881611de2565b965060208801356129f881611de2565b9550604088013594506060880135935060808801356001600160401b0380821115612a2257600080fd5b818a0191508a601f830112612a3657600080fd5b612a458b833560208501612893565b945060a08a0135915080821115612a5b57600080fd5b50612a688a828b01611e85565b989b979a50959850939692959293505050565b60008060008060008060a08789031215612a9457600080fd5b8635612a9f81611de2565b95506020870135612aaf81611de2565b9450604087013593506060870135925060808701356001600160401b03811115612ad857600080fd5b612ae489828a01611e85565b979a9699509497509295939492505050565b600060208284031215612b0857600080fd5b815161189481611de2565b600060208284031215612b2557600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b600082821015612b5457612b54612b2c565b500390565b6020808252818101527f496e636f72726563742062616c616e6365206166746572207472616e73666572604082015260600190565b6000808335601e19843603018112612ba557600080fd5b83016020810192503590506001600160401b03811115612bc457600080fd5b8060051b3603821315611e7e57600080fd5b6000808335601e19843603018112612bed57600080fd5b83016020810192503590506001600160401b03811115612c0c57600080fd5b803603821315611e7e57600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60008235603e19833603018112612c5a57600080fd5b90910192915050565b60008383855260208086019550808560051b8301018460005b8781101561273057848303601f19018952612c978288612c44565b60408135612ca481611de2565b6001600160a01b03168552612cbb82870183612bd6565b92508187870152612ccf8287018483612c1b565b9b87019b955050509184019150600101612c7c565b60048110612d0257634e487b7160e01b600052602160045260246000fd5b9052565b81835260006020808501808196508560051b81019150846000805b88811015612dad578385038a528235609e19893603018112612d41578283fd5b88018035865260a0612d548883016124c4565b612d6089890182612ce4565b5060408281013590880152606080830135908801526080612d8381840184612bd6565b935082828a0152612d97838a018583612c1b565b9d8a019d98505050938701935050600101612d21565b509298975050505050505050565b6000823560de19833603018112612c5a57600080fd5b81835260006001600160fb1b03831115612dea57600080fd5b8260051b8083602087013760009401602001938452509192915050565b60008383855260208086019550808560051b8301018460005b8781101561273057848303601f19018952612e3b8288612bd6565b612e46858284612c1b565b9a86019a9450505090830190600101612e20565b60008135612e6781611de2565b6001600160a01b03168352602082810135818501526040808401358186015260608085013590860152612e9d6080850185612b8e565b60e06080880152612eb260e088018284612dd1565b915050612ec260a0860186612b8e565b87830360a0890152808352848301600582901b840186018360005b84811015612f3057868303601f19018452612ef88287612c44565b80358452612f088a820182612b8e565b9150898b860152612f1c8a86018383612dd1565b958b01959450505090880190600101612edd565b5050612f3f60c08a018a612b8e565b9750955089810360c08b0152612f56818888612e07565b9a9950505050505050505050565b81835260006020808501808196508560051b810191508460005b8781101561306a578284038952612f958288612dbb565b60e08135612fa281611de2565b6001600160a01b03168652612fb8828801611dfa565b612fc488880182611fb3565b506040612fd2818401611dfa565b612fde82890182611fb3565b5050606082810135908701526080612ff881840184612b8e565b83838a015261300a848a018284612c63565b935050505060a061301d81840184612b8e565b888403838a015261302f848284612d06565b935050505060c061304281840184612dbb565b925086820381880152506130568183612e5a565b9a87019a9550505090840190600101612f7e565b5091979650505050505050565b8681526001600160a01b03861660208201526080604082018190526000906130a29083018688612f64565b82810360608401526130b5818587612c1b565b9998505050505050505050565b6000611894368484612893565b600181811c908216806130e357607f821691505b60208210810361310357634e487b7160e01b600052602260045260246000fd5b50919050565b60208082526027908201527f50726f706f73616c734875623a3a50726f706f73616c20616c726561647920656040820152661e1958dd5d195960ca1b606082015260800190565b848152836020820152606060408201526000613170606083018486612f64565b9695505050505050565b602080825260179082015276141c9bdc1bdcd85b08191bd95cc81b9bdd08195e1a5cdd604a1b604082015260600190565b60208082526031908201527f50726f706f73616c20646f6573206e6f7420696e636c756465207468697320746040820152701bdad95b881d1bc8189948199d5b991959607a1b606082015260800190565b602080825260159082015274416d6f756e742063616e6e6f74206265207a65726f60581b604082015260600190565b9182526001600160a01b0316602082015260400190565b6000821982111561325557613255612b2c565b500190565b6001600160a01b03868116825285166020820152604081018490526060810183905260a060808201819052600090611cdb90830184611fec565b6020808252602a908201527f50726f706f73616c734875623a3a44617461206973206e6f742076616c6964206040820152691c1c9bdc1bdcd85b125960b21b606082015260800190565b6020808252602c908201527f50726f706f73616c734875623a3a50726f706f73616c20686173206e6f74206260408201526b19595b88195e1958dd5d195960a21b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b60006001820161335257613352612b2c565b5060010190565b600081518084526020808501808196508360051b8101915082860160005b8581101561306a578284038952815180516001600160a01b0316855285015160408686018190526133aa81870183611fec565b9a87019a9550505090840190600101613377565b600081518084526020808501808196508360051b8101915082860160005b8581101561306a578284038952815160a0815186528682015161340188880182612ce4565b50604082810151908701526060808301519087015260809182015191860181905261342e81870183611fec565b9a87019a95505050908401906001016133dc565b600081518084526020808501808196508360051b810191508286016000805b86811015612dad578385038a528251805186528601516040878701819052815190870181905290870190606087019084905b808210156134b35783518352928901929189019160019190910190613493565b50509a87019a95505091850191600101613461565b600082825180855260208086019550808260051b84010181860160005b8481101561273057601f19868403018952613501838351611fec565b988401989250908301906001016134e5565b80516001600160a01b0316825260208082015181840152604080830151908401526060808301519084015260808083015160e091850182905280519185018290526000929081019183906101008701905b808310156135845784518252938301936001929092019190830190613564565b5060a0860151935086810360a088015261359e8185613442565b935050505060c083015184820360c08601526135ba82826134c8565b95945050505050565b6000604080830185845260208281860152818651808452606093508387019150838160051b88010183890160005b8381101561369c57898303605f19018552815180516001600160a01b0390811685528782015116878501528881015160e09061362f8b870182611fb3565b508882015189860152608080830151828288015261364f83880182613359565b9250505060a0808301518683038288015261366a83826133be565b9250505060c080830151925085820381870152506136888183613513565b9688019694505050908501906001016135f1565b50909a9950505050505050505050565b6000602082840312156136be57600080fd5b8151801515811461189457600080fd5b8481526060602082015260006136e8606083018587612c1b565b905082604083015295945050505050565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052600160045260246000fd5b60008251613737818460208701611fc0565b919091019291505056fea2646970667358221220b7cb93258e5758ffb200d36a221557b6b701d62f8c75788a0695079004c212cc64736f6c634300080e0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createProposal(address,address,uint256,bytes32,(address,address,address,uint256,(address,bytes)[],(uint256,uint8,bytes32,uint256,bytes)[],(address,uint256,uint256,bytes32,uint256[],(bytes32,bytes32[])[],string[]))[],string)": {
        "details": "Creates a Proposal from an existing Solution.Base",
        "params": {
          "collateralToken": "ERC20 token being used as collateral for conditional tokens",
          "fundingGoal": "Amount of ERC20 collateral requested for the Proposal",
          "safeBaseId": "ID of the Solution.Base for which a new instance and proposal is created",
          "solutionsHub": "Address of the SolutionsHub contract managing the Solution"
        }
      },
      "defundProposal(bytes32,address,uint256)": {
        "details": "Called by user to remove their funding from a Proposal",
        "params": {
          "amount": "Amount to be defunded",
          "proposalId": "ID of Proposal being defunded",
          "token": "ERC20 token to be defunded"
        }
      },
      "executeIPFSProposal(bytes32,(address,address,address,uint256,(address,bytes)[],(uint256,uint8,bytes32,uint256,bytes)[],(address,uint256,uint256,bytes32,uint256[],(bytes32,bytes32[])[],string[]))[])": {
        "details": "Executes a proposal for Solutions where on the *hash* of solver configs is stored on-chain",
        "params": {
          "proposalId": "ID of proposal",
          "solverConfigs": "Configurations of Solvers to be run for the proposed solution"
        }
      },
      "fundProposal(bytes32,address,uint256)": {
        "details": "Called by user to add funding to a Proposal",
        "params": {
          "amount": "Amount to be funded",
          "proposalId": "ID of Proposal being funded",
          "token": "ERC20 token to be funded with"
        }
      },
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
        "details": "Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81, or its own function selector).",
        "params": {
          "data": "Additional data with no specified format",
          "from": "The address which previously owned the token",
          "ids": "An array containing ids of each token being transferred (order and length must match values array)",
          "operator": "The address which initiated the batch transfer (i.e. msg.sender)",
          "values": "An array containing amounts of each token being transferred (order and length must match ids array)"
        },
        "returns": {
          "_0": "`bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed"
        }
      },
      "reclaimTokens(bytes32,uint256)": {
        "details": "Transfers reclaimable CTs to a claimer and lowers their reclaimable balance for that token",
        "params": {
          "proposalId": "ID of proposal being reclaimed from",
          "tokenId": "ERC1155 token being reclaimed"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "transferERC20(bytes32,address)": {
        "details": "Called by SolutionsHub after deploying Solvers",
        "params": {
          "proposalId": "Proposal that collateral is being transferred from",
          "solver": "Solver receiving collateral"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "createProposal(address,address,uint256,bytes32,(address,address,address,uint256,(address,bytes)[],(uint256,uint8,bytes32,uint256,bytes)[],(address,uint256,uint256,bytes32,uint256[],(bytes32,bytes32[])[],string[]))[],string)": {
        "notice": "Ceramic Interop: safeBaseId == keccak256(abi.encode(keccak256(abi.encode(templateCommitID, proposalCommitID)), nonce))"
      },
      "onERC1155Received(address,address,uint256,uint256,bytes)": {
        "notice": "IMPORTANT! Any CTs sent to this contract are reclaimable by the funders in proportion to their funding. If a user reclaims CTs and sends them back again to this contract, they will only be able to  regain from them a fraction of their original funding."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7469,
        "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
        "label": "nonces",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 7494,
        "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
        "label": "proposals",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_struct(Proposal)7489_storage)"
      },
      {
        "astId": 7500,
        "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
        "label": "funderAmountMap",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 7506,
        "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
        "label": "reclaimableTokens",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_bytes32,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 7512,
        "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
        "label": "reclaimedTokens",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_uint256))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IERC20)1755": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_bytes32,t_struct(Proposal)7489_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct ProposalsHub.Proposal)",
        "numberOfBytes": "32",
        "value": "t_struct(Proposal)7489_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Proposal)7489_storage": {
        "encoding": "inplace",
        "label": "struct ProposalsHub.Proposal",
        "members": [
          {
            "astId": 7471,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "isExecuted",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 7474,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "collateralToken",
            "offset": 1,
            "slot": "0",
            "type": "t_contract(IERC20)1755"
          },
          {
            "astId": 7476,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "proposer",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 7478,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "solutionsHub",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 7480,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "id",
            "offset": 0,
            "slot": "3",
            "type": "t_bytes32"
          },
          {
            "astId": 7482,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "solutionId",
            "offset": 0,
            "slot": "4",
            "type": "t_bytes32"
          },
          {
            "astId": 7484,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "funding",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 7486,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "fundingGoal",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 7488,
            "contract": "contracts/hubs/ProposalsHub.sol:ProposalsHub",
            "label": "metadataURI",
            "offset": 0,
            "slot": "7",
            "type": "t_string_storage"
          }
        ],
        "numberOfBytes": "256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}