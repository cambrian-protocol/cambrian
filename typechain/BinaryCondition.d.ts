/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface BinaryConditionInterface extends ethers.utils.Interface {
  functions: {
    "PPM()": FunctionFragment;
    "PPM100()": FunctionFragment;
    "_binaryIndexSets(uint256)": FunctionFragment;
    "_binaryOutcomeSlots()": FunctionFragment;
    "_binaryPartition(uint256)": FunctionFragment;
    "avatar()": FunctionFragment;
    "conditionalTokens()": FunctionFragment;
    "createBinaryCondition(address,bytes32,bytes32,address)": FunctionFragment;
    "fee()": FunctionFragment;
    "initialize(address,address,uint256)": FunctionFragment;
    "initialized()": FunctionFragment;
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "oracle()": FunctionFragment;
    "redeemPositions(address,bytes32,bytes32,bool,address,address,uint256)": FunctionFragment;
    "rescueTokens(address,uint256,address)": FunctionFragment;
    "setApproval(address,bool)": FunctionFragment;
    "setFee(uint256)": FunctionFragment;
    "setOracle(address)": FunctionFragment;
    "splitBinaryCondition(address,bytes32,bytes32,address,uint256,address)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "PPM", values?: undefined): string;
  encodeFunctionData(functionFragment: "PPM100", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "_binaryIndexSets",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "_binaryOutcomeSlots",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_binaryPartition",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "avatar", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "conditionalTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "createBinaryCondition",
    values: [string, BytesLike, BytesLike, string]
  ): string;
  encodeFunctionData(functionFragment: "fee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialized",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "oracle", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "redeemPositions",
    values: [
      string,
      BytesLike,
      BytesLike,
      boolean,
      string,
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "rescueTokens",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setApproval",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "setOracle", values: [string]): string;
  encodeFunctionData(
    functionFragment: "splitBinaryCondition",
    values: [string, BytesLike, BytesLike, string, BigNumberish, string]
  ): string;

  decodeFunctionResult(functionFragment: "PPM", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "PPM100", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_binaryIndexSets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_binaryOutcomeSlots",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_binaryPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "avatar", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "conditionalTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createBinaryCondition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fee", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initialized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "oracle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redeemPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rescueTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApproval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setFee", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setOracle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "splitBinaryCondition",
    data: BytesLike
  ): Result;

  events: {
    "FeeSet(uint256)": EventFragment;
    "OracleSet(address)": EventFragment;
    "RedeemFail(bytes32,uint256,address)": EventFragment;
    "RedeemSuccess(bytes32,address,uint256,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "FeeSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RedeemFail"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RedeemSuccess"): EventFragment;
}

export class BinaryCondition extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: BinaryConditionInterface;

  functions: {
    PPM(overrides?: CallOverrides): Promise<[number]>;

    PPM100(overrides?: CallOverrides): Promise<[BigNumber]>;

    _binaryIndexSets(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    _binaryOutcomeSlots(overrides?: CallOverrides): Promise<[BigNumber]>;

    _binaryPartition(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    avatar(overrides?: CallOverrides): Promise<[string]>;

    conditionalTokens(overrides?: CallOverrides): Promise<[string]>;

    createBinaryCondition(
      _oracle: string,
      _questionId: BytesLike,
      _parentCollectionId: BytesLike,
      _collateralToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fee(overrides?: CallOverrides): Promise<[BigNumber]>;

    initialize(
      _avatar: string,
      _conditionalTokens: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initialized(overrides?: CallOverrides): Promise<[boolean]>;

    onERC1155BatchReceived(
      operator: string,
      from: string,
      ids: BigNumberish[],
      values: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    onERC1155Received(
      operator: string,
      from: string,
      id: BigNumberish,
      value: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    oracle(overrides?: CallOverrides): Promise<[string]>;

    redeemPositions(
      _collateralToken: string,
      _parentCollectionId: BytesLike,
      _conditionId: BytesLike,
      _success: boolean,
      _dao: string,
      _jv: string,
      _balance: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rescueTokens(
      _token: string,
      _amount: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setApproval(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setFee(
      _newFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setOracle(
      _oracle: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    splitBinaryCondition(
      _oracle: string,
      _questionId: BytesLike,
      _parentCollectionId: BytesLike,
      _collateralToken: string,
      _amount: BigNumberish,
      _jv: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  PPM(overrides?: CallOverrides): Promise<number>;

  PPM100(overrides?: CallOverrides): Promise<BigNumber>;

  _binaryIndexSets(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  _binaryOutcomeSlots(overrides?: CallOverrides): Promise<BigNumber>;

  _binaryPartition(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  avatar(overrides?: CallOverrides): Promise<string>;

  conditionalTokens(overrides?: CallOverrides): Promise<string>;

  createBinaryCondition(
    _oracle: string,
    _questionId: BytesLike,
    _parentCollectionId: BytesLike,
    _collateralToken: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fee(overrides?: CallOverrides): Promise<BigNumber>;

  initialize(
    _avatar: string,
    _conditionalTokens: string,
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initialized(overrides?: CallOverrides): Promise<boolean>;

  onERC1155BatchReceived(
    operator: string,
    from: string,
    ids: BigNumberish[],
    values: BigNumberish[],
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  onERC1155Received(
    operator: string,
    from: string,
    id: BigNumberish,
    value: BigNumberish,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  oracle(overrides?: CallOverrides): Promise<string>;

  redeemPositions(
    _collateralToken: string,
    _parentCollectionId: BytesLike,
    _conditionId: BytesLike,
    _success: boolean,
    _dao: string,
    _jv: string,
    _balance: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rescueTokens(
    _token: string,
    _amount: BigNumberish,
    to: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setApproval(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setFee(
    _newFee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setOracle(
    _oracle: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  splitBinaryCondition(
    _oracle: string,
    _questionId: BytesLike,
    _parentCollectionId: BytesLike,
    _collateralToken: string,
    _amount: BigNumberish,
    _jv: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    PPM(overrides?: CallOverrides): Promise<number>;

    PPM100(overrides?: CallOverrides): Promise<BigNumber>;

    _binaryIndexSets(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _binaryOutcomeSlots(overrides?: CallOverrides): Promise<BigNumber>;

    _binaryPartition(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    avatar(overrides?: CallOverrides): Promise<string>;

    conditionalTokens(overrides?: CallOverrides): Promise<string>;

    createBinaryCondition(
      _oracle: string,
      _questionId: BytesLike,
      _parentCollectionId: BytesLike,
      _collateralToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    fee(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _avatar: string,
      _conditionalTokens: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    initialized(overrides?: CallOverrides): Promise<boolean>;

    onERC1155BatchReceived(
      operator: string,
      from: string,
      ids: BigNumberish[],
      values: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC1155Received(
      operator: string,
      from: string,
      id: BigNumberish,
      value: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    oracle(overrides?: CallOverrides): Promise<string>;

    redeemPositions(
      _collateralToken: string,
      _parentCollectionId: BytesLike,
      _conditionId: BytesLike,
      _success: boolean,
      _dao: string,
      _jv: string,
      _balance: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    rescueTokens(
      _token: string,
      _amount: BigNumberish,
      to: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setApproval(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setFee(_newFee: BigNumberish, overrides?: CallOverrides): Promise<void>;

    setOracle(_oracle: string, overrides?: CallOverrides): Promise<void>;

    splitBinaryCondition(
      _oracle: string,
      _questionId: BytesLike,
      _parentCollectionId: BytesLike,
      _collateralToken: string,
      _amount: BigNumberish,
      _jv: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    FeeSet(
      fee?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { fee: BigNumber }>;

    OracleSet(
      oracle?: string | null
    ): TypedEventFilter<[string], { oracle: string }>;

    RedeemFail(
      conditionId?: BytesLike | null,
      payeeAmount?: null,
      avatar?: null
    ): TypedEventFilter<
      [string, BigNumber, string],
      { conditionId: string; payeeAmount: BigNumber; avatar: string }
    >;

    RedeemSuccess(
      conditionId?: BytesLike | null,
      payee?: string | null,
      payeeAmount?: null,
      avatar?: null,
      feeAmount?: null
    ): TypedEventFilter<
      [string, string, BigNumber, string, BigNumber],
      {
        conditionId: string;
        payee: string;
        payeeAmount: BigNumber;
        avatar: string;
        feeAmount: BigNumber;
      }
    >;
  };

  estimateGas: {
    PPM(overrides?: CallOverrides): Promise<BigNumber>;

    PPM100(overrides?: CallOverrides): Promise<BigNumber>;

    _binaryIndexSets(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _binaryOutcomeSlots(overrides?: CallOverrides): Promise<BigNumber>;

    _binaryPartition(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    avatar(overrides?: CallOverrides): Promise<BigNumber>;

    conditionalTokens(overrides?: CallOverrides): Promise<BigNumber>;

    createBinaryCondition(
      _oracle: string,
      _questionId: BytesLike,
      _parentCollectionId: BytesLike,
      _collateralToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fee(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _avatar: string,
      _conditionalTokens: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initialized(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155BatchReceived(
      operator: string,
      from: string,
      ids: BigNumberish[],
      values: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    onERC1155Received(
      operator: string,
      from: string,
      id: BigNumberish,
      value: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<BigNumber>;

    redeemPositions(
      _collateralToken: string,
      _parentCollectionId: BytesLike,
      _conditionId: BytesLike,
      _success: boolean,
      _dao: string,
      _jv: string,
      _balance: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rescueTokens(
      _token: string,
      _amount: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setApproval(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setFee(
      _newFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setOracle(
      _oracle: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    splitBinaryCondition(
      _oracle: string,
      _questionId: BytesLike,
      _parentCollectionId: BytesLike,
      _collateralToken: string,
      _amount: BigNumberish,
      _jv: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    PPM(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PPM100(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _binaryIndexSets(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _binaryOutcomeSlots(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _binaryPartition(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    avatar(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    conditionalTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    createBinaryCondition(
      _oracle: string,
      _questionId: BytesLike,
      _parentCollectionId: BytesLike,
      _collateralToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _avatar: string,
      _conditionalTokens: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initialized(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    onERC1155BatchReceived(
      operator: string,
      from: string,
      ids: BigNumberish[],
      values: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    onERC1155Received(
      operator: string,
      from: string,
      id: BigNumberish,
      value: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeemPositions(
      _collateralToken: string,
      _parentCollectionId: BytesLike,
      _conditionId: BytesLike,
      _success: boolean,
      _dao: string,
      _jv: string,
      _balance: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rescueTokens(
      _token: string,
      _amount: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setApproval(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setFee(
      _newFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setOracle(
      _oracle: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    splitBinaryCondition(
      _oracle: string,
      _questionId: BytesLike,
      _parentCollectionId: BytesLike,
      _collateralToken: string,
      _amount: BigNumberish,
      _jv: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
